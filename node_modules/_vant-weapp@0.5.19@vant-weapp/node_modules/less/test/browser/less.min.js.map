{"version":3,"file":"less.min.js","sources":["../../lib/less-browser/utils.js","../../lib/less-browser/browser.js","../../lib/less/data/colors.js","../../lib/less/data/unit-conversions.js","../../lib/less/data/index.js","../../lib/less/tree/node.js","../../lib/less/tree/color.js","../../lib/less/tree/paren.js","../../lib/less/tree/combinator.js","../../lib/less/tree/element.js","../../lib/less/constants.js","../../node_modules/clone/clone.js","../../lib/less/utils.js","../../lib/less/less-error.js","../../lib/less/tree/selector.js","../../lib/less/tree/value.js","../../lib/less/tree/keyword.js","../../lib/less/tree/anonymous.js","../../lib/less/tree/declaration.js","../../lib/less/tree/debug-info.js","../../lib/less/tree/comment.js","../../lib/less/contexts.js","../../lib/less/functions/function-registry.js","../../lib/less/functions/default.js","../../lib/less/tree/ruleset.js","../../lib/less/tree/atrule.js","../../lib/less/tree/detached-ruleset.js","../../lib/less/tree/unit.js","../../lib/less/tree/dimension.js","../../lib/less/tree/operation.js","../../lib/less/tree/expression.js","../../lib/less/functions/function-caller.js","../../lib/less/tree/call.js","../../lib/less/tree/variable.js","../../lib/less/tree/property.js","../../lib/less/tree/attribute.js","../../lib/less/tree/quoted.js","../../lib/less/tree/url.js","../../lib/less/tree/media.js","../../lib/less/tree/import.js","../../lib/less/tree/js-eval-node.js","../../lib/less/tree/javascript.js","../../lib/less/tree/assignment.js","../../lib/less/tree/condition.js","../../lib/less/tree/unicode-descriptor.js","../../lib/less/tree/negative.js","../../lib/less/tree/extend.js","../../lib/less/tree/variable-call.js","../../lib/less/tree/namespace-value.js","../../lib/less/tree/mixin-definition.js","../../lib/less/tree/mixin-call.js","../../lib/less/tree/index.js","../../lib/less/logger.js","../../lib/less/environment/environment.js","../../lib/less/environment/abstract-file-manager.js","../../lib/less/environment/abstract-plugin-loader.js","../../lib/less/visitors/visitor.js","../../lib/less/visitors/import-sequencer.js","../../lib/less/visitors/import-visitor.js","../../lib/less/visitors/set-tree-visibility-visitor.js","../../lib/less/visitors/extend-visitor.js","../../lib/less/visitors/join-selector-visitor.js","../../lib/less/visitors/to-css-visitor.js","../../lib/less/visitors/index.js","../../lib/less/parser/parser-input.js","../../lib/less/parser/chunker.js","../../lib/less/parser/parser.js","../../lib/less/functions/color.js","../../lib/less/functions/boolean.js","../../lib/less/functions/color-blending.js","../../lib/less/functions/list.js","../../lib/less/functions/math-helper.js","../../lib/less/functions/math.js","../../lib/less/functions/number.js","../../lib/less/plugin-manager.js","../../lib/less/functions/string.js","../../lib/less/functions/types.js","../../lib/less/functions/index.js","../../lib/less/functions/data-uri.js","../../lib/less/functions/svg.js","../../lib/less/transform-tree.js","../../lib/less-browser/file-manager.js","../../lib/less/index.js","../../lib/less/source-map-output.js","../../lib/less/source-map-builder.js","../../lib/less/parse-tree.js","../../lib/less/import-manager.js","../../lib/less/render.js","../../lib/less/parse.js","../../lib/less-browser/plugin-loader.js","../../lib/less-browser/error-reporting.js","../../lib/less-browser/bootstrap.js","../../lib/less/default-options.js","../../lib/less-browser/add-default-options.js","../../lib/less-browser/index.js","../../lib/less-browser/log-listener.js","../../lib/less-browser/cache.js","../../lib/less-browser/image-size.js"],"sourcesContent":["\nexport function extractId(href) {\n    return href.replace(/^[a-z-]+:\\/+?[^\\/]+/, '')  // Remove protocol & domain\n        .replace(/[\\?\\&]livereload=\\w+/, '')        // Remove LiveReload cachebuster\n        .replace(/^\\//, '')                         // Remove root /\n        .replace(/\\.[a-zA-Z]+$/, '')                // Remove simple extension\n        .replace(/[^\\.\\w-]+/g, '-')                 // Replace illegal characters\n        .replace(/\\./g, ':');                       // Replace dots with colons(for valid id)\n}\n\nexport function addDataAttr(options, tag) {\n    for (const opt in tag.dataset) {\n        if (tag.dataset.hasOwnProperty(opt)) {\n            if (opt === 'env' || opt === 'dumpLineNumbers' || opt === 'rootpath' || opt === 'errorReporting') {\n                options[opt] = tag.dataset[opt];\n            } else {\n                try {\n                    options[opt] = JSON.parse(tag.dataset[opt]);\n                }\n                catch (_) {}\n            }\n        }\n    }\n}\n","import * as utils from './utils';\n\nexport default {\n    createCSS: function (document, styles, sheet) {\n        // Strip the query-string\n        const href = sheet.href || '';\n\n        // If there is no title set, use the filename, minus the extension\n        const id = `less:${sheet.title || utils.extractId(href)}`;\n\n        // If this has already been inserted into the DOM, we may need to replace it\n        const oldStyleNode = document.getElementById(id);\n        let keepOldStyleNode = false;\n\n        // Create a new stylesheet node for insertion or (if necessary) replacement\n        const styleNode = document.createElement('style');\n        styleNode.setAttribute('type', 'text/css');\n        if (sheet.media) {\n            styleNode.setAttribute('media', sheet.media);\n        }\n        styleNode.id = id;\n\n        if (!styleNode.styleSheet) {\n            styleNode.appendChild(document.createTextNode(styles));\n\n            // If new contents match contents of oldStyleNode, don't replace oldStyleNode\n            keepOldStyleNode = (oldStyleNode !== null && oldStyleNode.childNodes.length > 0 && styleNode.childNodes.length > 0 &&\n                oldStyleNode.firstChild.nodeValue === styleNode.firstChild.nodeValue);\n        }\n\n        const head = document.getElementsByTagName('head')[0];\n\n        // If there is no oldStyleNode, just append; otherwise, only append if we need\n        // to replace oldStyleNode with an updated stylesheet\n        if (oldStyleNode === null || keepOldStyleNode === false) {\n            const nextEl = sheet && sheet.nextSibling || null;\n            if (nextEl) {\n                nextEl.parentNode.insertBefore(styleNode, nextEl);\n            } else {\n                head.appendChild(styleNode);\n            }\n        }\n        if (oldStyleNode && keepOldStyleNode === false) {\n            oldStyleNode.parentNode.removeChild(oldStyleNode);\n        }\n\n        // For IE.\n        // This needs to happen *after* the style element is added to the DOM, otherwise IE 7 and 8 may crash.\n        // See http://social.msdn.microsoft.com/Forums/en-US/7e081b65-878a-4c22-8e68-c10d39c2ed32/internet-explorer-crashes-appending-style-element-to-head\n        if (styleNode.styleSheet) {\n            try {\n                styleNode.styleSheet.cssText = styles;\n            } catch (e) {\n                throw new Error('Couldn\\'t reassign styleSheet.cssText.');\n            }\n        }\n    },\n    currentScript: function(window) {\n        const document = window.document;\n        return document.currentScript || (() => {\n            const scripts = document.getElementsByTagName('script');\n            return scripts[scripts.length - 1];\n        })();\n    }\n};\n","export default {\n    'aliceblue':'#f0f8ff',\n    'antiquewhite':'#faebd7',\n    'aqua':'#00ffff',\n    'aquamarine':'#7fffd4',\n    'azure':'#f0ffff',\n    'beige':'#f5f5dc',\n    'bisque':'#ffe4c4',\n    'black':'#000000',\n    'blanchedalmond':'#ffebcd',\n    'blue':'#0000ff',\n    'blueviolet':'#8a2be2',\n    'brown':'#a52a2a',\n    'burlywood':'#deb887',\n    'cadetblue':'#5f9ea0',\n    'chartreuse':'#7fff00',\n    'chocolate':'#d2691e',\n    'coral':'#ff7f50',\n    'cornflowerblue':'#6495ed',\n    'cornsilk':'#fff8dc',\n    'crimson':'#dc143c',\n    'cyan':'#00ffff',\n    'darkblue':'#00008b',\n    'darkcyan':'#008b8b',\n    'darkgoldenrod':'#b8860b',\n    'darkgray':'#a9a9a9',\n    'darkgrey':'#a9a9a9',\n    'darkgreen':'#006400',\n    'darkkhaki':'#bdb76b',\n    'darkmagenta':'#8b008b',\n    'darkolivegreen':'#556b2f',\n    'darkorange':'#ff8c00',\n    'darkorchid':'#9932cc',\n    'darkred':'#8b0000',\n    'darksalmon':'#e9967a',\n    'darkseagreen':'#8fbc8f',\n    'darkslateblue':'#483d8b',\n    'darkslategray':'#2f4f4f',\n    'darkslategrey':'#2f4f4f',\n    'darkturquoise':'#00ced1',\n    'darkviolet':'#9400d3',\n    'deeppink':'#ff1493',\n    'deepskyblue':'#00bfff',\n    'dimgray':'#696969',\n    'dimgrey':'#696969',\n    'dodgerblue':'#1e90ff',\n    'firebrick':'#b22222',\n    'floralwhite':'#fffaf0',\n    'forestgreen':'#228b22',\n    'fuchsia':'#ff00ff',\n    'gainsboro':'#dcdcdc',\n    'ghostwhite':'#f8f8ff',\n    'gold':'#ffd700',\n    'goldenrod':'#daa520',\n    'gray':'#808080',\n    'grey':'#808080',\n    'green':'#008000',\n    'greenyellow':'#adff2f',\n    'honeydew':'#f0fff0',\n    'hotpink':'#ff69b4',\n    'indianred':'#cd5c5c',\n    'indigo':'#4b0082',\n    'ivory':'#fffff0',\n    'khaki':'#f0e68c',\n    'lavender':'#e6e6fa',\n    'lavenderblush':'#fff0f5',\n    'lawngreen':'#7cfc00',\n    'lemonchiffon':'#fffacd',\n    'lightblue':'#add8e6',\n    'lightcoral':'#f08080',\n    'lightcyan':'#e0ffff',\n    'lightgoldenrodyellow':'#fafad2',\n    'lightgray':'#d3d3d3',\n    'lightgrey':'#d3d3d3',\n    'lightgreen':'#90ee90',\n    'lightpink':'#ffb6c1',\n    'lightsalmon':'#ffa07a',\n    'lightseagreen':'#20b2aa',\n    'lightskyblue':'#87cefa',\n    'lightslategray':'#778899',\n    'lightslategrey':'#778899',\n    'lightsteelblue':'#b0c4de',\n    'lightyellow':'#ffffe0',\n    'lime':'#00ff00',\n    'limegreen':'#32cd32',\n    'linen':'#faf0e6',\n    'magenta':'#ff00ff',\n    'maroon':'#800000',\n    'mediumaquamarine':'#66cdaa',\n    'mediumblue':'#0000cd',\n    'mediumorchid':'#ba55d3',\n    'mediumpurple':'#9370d8',\n    'mediumseagreen':'#3cb371',\n    'mediumslateblue':'#7b68ee',\n    'mediumspringgreen':'#00fa9a',\n    'mediumturquoise':'#48d1cc',\n    'mediumvioletred':'#c71585',\n    'midnightblue':'#191970',\n    'mintcream':'#f5fffa',\n    'mistyrose':'#ffe4e1',\n    'moccasin':'#ffe4b5',\n    'navajowhite':'#ffdead',\n    'navy':'#000080',\n    'oldlace':'#fdf5e6',\n    'olive':'#808000',\n    'olivedrab':'#6b8e23',\n    'orange':'#ffa500',\n    'orangered':'#ff4500',\n    'orchid':'#da70d6',\n    'palegoldenrod':'#eee8aa',\n    'palegreen':'#98fb98',\n    'paleturquoise':'#afeeee',\n    'palevioletred':'#d87093',\n    'papayawhip':'#ffefd5',\n    'peachpuff':'#ffdab9',\n    'peru':'#cd853f',\n    'pink':'#ffc0cb',\n    'plum':'#dda0dd',\n    'powderblue':'#b0e0e6',\n    'purple':'#800080',\n    'rebeccapurple':'#663399',\n    'red':'#ff0000',\n    'rosybrown':'#bc8f8f',\n    'royalblue':'#4169e1',\n    'saddlebrown':'#8b4513',\n    'salmon':'#fa8072',\n    'sandybrown':'#f4a460',\n    'seagreen':'#2e8b57',\n    'seashell':'#fff5ee',\n    'sienna':'#a0522d',\n    'silver':'#c0c0c0',\n    'skyblue':'#87ceeb',\n    'slateblue':'#6a5acd',\n    'slategray':'#708090',\n    'slategrey':'#708090',\n    'snow':'#fffafa',\n    'springgreen':'#00ff7f',\n    'steelblue':'#4682b4',\n    'tan':'#d2b48c',\n    'teal':'#008080',\n    'thistle':'#d8bfd8',\n    'tomato':'#ff6347',\n    'turquoise':'#40e0d0',\n    'violet':'#ee82ee',\n    'wheat':'#f5deb3',\n    'white':'#ffffff',\n    'whitesmoke':'#f5f5f5',\n    'yellow':'#ffff00',\n    'yellowgreen':'#9acd32'\n};","export default {\n    length: {\n        'm': 1,\n        'cm': 0.01,\n        'mm': 0.001,\n        'in': 0.0254,\n        'px': 0.0254 / 96,\n        'pt': 0.0254 / 72,\n        'pc': 0.0254 / 72 * 12\n    },\n    duration: {\n        's': 1,\n        'ms': 0.001\n    },\n    angle: {\n        'rad': 1 / (2 * Math.PI),\n        'deg': 1 / 360,\n        'grad': 1 / 400,\n        'turn': 1\n    }\n};","import colors from './colors';\nimport unitConversions from './unit-conversions';\n\nexport default { colors, unitConversions };\n","class Node {\n    constructor() {\n        this.parent = null;\n        this.visibilityBlocks = undefined;\n        this.nodeVisible = undefined;\n        this.rootNode = null;\n        this.parsed = null;\n\n        const self = this;\n        Object.defineProperty(this, 'currentFileInfo', {\n            get: function() { return self.fileInfo(); }\n        });\n        Object.defineProperty(this, 'index', {\n            get: function() { return self.getIndex(); }\n        });\n\n    }\n\n    setParent(nodes, parent) {\n        function set(node) {\n            if (node && node instanceof Node) {\n                node.parent = parent;\n            }\n        }\n        if (Array.isArray(nodes)) {\n            nodes.forEach(set);\n        }\n        else {\n            set(nodes);\n        }\n    }\n\n    getIndex() {\n        return this._index || (this.parent && this.parent.getIndex()) || 0;\n    }\n\n    fileInfo() {\n        return this._fileInfo || (this.parent && this.parent.fileInfo()) || {};\n    }\n\n    isRulesetLike() {\n        return false;\n    }\n\n    toCSS(context) {\n        const strs = [];\n        this.genCSS(context, {\n            add: function(chunk, fileInfo, index) {\n                strs.push(chunk);\n            },\n            isEmpty: function () {\n                return strs.length === 0;\n            }\n        });\n        return strs.join('');\n    }\n\n    genCSS(context, output) {\n        output.add(this.value);\n    }\n\n    accept(visitor) {\n        this.value = visitor.visit(this.value);\n    }\n\n    eval() { return this; }\n\n    _operate(context, op, a, b) {\n        switch (op) {\n            case '+': return a + b;\n            case '-': return a - b;\n            case '*': return a * b;\n            case '/': return a / b;\n        }\n    }\n\n    fround(context, value) {\n        const precision = context && context.numPrecision;\n        // add \"epsilon\" to ensure numbers like 1.000000005 (represented as 1.000000004999...) are properly rounded:\n        return (precision) ? Number((value + 2e-16).toFixed(precision)) : value;\n    }\n\n    // Returns true if this node represents root of ast imported by reference\n    blocksVisibility() {\n        if (this.visibilityBlocks == null) {\n            this.visibilityBlocks = 0;\n        }\n        return this.visibilityBlocks !== 0;\n    }\n\n    addVisibilityBlock() {\n        if (this.visibilityBlocks == null) {\n            this.visibilityBlocks = 0;\n        }\n        this.visibilityBlocks = this.visibilityBlocks + 1;\n    }\n\n    removeVisibilityBlock() {\n        if (this.visibilityBlocks == null) {\n            this.visibilityBlocks = 0;\n        }\n        this.visibilityBlocks = this.visibilityBlocks - 1;\n    }\n\n    // Turns on node visibility - if called node will be shown in output regardless\n    // of whether it comes from import by reference or not\n    ensureVisibility() {\n        this.nodeVisible = true;\n    }\n\n    // Turns off node visibility - if called node will NOT be shown in output regardless\n    // of whether it comes from import by reference or not\n    ensureInvisibility() {\n        this.nodeVisible = false;\n    }\n\n    // return values:\n    // false - the node must not be visible\n    // true - the node must be visible\n    // undefined or null - the node has the same visibility as its parent\n    isVisible() {\n        return this.nodeVisible;\n    }\n\n    visibilityInfo() {\n        return {\n            visibilityBlocks: this.visibilityBlocks,\n            nodeVisible: this.nodeVisible\n        };\n    }\n\n    copyVisibilityInfo(info) {\n        if (!info) {\n            return;\n        }\n        this.visibilityBlocks = info.visibilityBlocks;\n        this.nodeVisible = info.nodeVisible;\n    }\n}\n\nNode.compare = (a, b) => {\n    /* returns:\n     -1: a < b\n     0: a = b\n     1: a > b\n     and *any* other value for a != b (e.g. undefined, NaN, -2 etc.) */\n\n    if ((a.compare) &&\n        // for \"symmetric results\" force toCSS-based comparison\n        // of Quoted or Anonymous if either value is one of those\n        !(b.type === 'Quoted' || b.type === 'Anonymous')) {\n        return a.compare(b);\n    } else if (b.compare) {\n        return -b.compare(a);\n    } else if (a.type !== b.type) {\n        return undefined;\n    }\n\n    a = a.value;\n    b = b.value;\n    if (!Array.isArray(a)) {\n        return a === b ? 0 : undefined;\n    }\n    if (a.length !== b.length) {\n        return undefined;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (Node.compare(a[i], b[i]) !== 0) {\n            return undefined;\n        }\n    }\n    return 0;\n};\n\nNode.numericCompare = (a, b) => a  <  b ? -1\n    : a === b ?  0\n        : a  >  b ?  1 : undefined;\nexport default Node;\n","import Node from './node';\nimport colors from '../data/colors';\n\n//\n// RGB Colors - #ff0014, #eee\n//\nclass Color extends Node {\n    constructor(rgb, a, originalForm) {\n        super();\n\n        const self = this;\n        //\n        // The end goal here, is to parse the arguments\n        // into an integer triplet, such as `128, 255, 0`\n        //\n        // This facilitates operations and conversions.\n        //\n        if (Array.isArray(rgb)) {\n            this.rgb = rgb;\n        } else if (rgb.length >= 6) {\n            this.rgb = [];\n            rgb.match(/.{2}/g).map((c, i) => {\n                if (i < 3) {\n                    self.rgb.push(parseInt(c, 16));\n                } else {\n                    self.alpha = (parseInt(c, 16)) / 255;\n                }\n            });\n        } else {\n            this.rgb = [];\n            rgb.split('').map((c, i) => {\n                if (i < 3) {\n                    self.rgb.push(parseInt(c + c, 16));\n                } else {\n                    self.alpha = (parseInt(c + c, 16)) / 255;\n                }\n            });\n        }\n        this.alpha = this.alpha || (typeof a === 'number' ? a : 1);\n        if (typeof originalForm !== 'undefined') {\n            this.value = originalForm;\n        }\n    }\n\n    luma() {\n        let r = this.rgb[0] / 255;\n        let g = this.rgb[1] / 255;\n        let b = this.rgb[2] / 255;\n\n        r = (r <= 0.03928) ? r / 12.92 : Math.pow(((r + 0.055) / 1.055), 2.4);\n        g = (g <= 0.03928) ? g / 12.92 : Math.pow(((g + 0.055) / 1.055), 2.4);\n        b = (b <= 0.03928) ? b / 12.92 : Math.pow(((b + 0.055) / 1.055), 2.4);\n\n        return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    }\n\n    genCSS(context, output) {\n        output.add(this.toCSS(context));\n    }\n\n    toCSS(context, doNotCompress) {\n        const compress = context && context.compress && !doNotCompress;\n        let color;\n        let alpha;\n        let colorFunction;\n        let args = [];\n\n        // `value` is set if this color was originally\n        // converted from a named color string so we need\n        // to respect this and try to output named color too.\n        alpha = this.fround(context, this.alpha);\n\n        if (this.value) {\n            if (this.value.indexOf('rgb') === 0) {\n                if (alpha < 1) {\n                    colorFunction = 'rgba';\n                }\n            } else if (this.value.indexOf('hsl') === 0) {\n                if (alpha < 1) {\n                    colorFunction = 'hsla';\n                } else {\n                    colorFunction = 'hsl';\n                }\n            } else {\n                return this.value;\n            }\n        } else {\n            if (alpha < 1) {\n                colorFunction = 'rgba';\n            }\n        }\n\n        switch (colorFunction) {\n            case 'rgba':\n                args = this.rgb.map(c => clamp(Math.round(c), 255)).concat(clamp(alpha, 1));\n                break;\n            case 'hsla':\n                args.push(clamp(alpha, 1));\n            case 'hsl':\n                color = this.toHSL();\n                args = [\n                    this.fround(context, color.h),\n                    `${this.fround(context, color.s * 100)}%`,\n                    `${this.fround(context, color.l * 100)}%`\n                ].concat(args);\n        }\n\n        if (colorFunction) {\n            // Values are capped between `0` and `255`, rounded and zero-padded.\n            return `${colorFunction}(${args.join(`,${compress ? '' : ' '}`)})`;\n        }\n\n        color = this.toRGB();\n\n        if (compress) {\n            const splitcolor = color.split('');\n\n            // Convert color to short format\n            if (splitcolor[1] === splitcolor[2] && splitcolor[3] === splitcolor[4] && splitcolor[5] === splitcolor[6]) {\n                color = `#${splitcolor[1]}${splitcolor[3]}${splitcolor[5]}`;\n            }\n        }\n\n        return color;\n    }\n\n    //\n    // Operations have to be done per-channel, if not,\n    // channels will spill onto each other. Once we have\n    // our result, in the form of an integer triplet,\n    // we create a new Color node to hold the result.\n    //\n    operate(context, op, other) {\n        const rgb = new Array(3);\n        const alpha = this.alpha * (1 - other.alpha) + other.alpha;\n        for (let c = 0; c < 3; c++) {\n            rgb[c] = this._operate(context, op, this.rgb[c], other.rgb[c]);\n        }\n        return new Color(rgb, alpha);\n    }\n\n    toRGB() {\n        return toHex(this.rgb);\n    }\n\n    toHSL() {\n        const r = this.rgb[0] / 255;\n        const g = this.rgb[1] / 255;\n        const b = this.rgb[2] / 255;\n        const a = this.alpha;\n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n        let h;\n        let s;\n        const l = (max + min) / 2;\n        const d = max - min;\n\n        if (max === min) {\n            h = s = 0;\n        } else {\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n            switch (max) {\n                case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n                case g: h = (b - r) / d + 2;               break;\n                case b: h = (r - g) / d + 4;               break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s, l, a };\n    }\n\n    // Adapted from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n    toHSV() {\n        const r = this.rgb[0] / 255;\n        const g = this.rgb[1] / 255;\n        const b = this.rgb[2] / 255;\n        const a = this.alpha;\n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n        let h;\n        let s;\n        const v = max;\n\n        const d = max - min;\n        if (max === 0) {\n            s = 0;\n        } else {\n            s = d / max;\n        }\n\n        if (max === min) {\n            h = 0;\n        } else {\n            switch (max) {\n                case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n                case g: h = (b - r) / d + 2; break;\n                case b: h = (r - g) / d + 4; break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s, v, a };\n    }\n\n    toARGB() {\n        return toHex([this.alpha * 255].concat(this.rgb));\n    }\n\n    compare(x) {\n        return (x.rgb &&\n            x.rgb[0] === this.rgb[0] &&\n            x.rgb[1] === this.rgb[1] &&\n            x.rgb[2] === this.rgb[2] &&\n            x.alpha  === this.alpha) ? 0 : undefined;\n    }\n}\n\nColor.prototype.type = 'Color';\n\nfunction clamp(v, max) {\n    return Math.min(Math.max(v, 0), max);\n}\n\nfunction toHex(v) {\n    return `#${v.map(c => {\n        c = clamp(Math.round(c), 255);\n        return (c < 16 ? '0' : '') + c.toString(16);\n    }).join('')}`;\n}\n\nColor.fromKeyword = keyword => {\n    let c;\n    const key = keyword.toLowerCase();\n    if (colors.hasOwnProperty(key)) {\n        c = new Color(colors[key].slice(1));\n    }\n    else if (key === 'transparent') {\n        c = new Color([0, 0, 0], 0);\n    }\n\n    if (c) {\n        c.value = keyword;\n        return c;\n    }\n};\nexport default Color;\n","import Node from './node';\n\nclass Paren extends Node {\n    constructor(node) {\n        super();\n\n        this.value = node;\n    }\n\n    genCSS(context, output) {\n        output.add('(');\n        this.value.genCSS(context, output);\n        output.add(')');\n    }\n\n    eval(context) {\n        return new Paren(this.value.eval(context));\n    }\n}\n\nParen.prototype.type = 'Paren';\nexport default Paren;\n","import Node from './node';\nconst _noSpaceCombinators = {\n    '': true,\n    ' ': true,\n    '|': true\n};\n\nclass Combinator extends Node {\n    constructor(value) {\n        super();\n\n        if (value === ' ') {\n            this.value = ' ';\n            this.emptyOrWhitespace = true;\n        } else {\n            this.value = value ? value.trim() : '';\n            this.emptyOrWhitespace = this.value === '';\n        }\n    }\n\n    genCSS(context, output) {\n        const spaceOrEmpty = (context.compress || _noSpaceCombinators[this.value]) ? '' : ' ';\n        output.add(spaceOrEmpty + this.value + spaceOrEmpty);\n    }\n}\n\nCombinator.prototype.type = 'Combinator';\n\nexport default Combinator;\n","import Node from './node';\nimport Paren from './paren';\nimport Combinator from './combinator';\n\nclass Element extends Node {\n    constructor(combinator, value, isVariable, index, currentFileInfo, visibilityInfo) {\n        super();\n\n        this.combinator = combinator instanceof Combinator ?\n            combinator : new Combinator(combinator);\n\n        if (typeof value === 'string') {\n            this.value = value.trim();\n        } else if (value) {\n            this.value = value;\n        } else {\n            this.value = '';\n        }\n        this.isVariable = isVariable;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.copyVisibilityInfo(visibilityInfo);\n        this.setParent(this.combinator, this);\n    }\n\n    accept(visitor) {\n        const value = this.value;\n        this.combinator = visitor.visit(this.combinator);\n        if (typeof value === 'object') {\n            this.value = visitor.visit(value);\n        }\n    }\n\n    eval(context) {\n        return new Element(this.combinator,\n            this.value.eval ? this.value.eval(context) : this.value,\n            this.isVariable,\n            this.getIndex(),\n            this.fileInfo(), this.visibilityInfo());\n    }\n\n    clone() {\n        return new Element(this.combinator,\n            this.value,\n            this.isVariable,\n            this.getIndex(),\n            this.fileInfo(), this.visibilityInfo());\n    }\n\n    genCSS(context, output) {\n        output.add(this.toCSS(context), this.fileInfo(), this.getIndex());\n    }\n\n    toCSS(context = {}) {\n        let value = this.value;\n        const firstSelector = context.firstSelector;\n        if (value instanceof Paren) {\n            // selector in parens should not be affected by outer selector\n            // flags (breaks only interpolated selectors - see #1973)\n            context.firstSelector = true;\n        }\n        value = value.toCSS ? value.toCSS(context) : value;\n        context.firstSelector = firstSelector;\n        if (value === '' && this.combinator.value.charAt(0) === '&') {\n            return '';\n        } else {\n            return this.combinator.toCSS(context) + value;\n        }\n    }\n}\n\nElement.prototype.type = 'Element';\nexport default Element;\n","\nexport const Math = {\n    ALWAYS: 0,\n    PARENS_DIVISION: 1,\n    PARENS: 2,\n    STRICT_LEGACY: 3\n};\n\nexport const RewriteUrls = {\n    OFF: 0,\n    LOCAL: 1,\n    ALL: 2\n};","var clone = (function() {\n'use strict';\n\nfunction _instanceof(obj, type) {\n  return type != null && obj instanceof type;\n}\n\nvar nativeMap;\ntry {\n  nativeMap = Map;\n} catch(_) {\n  // maybe a reference error because no `Map`. Give it a dummy value that no\n  // value will ever be an instanceof.\n  nativeMap = function() {};\n}\n\nvar nativeSet;\ntry {\n  nativeSet = Set;\n} catch(_) {\n  nativeSet = function() {};\n}\n\nvar nativePromise;\ntry {\n  nativePromise = Promise;\n} catch(_) {\n  nativePromise = function() {};\n}\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/\nfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    includeNonEnumerable = circular.includeNonEnumerable;\n    circular = circular.circular;\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      child = new nativeMap();\n    } else if (_instanceof(parent, nativeSet)) {\n      child = new nativeSet();\n    } else if (_instanceof(parent, nativePromise)) {\n      child = new nativePromise(function (resolve, reject) {\n        parent.then(function(value) {\n          resolve(_clone(value, depth - 1));\n        }, function(err) {\n          reject(_clone(err, depth - 1));\n        });\n      });\n    } else if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      if (Buffer.allocUnsafe) {\n        // Node.js >= 4.5.0\n        child = Buffer.allocUnsafe(parent.length);\n      } else {\n        // Older Node.js versions\n        child = new Buffer(parent.length);\n      }\n      parent.copy(child);\n      return child;\n    } else if (_instanceof(parent, Error)) {\n      child = Object.create(parent);\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      parent.forEach(function(value, key) {\n        var keyChild = _clone(key, depth - 1);\n        var valueChild = _clone(value, depth - 1);\n        child.set(keyChild, valueChild);\n      });\n    }\n    if (_instanceof(parent, nativeSet)) {\n      parent.forEach(function(value) {\n        var entryChild = _clone(value, depth - 1);\n        child.add(entryChild);\n      });\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(parent);\n      for (var i = 0; i < symbols.length; i++) {\n        // Don't need to worry about cloning a symbol because it is a primitive,\n        // like a number or string.\n        var symbol = symbols[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n          continue;\n        }\n        child[symbol] = _clone(parent[symbol], depth - 1);\n        if (!descriptor.enumerable) {\n          Object.defineProperty(child, symbol, {\n            enumerable: false\n          });\n        }\n      }\n    }\n\n    if (includeNonEnumerable) {\n      var allPropertyNames = Object.getOwnPropertyNames(parent);\n      for (var i = 0; i < allPropertyNames.length; i++) {\n        var propertyName = allPropertyNames[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n        if (descriptor && descriptor.enumerable) {\n          continue;\n        }\n        child[propertyName] = _clone(parent[propertyName], depth - 1);\n        Object.defineProperty(child, propertyName, {\n          enumerable: false\n        });\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n}\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n}\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n}\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n}\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n}\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n","/* jshint proto: true */\nimport * as Constants from './constants';\nimport CloneHelper from 'clone';\n\nexport function getLocation(index, inputStream) {\n    let n = index + 1;\n    let line = null;\n    let column = -1;\n\n    while (--n >= 0 && inputStream.charAt(n) !== '\\n') {\n        column++;\n    }\n\n    if (typeof index === 'number') {\n        line = (inputStream.slice(0, index).match(/\\n/g) || '').length;\n    }\n\n    return {\n        line,\n        column\n    };\n}\n\nexport function copyArray(arr) {\n    let i;\n    const length = arr.length;\n    const copy = new Array(length);\n\n    for (i = 0; i < length; i++) {\n        copy[i] = arr[i];\n    }\n    return copy;\n}\n\nexport function clone(obj) {\n    const cloned = {};\n    for (const prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n            cloned[prop] = obj[prop];\n        }\n    }\n    return cloned;\n}\n\nexport function defaults(obj1, obj2) {\n    let newObj = obj2 || {};\n    if (!obj2._defaults) {\n        newObj = {};\n        const defaults = CloneHelper(obj1);\n        newObj._defaults = defaults;\n        const cloned = obj2 ? CloneHelper(obj2) : {};\n        Object.assign(newObj, defaults, cloned);\n    }\n    return newObj;\n}\n\nexport function copyOptions(obj1, obj2) {\n    if (obj2 && obj2._defaults) {\n        return obj2;\n    }\n    const opts = defaults(obj1, obj2);\n    if (opts.strictMath) {\n        opts.math = Constants.Math.STRICT_LEGACY;\n    }\n    // Back compat with changed relativeUrls option\n    if (opts.relativeUrls) {\n        opts.rewriteUrls = Constants.RewriteUrls.ALL;\n    }\n    if (typeof opts.math === 'string') {\n        switch (opts.math.toLowerCase()) {\n            case 'always':\n                opts.math = Constants.Math.ALWAYS;\n                break;\n            case 'parens-division':\n                opts.math = Constants.Math.PARENS_DIVISION;\n                break;\n            case 'strict':\n            case 'parens':\n                opts.math = Constants.Math.PARENS;\n                break;\n            case 'strict-legacy':\n                opts.math = Constants.Math.STRICT_LEGACY;\n        }\n    }\n    if (typeof opts.rewriteUrls === 'string') {\n        switch (opts.rewriteUrls.toLowerCase()) {\n            case 'off':\n                opts.rewriteUrls = Constants.RewriteUrls.OFF;\n                break;\n            case 'local':\n                opts.rewriteUrls = Constants.RewriteUrls.LOCAL;\n                break;\n            case 'all':\n                opts.rewriteUrls = Constants.RewriteUrls.ALL;\n                break;\n        }\n    }\n    return opts;\n}\n\nexport function merge(obj1, obj2) {\n    for (const prop in obj2) {\n        if (obj2.hasOwnProperty(prop)) {\n            obj1[prop] = obj2[prop];\n        }\n    }\n    return obj1;\n}\n\nexport function flattenArray(arr, result = []) {\n    for (let i = 0, length = arr.length; i < length; i++) {\n        const value = arr[i];\n        if (Array.isArray(value)) {\n            flattenArray(value, result);\n        } else {\n            if (value !== undefined) {\n                result.push(value);\n            }\n        }\n    }\n    return result;\n}","import * as utils from './utils';\n/**\n * This is a centralized class of any error that could be thrown internally (mostly by the parser).\n * Besides standard .message it keeps some additional data like a path to the file where the error\n * occurred along with line and column numbers.\n *\n * @class\n * @extends Error\n * @type {module.LessError}\n *\n * @prop {string} type\n * @prop {string} filename\n * @prop {number} index\n * @prop {number} line\n * @prop {number} column\n * @prop {number} callLine\n * @prop {number} callExtract\n * @prop {string[]} extract\n *\n * @param {Object} e              - An error object to wrap around or just a descriptive object\n * @param {Object} fileContentMap - An object with file contents in 'contents' property (like importManager) @todo - move to fileManager?\n * @param {string} [currentFilename]\n */\nconst LessError = function LessError(e, fileContentMap, currentFilename) {\n    Error.call(this);\n\n    const filename = e.filename || currentFilename;\n\n    this.message = e.message;\n    this.stack = e.stack;\n\n    if (fileContentMap && filename) {\n        const input = fileContentMap.contents[filename];\n        const loc = utils.getLocation(e.index, input);\n        const line = loc.line;\n        const col  = loc.column;\n        const callLine = e.call && utils.getLocation(e.call, input).line;\n        const lines = input ? input.split('\\n') : '';\n\n        this.type = e.type || 'Syntax';\n        this.filename = filename;\n        this.index = e.index;\n        this.line = typeof line === 'number' ? line + 1 : null;\n        this.column = col;\n\n        if (!this.line && this.stack) {\n            const found = this.stack.match(/(<anonymous>|Function):(\\d+):(\\d+)/);\n\n            if (found) {\n                if (found[2]) {\n                    this.line = parseInt(found[2]) - 2;\n                }\n                if (found[3]) {\n                    this.column = parseInt(found[3]);\n                }\n            }\n        }\n\n        this.callLine = callLine + 1;\n        this.callExtract = lines[callLine];\n\n        this.extract = [\n            lines[this.line - 2],\n            lines[this.line - 1],\n            lines[this.line]\n        ];\n    }\n\n};\n\nif (typeof Object.create === 'undefined') {\n    const F = () => {};\n    F.prototype = Error.prototype;\n    LessError.prototype = new F();\n} else {\n    LessError.prototype = Object.create(Error.prototype);\n}\n\nLessError.prototype.constructor = LessError;\n\n/**\n * An overridden version of the default Object.prototype.toString\n * which uses additional information to create a helpful message.\n *\n * @param {Object} options\n * @returns {string}\n */\nLessError.prototype.toString = function(options = {}) {\n    let message = '';\n    const extract = this.extract || [];\n    let error = [];\n    let stylize = str => str;\n    if (options.stylize) {\n        const type = typeof options.stylize;\n        if (type !== 'function') {\n            throw Error(`options.stylize should be a function, got a ${type}!`);\n        }\n        stylize = options.stylize;\n    }\n\n    if (this.line !== null) {\n        if (typeof extract[0] === 'string') {\n            error.push(stylize(`${this.line - 1} ${extract[0]}`, 'grey'));\n        }\n\n        if (typeof extract[1] === 'string') {\n            let errorTxt = `${this.line} `;\n            if (extract[1]) {\n                errorTxt += extract[1].slice(0, this.column) +\n                    stylize(stylize(stylize(extract[1].substr(this.column, 1), 'bold') +\n                        extract[1].slice(this.column + 1), 'red'), 'inverse');\n            }\n            error.push(errorTxt);\n        }\n\n        if (typeof extract[2] === 'string') {\n            error.push(stylize(`${this.line + 1} ${extract[2]}`, 'grey'));\n        }\n        error = `${error.join('\\n') + stylize('', 'reset')}\\n`;\n    }\n\n    message += stylize(`${this.type}Error: ${this.message}`, 'red');\n    if (this.filename) {\n        message += stylize(' in ', 'red') + this.filename;\n    }\n    if (this.line) {\n        message += stylize(` on line ${this.line}, column ${this.column + 1}:`, 'grey');\n    }\n\n    message += `\\n${error}`;\n\n    if (this.callLine) {\n        message += `${stylize('from ', 'red') + (this.filename || '')}/n`;\n        message += `${stylize(this.callLine, 'grey')} ${this.callExtract}/n`;\n    }\n\n    return message;\n};\n\nexport default LessError;","import Node from './node';\nimport Element from './element';\nimport LessError from '../less-error';\n\nclass Selector extends Node {\n    constructor(elements, extendList, condition, index, currentFileInfo, visibilityInfo) {\n        super();\n\n        this.extendList = extendList;\n        this.condition = condition;\n        this.evaldCondition = !condition;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.elements = this.getElements(elements);\n        this.mixinElements_ = undefined;\n        this.copyVisibilityInfo(visibilityInfo);\n        this.setParent(this.elements, this);\n    }\n\n    accept(visitor) {\n        if (this.elements) {\n            this.elements = visitor.visitArray(this.elements);\n        }\n        if (this.extendList) {\n            this.extendList = visitor.visitArray(this.extendList);\n        }\n        if (this.condition) {\n            this.condition = visitor.visit(this.condition);\n        }\n    }\n\n    createDerived(elements, extendList, evaldCondition) {\n        elements = this.getElements(elements);\n        const newSelector = new Selector(elements, extendList || this.extendList,\n            null, this.getIndex(), this.fileInfo(), this.visibilityInfo());\n        newSelector.evaldCondition = (evaldCondition != null) ? evaldCondition : this.evaldCondition;\n        newSelector.mediaEmpty = this.mediaEmpty;\n        return newSelector;\n    }\n\n    getElements(els) {\n        if (!els) {\n            return [new Element('', '&', false, this._index, this._fileInfo)];\n        }\n        if (typeof els === 'string') {\n            this.parse.parseNode(\n                els, \n                ['selector'],\n                this._index, \n                this._fileInfo, \n                function(err, result) {\n                    if (err) {\n                        throw new LessError({\n                            index: err.index,\n                            message: err.message\n                        }, this.parse.imports, this._fileInfo.filename);\n                    }\n                    els = result[0].elements;\n                });\n        }\n        return els;\n    }\n\n    createEmptySelectors() {\n        const el = new Element('', '&', false, this._index, this._fileInfo);\n        const sels = [new Selector([el], null, null, this._index, this._fileInfo)];\n        sels[0].mediaEmpty = true;\n        return sels;\n    }\n\n    match(other) {\n        const elements = this.elements;\n        const len = elements.length;\n        let olen;\n        let i;\n\n        other = other.mixinElements();\n        olen = other.length;\n        if (olen === 0 || len < olen) {\n            return 0;\n        } else {\n            for (i = 0; i < olen; i++) {\n                if (elements[i].value !== other[i]) {\n                    return 0;\n                }\n            }\n        }\n\n        return olen; // return number of matched elements\n    }\n\n    mixinElements() {\n        if (this.mixinElements_) {\n            return this.mixinElements_;\n        }\n\n        let elements = this.elements.map( v => v.combinator.value + (v.value.value || v.value)).join('').match(/[,&#\\*\\.\\w-]([\\w-]|(\\\\.))*/g);\n\n        if (elements) {\n            if (elements[0] === '&') {\n                elements.shift();\n            }\n        } else {\n            elements = [];\n        }\n\n        return (this.mixinElements_ = elements);\n    }\n\n    isJustParentSelector() {\n        return !this.mediaEmpty &&\n            this.elements.length === 1 &&\n            this.elements[0].value === '&' &&\n            (this.elements[0].combinator.value === ' ' || this.elements[0].combinator.value === '');\n    }\n\n    eval(context) {\n        const evaldCondition = this.condition && this.condition.eval(context);\n        let elements = this.elements;\n        let extendList = this.extendList;\n\n        elements = elements && elements.map(e => e.eval(context));\n        extendList = extendList && extendList.map(extend => extend.eval(context));\n\n        return this.createDerived(elements, extendList, evaldCondition);\n    }\n\n    genCSS(context, output) {\n        let i;\n        let element;\n        if ((!context || !context.firstSelector) && this.elements[0].combinator.value === '') {\n            output.add(' ', this.fileInfo(), this.getIndex());\n        }\n        for (i = 0; i < this.elements.length; i++) {\n            element = this.elements[i];\n            element.genCSS(context, output);\n        }\n    }\n\n    getIsOutput() {\n        return this.evaldCondition;\n    }\n}\n\nSelector.prototype.type = 'Selector';\nexport default Selector;\n","import Node from './node';\n\nclass Value extends Node {\n    constructor(value) {\n        super();\n\n        if (!value) {\n            throw new Error('Value requires an array argument');\n        }\n        if (!Array.isArray(value)) {\n            this.value = [ value ];\n        }\n        else {\n            this.value = value;\n        }\n    }\n\n    accept(visitor) {\n        if (this.value) {\n            this.value = visitor.visitArray(this.value);\n        }\n    }\n\n    eval(context) {\n        if (this.value.length === 1) {\n            return this.value[0].eval(context);\n        } else {\n            return new Value(this.value.map(v => v.eval(context)));\n        }\n    }\n\n    genCSS(context, output) {\n        let i;\n        for (i = 0; i < this.value.length; i++) {\n            this.value[i].genCSS(context, output);\n            if (i + 1 < this.value.length) {\n                output.add((context && context.compress) ? ',' : ', ');\n            }\n        }\n    }\n}\n\nValue.prototype.type = 'Value';\nexport default Value;\n","import Node from './node';\n\nclass Keyword extends Node {\n    constructor(value) {\n        super();\n\n        this.value = value;\n    }\n\n    genCSS(context, output) {\n        if (this.value === '%') { throw { type: 'Syntax', message: 'Invalid % without number' }; }\n        output.add(this.value);\n    }\n}\n\nKeyword.prototype.type = 'Keyword';\n\nKeyword.True = new Keyword('true');\nKeyword.False = new Keyword('false');\n\nexport default Keyword;\n","import Node from './node';\n\nclass Anonymous extends Node {\n    constructor(value, index, currentFileInfo, mapLines, rulesetLike, visibilityInfo) {\n        super();\n\n        this.value = value;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.mapLines = mapLines;\n        this.rulesetLike = (typeof rulesetLike === 'undefined') ? false : rulesetLike;\n        this.allowRoot = true;\n        this.copyVisibilityInfo(visibilityInfo);\n    }\n\n    eval() {\n        return new Anonymous(this.value, this._index, this._fileInfo, this.mapLines, this.rulesetLike, this.visibilityInfo());\n    }\n\n    compare(other) {\n        return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;\n    }\n\n    isRulesetLike() {\n        return this.rulesetLike;\n    }\n\n    genCSS(context, output) {\n        this.nodeVisible = Boolean(this.value);\n        if (this.nodeVisible) {\n            output.add(this.value, this._fileInfo, this._index, this.mapLines);\n        }\n    }\n}\n\nAnonymous.prototype.type = 'Anonymous';\nexport default Anonymous;\n","import Node from './node';\nimport Value from './value';\nimport Keyword from './keyword';\nimport Anonymous from './anonymous';\nimport * as Constants from '../constants';\nconst MATH = Constants.Math;\n\n\nclass Declaration extends Node {\n    constructor(name, value, important, merge, index, currentFileInfo, inline, variable) {\n        super();\n\n        this.name = name;\n        this.value = (value instanceof Node) ? value : new Value([value ? new Anonymous(value) : null]);\n        this.important = important ? ` ${important.trim()}` : '';\n        this.merge = merge;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.inline = inline || false;\n        this.variable = (variable !== undefined) ? variable\n            : (name.charAt && (name.charAt(0) === '@'));\n        this.allowRoot = true;\n        this.setParent(this.value, this);\n    }\n\n    genCSS(context, output) {\n        output.add(this.name + (context.compress ? ':' : ': '), this.fileInfo(), this.getIndex());\n        try {\n            this.value.genCSS(context, output);\n        }\n        catch (e) {\n            e.index = this._index;\n            e.filename = this._fileInfo.filename;\n            throw e;\n        }\n        output.add(this.important + ((this.inline || (context.lastRule && context.compress)) ? '' : ';'), this._fileInfo, this._index);\n    }\n\n    eval(context) {\n        let mathBypass = false;\n        let prevMath;\n        let name = this.name;\n        let evaldValue;\n        let variable = this.variable;\n        if (typeof name !== 'string') {\n            // expand 'primitive' name directly to get\n            // things faster (~10% for benchmark.less):\n            name = (name.length === 1) && (name[0] instanceof Keyword) ?\n                name[0].value : evalName(context, name);\n            variable = false; // never treat expanded interpolation as new variable name\n        }\n\n        // @todo remove when parens-division is default\n        if (name === 'font' && context.math === MATH.ALWAYS) {\n            mathBypass = true;\n            prevMath = context.math;\n            context.math = MATH.PARENS_DIVISION;\n        }\n        try {\n            context.importantScope.push({});\n            evaldValue = this.value.eval(context);\n\n            if (!this.variable && evaldValue.type === 'DetachedRuleset') {\n                throw { message: 'Rulesets cannot be evaluated on a property.',\n                    index: this.getIndex(), filename: this.fileInfo().filename };\n            }\n            let important = this.important;\n            const importantResult = context.importantScope.pop();\n            if (!important && importantResult.important) {\n                important = importantResult.important;\n            }\n\n            return new Declaration(name,\n                evaldValue,\n                important,\n                this.merge,\n                this.getIndex(), this.fileInfo(), this.inline,\n                variable);\n        }\n        catch (e) {\n            if (typeof e.index !== 'number') {\n                e.index = this.getIndex();\n                e.filename = this.fileInfo().filename;\n            }\n            throw e;\n        }\n        finally {\n            if (mathBypass) {\n                context.math = prevMath;\n            }\n        }\n    }\n\n    makeImportant() {\n        return new Declaration(this.name,\n            this.value,\n            '!important',\n            this.merge,\n            this.getIndex(), this.fileInfo(), this.inline);\n    }\n}\n\nfunction evalName(context, name) {\n    let value = '';\n    let i;\n    const n = name.length;\n    const output = {add: function (s) {value += s;}};\n    for (i = 0; i < n; i++) {\n        name[i].eval(context).genCSS(context, output);\n    }\n    return value;\n}\n\nDeclaration.prototype.type = 'Declaration';\nexport default Declaration;","const debugInfo = (context, ctx, lineSeparator) => {\n    let result = '';\n    if (context.dumpLineNumbers && !context.compress) {\n        switch (context.dumpLineNumbers) {\n            case 'comments':\n                result = debugInfo.asComment(ctx);\n                break;\n            case 'mediaquery':\n                result = debugInfo.asMediaQuery(ctx);\n                break;\n            case 'all':\n                result = debugInfo.asComment(ctx) + (lineSeparator || '') + debugInfo.asMediaQuery(ctx);\n                break;\n        }\n    }\n    return result;\n};\n\ndebugInfo.asComment = ctx => `/* line ${ctx.debugInfo.lineNumber}, ${ctx.debugInfo.fileName} */\\n`;\n\ndebugInfo.asMediaQuery = ctx => {\n    let filenameWithProtocol = ctx.debugInfo.fileName;\n    if (!/^[a-z]+:\\/\\//i.test(filenameWithProtocol)) {\n        filenameWithProtocol = `file://${filenameWithProtocol}`;\n    }\n    return `@media -sass-debug-info{filename{font-family:${filenameWithProtocol.replace(/([.:\\/\\\\])/g, a => {\n        if (a == '\\\\') {\n            a = '\\/';\n        }\n        return `\\\\${a}`;\n    })}}line{font-family:\\\\00003${ctx.debugInfo.lineNumber}}}\\n`;\n};\n\nexport default debugInfo;\n","import Node from './node';\nimport getDebugInfo from './debug-info';\n\nclass Comment extends Node {\n    constructor(value, isLineComment, index, currentFileInfo) {\n        super();\n\n        this.value = value;\n        this.isLineComment = isLineComment;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.allowRoot = true;\n    }\n\n    genCSS(context, output) {\n        if (this.debugInfo) {\n            output.add(getDebugInfo(context, this), this.fileInfo(), this.getIndex());\n        }\n        output.add(this.value);\n    }\n\n    isSilent(context) {\n        const isCompressed = context.compress && this.value[2] !== '!';\n        return this.isLineComment || isCompressed;\n    }\n}\n\nComment.prototype.type = 'Comment';\nexport default Comment;\n","const contexts = {};\nexport default contexts;\nimport * as Constants from './constants';\n\nconst copyFromOriginal = function copyFromOriginal(original, destination, propertiesToCopy) {\n    if (!original) { return; }\n\n    for (let i = 0; i < propertiesToCopy.length; i++) {\n        if (original.hasOwnProperty(propertiesToCopy[i])) {\n            destination[propertiesToCopy[i]] = original[propertiesToCopy[i]];\n        }\n    }\n};\n\n/*\n parse is used whilst parsing\n */\nconst parseCopyProperties = [\n    // options\n    'paths',            // option - unmodified - paths to search for imports on\n    'rewriteUrls',      // option - whether to adjust URL's to be relative\n    'rootpath',         // option - rootpath to append to URL's\n    'strictImports',    // option -\n    'insecure',         // option - whether to allow imports from insecure ssl hosts\n    'dumpLineNumbers',  // option - whether to dump line numbers\n    'compress',         // option - whether to compress\n    'syncImport',       // option - whether to import synchronously\n    'chunkInput',       // option - whether to chunk input. more performant but causes parse issues.\n    'mime',             // browser only - mime type for sheet import\n    'useFileCache',     // browser only - whether to use the per file session cache\n    // context\n    'processImports',   // option & context - whether to process imports. if false then imports will not be imported.\n    // Used by the import manager to stop multiple import visitors being created.\n    'pluginManager'     // Used as the plugin manager for the session\n];\n\ncontexts.Parse = function(options) {\n    copyFromOriginal(options, this, parseCopyProperties);\n\n    if (typeof this.paths === 'string') { this.paths = [this.paths]; }\n};\n\nconst evalCopyProperties = [\n    'paths',             // additional include paths\n    'compress',          // whether to compress\n    'math',              // whether math has to be within parenthesis\n    'strictUnits',       // whether units need to evaluate correctly\n    'sourceMap',         // whether to output a source map\n    'importMultiple',    // whether we are currently importing multiple copies\n    'urlArgs',           // whether to add args into url tokens\n    'javascriptEnabled', // option - whether Inline JavaScript is enabled. if undefined, defaults to false\n    'pluginManager',     // Used as the plugin manager for the session\n    'importantScope',    // used to bubble up !important statements\n    'rewriteUrls'        // option - whether to adjust URL's to be relative\n];\n\nfunction isPathRelative(path) {\n    return !/^(?:[a-z-]+:|\\/|#)/i.test(path);\n}\n\nfunction isPathLocalRelative(path) {\n    return path.charAt(0) === '.';\n}\n\ncontexts.Eval = class {\n    constructor(options, frames) {\n        copyFromOriginal(options, this, evalCopyProperties);\n\n        if (typeof this.paths === 'string') { this.paths = [this.paths]; }\n\n        this.frames = frames || [];\n        this.importantScope = this.importantScope || [];\n        this.inCalc = false;\n        this.mathOn = true;\n    }\n\n    enterCalc() {\n        if (!this.calcStack) {\n            this.calcStack = [];\n        }\n        this.calcStack.push(true);\n        this.inCalc = true;\n    }\n\n    exitCalc() {\n        this.calcStack.pop();\n        if (!this.calcStack) {\n            this.inCalc = false;\n        }\n    }\n\n    inParenthesis() {\n        if (!this.parensStack) {\n            this.parensStack = [];\n        }\n        this.parensStack.push(true);\n    };\n\n    outOfParenthesis() {\n        this.parensStack.pop();\n    };\n\n    isMathOn(op) {\n        if (!this.mathOn) {\n            return false;\n        }\n        if (op === '/' && this.math !== Constants.Math.ALWAYS && (!this.parensStack || !this.parensStack.length)) {\n            return false;\n        }\n        if (this.math > Constants.Math.PARENS_DIVISION) {\n            return this.parensStack && this.parensStack.length;\n        }\n        return true;\n    }\n\n    pathRequiresRewrite(path) {\n        const isRelative = this.rewriteUrls === Constants.RewriteUrls.LOCAL ? isPathLocalRelative : isPathRelative;\n\n        return isRelative(path);\n    }\n\n    rewritePath(path, rootpath) {\n        let newPath;\n\n        rootpath = rootpath ||'';\n        newPath = this.normalizePath(rootpath + path);\n\n        // If a path was explicit relative and the rootpath was not an absolute path\n        // we must ensure that the new path is also explicit relative.\n        if (isPathLocalRelative(path) &&\n            isPathRelative(rootpath) &&\n            isPathLocalRelative(newPath) === false) {\n            newPath = `./${newPath}`;\n        }\n\n        return newPath;\n    }\n\n    normalizePath(path) {\n        const segments = path.split('/').reverse();\n        let segment;\n\n        path = [];\n        while (segments.length !== 0) {\n            segment = segments.pop();\n            switch ( segment ) {\n                case '.':\n                    break;\n                case '..':\n                    if ((path.length === 0) || (path[path.length - 1] === '..')) {\n                        path.push( segment );\n                    } else {\n                        path.pop();\n                    }\n                    break;\n                default:\n                    path.push(segment);\n                    break;\n            }\n        }\n\n        return path.join('/');\n    }\n}\n","function makeRegistry( base ) {\n    return {\n        _data: {},\n        add: function(name, func) {\n            // precautionary case conversion, as later querying of\n            // the registry by function-caller uses lower case as well.\n            name = name.toLowerCase();\n\n            if (this._data.hasOwnProperty(name)) {\n                // TODO warn\n            }\n            this._data[name] = func;\n        },\n        addMultiple: function(functions) {\n            Object.keys(functions).forEach(\n                name => {\n                    this.add(name, functions[name]);\n                });\n        },\n        get: function(name) {\n            return this._data[name] || ( base && base.get( name ));\n        },\n        getLocalFunctions: function() {\n            return this._data;\n        },\n        inherit: function() {\n            return makeRegistry( this );\n        },\n        create: function(base) {\n            return makeRegistry(base);\n        }\n    };\n}\n\nexport default makeRegistry( null );","import Keyword from '../tree/keyword';\n\nconst defaultFunc = {\n    eval: function () {\n        const v = this.value_;\n        const e = this.error_;\n        if (e) {\n            throw e;\n        }\n        if (v != null) {\n            return v ? Keyword.True : Keyword.False;\n        }\n    },\n    value: function (v) {\n        this.value_ = v;\n    },\n    error: function (e) {\n        this.error_ = e;\n    },\n    reset: function () {\n        this.value_ = this.error_ = null;\n    }\n};\n\nexport default defaultFunc;\n","import Node from './node';\nimport Declaration from './declaration';\nimport Keyword from './keyword';\nimport Comment from './comment';\nimport Paren from './paren';\nimport Selector from './selector';\nimport Element from './element';\nimport Anonymous from './anonymous';\nimport contexts from '../contexts';\nimport globalFunctionRegistry from '../functions/function-registry';\nimport defaultFunc from '../functions/default';\nimport getDebugInfo from './debug-info';\nimport * as utils from '../utils';\n\nclass Ruleset extends Node {\n    constructor(selectors, rules, strictImports, visibilityInfo) {\n        super();\n\n        this.selectors = selectors;\n        this.rules = rules;\n        this._lookups = {};\n        this._variables = null;\n        this._properties = null;\n        this.strictImports = strictImports;\n        this.copyVisibilityInfo(visibilityInfo);\n        this.allowRoot = true;\n\n        this.setParent(this.selectors, this);\n        this.setParent(this.rules, this);\n\n    }\n\n    isRulesetLike() {\n        return true;\n    }\n\n    accept(visitor) {\n        if (this.paths) {\n            this.paths = visitor.visitArray(this.paths, true);\n        } else if (this.selectors) {\n            this.selectors = visitor.visitArray(this.selectors);\n        }\n        if (this.rules && this.rules.length) {\n            this.rules = visitor.visitArray(this.rules);\n        }\n    }\n\n    eval(context) {\n        const that = this;\n        let selectors;\n        let selCnt;\n        let selector;\n        let i;\n        let hasVariable;\n        let hasOnePassingSelector = false;\n\n        if (this.selectors && (selCnt = this.selectors.length)) {\n            selectors = new Array(selCnt);\n            defaultFunc.error({\n                type: 'Syntax',\n                message: 'it is currently only allowed in parametric mixin guards,'\n            });\n\n            for (i = 0; i < selCnt; i++) {\n                selector = this.selectors[i].eval(context);\n                for (var j = 0; j < selector.elements.length; j++) {\n                    if (selector.elements[j].isVariable) {\n                        hasVariable = true;\n                        break;\n                    }\n                }\n                selectors[i] = selector;\n                if (selector.evaldCondition) {\n                    hasOnePassingSelector = true;\n                }\n            }\n\n            if (hasVariable) {\n                const toParseSelectors = new Array(selCnt);\n                for (i = 0; i < selCnt; i++) {\n                    selector = selectors[i];\n                    toParseSelectors[i] = selector.toCSS(context);\n                }\n                this.parse.parseNode(\n                    toParseSelectors.join(','),\n                    [\"selectors\"], \n                    selectors[0].getIndex(), \n                    selectors[0].fileInfo(), \n                    (err, result) => {\n                        if (result) {\n                            selectors = utils.flattenArray(result);\n                        }\n                    });\n            }\n\n            defaultFunc.reset();\n        } else {\n            hasOnePassingSelector = true;\n        }\n\n        let rules = this.rules ? utils.copyArray(this.rules) : null;\n        const ruleset = new Ruleset(selectors, rules, this.strictImports, this.visibilityInfo());\n        let rule;\n        let subRule;\n\n        ruleset.originalRuleset = this;\n        ruleset.root = this.root;\n        ruleset.firstRoot = this.firstRoot;\n        ruleset.allowImports = this.allowImports;\n\n        if (this.debugInfo) {\n            ruleset.debugInfo = this.debugInfo;\n        }\n\n        if (!hasOnePassingSelector) {\n            rules.length = 0;\n        }\n\n        // inherit a function registry from the frames stack when possible;\n        // otherwise from the global registry\n        ruleset.functionRegistry = (frames => {\n            let i = 0;\n            const n = frames.length;\n            let found;\n            for ( ; i !== n ; ++i ) {\n                found = frames[ i ].functionRegistry;\n                if ( found ) { return found; }\n            }\n            return globalFunctionRegistry;\n        })(context.frames).inherit();\n\n        // push the current ruleset to the frames stack\n        const ctxFrames = context.frames;\n        ctxFrames.unshift(ruleset);\n\n        // currrent selectors\n        let ctxSelectors = context.selectors;\n        if (!ctxSelectors) {\n            context.selectors = ctxSelectors = [];\n        }\n        ctxSelectors.unshift(this.selectors);\n\n        // Evaluate imports\n        if (ruleset.root || ruleset.allowImports || !ruleset.strictImports) {\n            ruleset.evalImports(context);\n        }\n\n        // Store the frames around mixin definitions,\n        // so they can be evaluated like closures when the time comes.\n        const rsRules = ruleset.rules;\n        for (i = 0; (rule = rsRules[i]); i++) {\n            if (rule.evalFirst) {\n                rsRules[i] = rule.eval(context);\n            }\n        }\n\n        const mediaBlockCount = (context.mediaBlocks && context.mediaBlocks.length) || 0;\n\n        // Evaluate mixin calls.\n        for (i = 0; (rule = rsRules[i]); i++) {\n            if (rule.type === 'MixinCall') {\n                /* jshint loopfunc:true */\n                rules = rule.eval(context).filter(r => {\n                    if ((r instanceof Declaration) && r.variable) {\n                        // do not pollute the scope if the variable is\n                        // already there. consider returning false here\n                        // but we need a way to \"return\" variable from mixins\n                        return !(ruleset.variable(r.name));\n                    }\n                    return true;\n                });\n                rsRules.splice(...[i, 1].concat(rules));\n                i += rules.length - 1;\n                ruleset.resetCache();\n            } else if (rule.type ===  'VariableCall') {\n                /* jshint loopfunc:true */\n                rules = rule.eval(context).rules.filter(r => {\n                    if ((r instanceof Declaration) && r.variable) {\n                        // do not pollute the scope at all\n                        return false;\n                    }\n                    return true;\n                });\n                rsRules.splice(...[i, 1].concat(rules));\n                i += rules.length - 1;\n                ruleset.resetCache();\n            }\n        }\n\n        // Evaluate everything else\n        for (i = 0; (rule = rsRules[i]); i++) {\n            if (!rule.evalFirst) {\n                rsRules[i] = rule = rule.eval ? rule.eval(context) : rule;\n            }\n        }\n\n        // Evaluate everything else\n        for (i = 0; (rule = rsRules[i]); i++) {\n            // for rulesets, check if it is a css guard and can be removed\n            if (rule instanceof Ruleset && rule.selectors && rule.selectors.length === 1) {\n                // check if it can be folded in (e.g. & where)\n                if (rule.selectors[0] && rule.selectors[0].isJustParentSelector()) {\n                    rsRules.splice(i--, 1);\n\n                    for (var j = 0; (subRule = rule.rules[j]); j++) {\n                        if (subRule instanceof Node) {\n                            subRule.copyVisibilityInfo(rule.visibilityInfo());\n                            if (!(subRule instanceof Declaration) || !subRule.variable) {\n                                rsRules.splice(++i, 0, subRule);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Pop the stack\n        ctxFrames.shift();\n        ctxSelectors.shift();\n\n        if (context.mediaBlocks) {\n            for (i = mediaBlockCount; i < context.mediaBlocks.length; i++) {\n                context.mediaBlocks[i].bubbleSelectors(selectors);\n            }\n        }\n\n        return ruleset;\n    }\n\n    evalImports(context) {\n        const rules = this.rules;\n        let i;\n        let importRules;\n        if (!rules) { return; }\n\n        for (i = 0; i < rules.length; i++) {\n            if (rules[i].type === 'Import') {\n                importRules = rules[i].eval(context);\n                if (importRules && (importRules.length || importRules.length === 0)) {\n                    rules.splice(...[i, 1].concat(importRules));\n                    i += importRules.length - 1;\n                } else {\n                    rules.splice(i, 1, importRules);\n                }\n                this.resetCache();\n            }\n        }\n    }\n\n    makeImportant() {\n        const result = new Ruleset(this.selectors, this.rules.map(r => {\n            if (r.makeImportant) {\n                return r.makeImportant();\n            } else {\n                return r;\n            }\n        }), this.strictImports, this.visibilityInfo());\n\n        return result;\n    }\n\n    matchArgs(args) {\n        return !args || args.length === 0;\n    }\n\n    // lets you call a css selector with a guard\n    matchCondition(args, context) {\n        const lastSelector = this.selectors[this.selectors.length - 1];\n        if (!lastSelector.evaldCondition) {\n            return false;\n        }\n        if (lastSelector.condition &&\n            !lastSelector.condition.eval(\n                new contexts.Eval(context,\n                    context.frames))) {\n            return false;\n        }\n        return true;\n    }\n\n    resetCache() {\n        this._rulesets = null;\n        this._variables = null;\n        this._properties = null;\n        this._lookups = {};\n    }\n\n    variables() {\n        if (!this._variables) {\n            this._variables = !this.rules ? {} : this.rules.reduce((hash, r) => {\n                if (r instanceof Declaration && r.variable === true) {\n                    hash[r.name] = r;\n                }\n                // when evaluating variables in an import statement, imports have not been eval'd\n                // so we need to go inside import statements.\n                // guard against root being a string (in the case of inlined less)\n                if (r.type === 'Import' && r.root && r.root.variables) {\n                    const vars = r.root.variables();\n                    for (const name in vars) {\n                        if (vars.hasOwnProperty(name)) {\n                            hash[name] = r.root.variable(name);\n                        }\n                    }\n                }\n                return hash;\n            }, {});\n        }\n        return this._variables;\n    }\n\n    properties() {\n        if (!this._properties) {\n            this._properties = !this.rules ? {} : this.rules.reduce((hash, r) => {\n                if (r instanceof Declaration && r.variable !== true) {\n                    const name = (r.name.length === 1) && (r.name[0] instanceof Keyword) ?\n                        r.name[0].value : r.name;\n                    // Properties don't overwrite as they can merge\n                    if (!hash[`$${name}`]) {\n                        hash[`$${name}`] = [ r ];\n                    }\n                    else {\n                        hash[`$${name}`].push(r);\n                    }\n                }\n                return hash;\n            }, {});\n        }\n        return this._properties;\n    }\n\n    variable(name) {\n        const decl = this.variables()[name];\n        if (decl) {\n            return this.parseValue(decl);\n        }\n    }\n\n    property(name) {\n        const decl = this.properties()[name];\n        if (decl) {\n            return this.parseValue(decl);\n        }\n    }\n\n    lastDeclaration() {\n        for (let i = this.rules.length; i > 0; i--) {\n            const decl = this.rules[i - 1];\n            if (decl instanceof Declaration) {\n                return this.parseValue(decl);\n            }\n        }\n    }\n\n    parseValue(toParse) {\n        const self = this;\n        function transformDeclaration(decl) {\n            if (decl.value instanceof Anonymous && !decl.parsed) {\n                if (typeof decl.value.value === 'string') {\n                    this.parse.parseNode(\n                        decl.value.value,\n                        ['value', 'important'], \n                        decl.value.getIndex(), \n                        decl.fileInfo(), \n                        (err, result) => {\n                            if (err) {\n                                decl.parsed = true;\n                            }\n                            if (result) {\n                                decl.value = result[0];\n                                decl.important = result[1] || '';\n                                decl.parsed = true;\n                            }\n                        });\n                } else {\n                    decl.parsed = true;\n                }\n\n                return decl;\n            }\n            else {\n                return decl;\n            }\n        }\n        if (!Array.isArray(toParse)) {\n            return transformDeclaration.call(self, toParse);\n        }\n        else {\n            const nodes = [];\n            toParse.forEach(n => {\n                nodes.push(transformDeclaration.call(self, n));\n            });\n            return nodes;\n        }\n    }\n\n    rulesets() {\n        if (!this.rules) { return []; }\n\n        const filtRules = [];\n        const rules = this.rules;\n        let i;\n        let rule;\n\n        for (i = 0; (rule = rules[i]); i++) {\n            if (rule.isRuleset) {\n                filtRules.push(rule);\n            }\n        }\n\n        return filtRules;\n    }\n\n    prependRule(rule) {\n        const rules = this.rules;\n        if (rules) {\n            rules.unshift(rule);\n        } else {\n            this.rules = [ rule ];\n        }\n        this.setParent(rule, this);\n    }\n\n    find(selector, self = this, filter) {\n        const rules = [];\n        let match;\n        let foundMixins;\n        const key = selector.toCSS();\n\n        if (key in this._lookups) { return this._lookups[key]; }\n\n        this.rulesets().forEach(rule => {\n            if (rule !== self) {\n                for (let j = 0; j < rule.selectors.length; j++) {\n                    match = selector.match(rule.selectors[j]);\n                    if (match) {\n                        if (selector.elements.length > match) {\n                            if (!filter || filter(rule)) {\n                                foundMixins = rule.find(new Selector(selector.elements.slice(match)), self, filter);\n                                for (let i = 0; i < foundMixins.length; ++i) {\n                                    foundMixins[i].path.push(rule);\n                                }\n                                Array.prototype.push.apply(rules, foundMixins);\n                            }\n                        } else {\n                            rules.push({ rule, path: []});\n                        }\n                        break;\n                    }\n                }\n            }\n        });\n        this._lookups[key] = rules;\n        return rules;\n    }\n\n    genCSS(context, output) {\n        let i;\n        let j;\n        const charsetRuleNodes = [];\n        let ruleNodes = [];\n\n        let // Line number debugging\n            debugInfo;\n\n        let rule;\n        let path;\n\n        context.tabLevel = (context.tabLevel || 0);\n\n        if (!this.root) {\n            context.tabLevel++;\n        }\n\n        const tabRuleStr = context.compress ? '' : Array(context.tabLevel + 1).join('  ');\n        const tabSetStr = context.compress ? '' : Array(context.tabLevel).join('  ');\n        let sep;\n\n        let charsetNodeIndex = 0;\n        let importNodeIndex = 0;\n        for (i = 0; (rule = this.rules[i]); i++) {\n            if (rule instanceof Comment) {\n                if (importNodeIndex === i) {\n                    importNodeIndex++;\n                }\n                ruleNodes.push(rule);\n            } else if (rule.isCharset && rule.isCharset()) {\n                ruleNodes.splice(charsetNodeIndex, 0, rule);\n                charsetNodeIndex++;\n                importNodeIndex++;\n            } else if (rule.type === 'Import') {\n                ruleNodes.splice(importNodeIndex, 0, rule);\n                importNodeIndex++;\n            } else {\n                ruleNodes.push(rule);\n            }\n        }\n        ruleNodes = charsetRuleNodes.concat(ruleNodes);\n\n        // If this is the root node, we don't render\n        // a selector, or {}.\n        if (!this.root) {\n            debugInfo = getDebugInfo(context, this, tabSetStr);\n\n            if (debugInfo) {\n                output.add(debugInfo);\n                output.add(tabSetStr);\n            }\n\n            const paths = this.paths;\n            const pathCnt = paths.length;\n            let pathSubCnt;\n\n            sep = context.compress ? ',' : (`,\\n${tabSetStr}`);\n\n            for (i = 0; i < pathCnt; i++) {\n                path = paths[i];\n                if (!(pathSubCnt = path.length)) { continue; }\n                if (i > 0) { output.add(sep); }\n\n                context.firstSelector = true;\n                path[0].genCSS(context, output);\n\n                context.firstSelector = false;\n                for (j = 1; j < pathSubCnt; j++) {\n                    path[j].genCSS(context, output);\n                }\n            }\n\n            output.add((context.compress ? '{' : ' {\\n') + tabRuleStr);\n        }\n\n        // Compile rules and rulesets\n        for (i = 0; (rule = ruleNodes[i]); i++) {\n\n            if (i + 1 === ruleNodes.length) {\n                context.lastRule = true;\n            }\n\n            const currentLastRule = context.lastRule;\n            if (rule.isRulesetLike(rule)) {\n                context.lastRule = false;\n            }\n\n            if (rule.genCSS) {\n                rule.genCSS(context, output);\n            } else if (rule.value) {\n                output.add(rule.value.toString());\n            }\n\n            context.lastRule = currentLastRule;\n\n            if (!context.lastRule && rule.isVisible()) {\n                output.add(context.compress ? '' : (`\\n${tabRuleStr}`));\n            } else {\n                context.lastRule = false;\n            }\n        }\n\n        if (!this.root) {\n            output.add((context.compress ? '}' : `\\n${tabSetStr}}`));\n            context.tabLevel--;\n        }\n\n        if (!output.isEmpty() && !context.compress && this.firstRoot) {\n            output.add('\\n');\n        }\n    }\n\n    joinSelectors(paths, context, selectors) {\n        for (let s = 0; s < selectors.length; s++) {\n            this.joinSelector(paths, context, selectors[s]);\n        }\n    }\n\n    joinSelector(paths, context, selector) {\n        function createParenthesis(elementsToPak, originalElement) {\n            let replacementParen;\n            let j;\n            if (elementsToPak.length === 0) {\n                replacementParen = new Paren(elementsToPak[0]);\n            } else {\n                const insideParent = new Array(elementsToPak.length);\n                for (j = 0; j < elementsToPak.length; j++) {\n                    insideParent[j] = new Element(\n                        null,\n                        elementsToPak[j],\n                        originalElement.isVariable,\n                        originalElement._index,\n                        originalElement._fileInfo\n                    );\n                }\n                replacementParen = new Paren(new Selector(insideParent));\n            }\n            return replacementParen;\n        }\n\n        function createSelector(containedElement, originalElement) {\n            let element;\n            let selector;\n            element = new Element(null, containedElement, originalElement.isVariable, originalElement._index, originalElement._fileInfo);\n            selector = new Selector([element]);\n            return selector;\n        }\n\n        // joins selector path from `beginningPath` with selector path in `addPath`\n        // `replacedElement` contains element that is being replaced by `addPath`\n        // returns concatenated path\n        function addReplacementIntoPath(beginningPath, addPath, replacedElement, originalSelector) {\n            let newSelectorPath;\n            let lastSelector;\n            let newJoinedSelector;\n            // our new selector path\n            newSelectorPath = [];\n\n            // construct the joined selector - if & is the first thing this will be empty,\n            // if not newJoinedSelector will be the last set of elements in the selector\n            if (beginningPath.length > 0) {\n                newSelectorPath = utils.copyArray(beginningPath);\n                lastSelector = newSelectorPath.pop();\n                newJoinedSelector = originalSelector.createDerived(utils.copyArray(lastSelector.elements));\n            }\n            else {\n                newJoinedSelector = originalSelector.createDerived([]);\n            }\n\n            if (addPath.length > 0) {\n                // /deep/ is a CSS4 selector - (removed, so should deprecate)\n                // that is valid without anything in front of it\n                // so if the & does not have a combinator that is \"\" or \" \" then\n                // and there is a combinator on the parent, then grab that.\n                // this also allows + a { & .b { .a & { ... though not sure why you would want to do that\n                let combinator = replacedElement.combinator;\n\n                const parentEl = addPath[0].elements[0];\n                if (combinator.emptyOrWhitespace && !parentEl.combinator.emptyOrWhitespace) {\n                    combinator = parentEl.combinator;\n                }\n                // join the elements so far with the first part of the parent\n                newJoinedSelector.elements.push(new Element(\n                    combinator,\n                    parentEl.value,\n                    replacedElement.isVariable,\n                    replacedElement._index,\n                    replacedElement._fileInfo\n                ));\n                newJoinedSelector.elements = newJoinedSelector.elements.concat(addPath[0].elements.slice(1));\n            }\n\n            // now add the joined selector - but only if it is not empty\n            if (newJoinedSelector.elements.length !== 0) {\n                newSelectorPath.push(newJoinedSelector);\n            }\n\n            // put together the parent selectors after the join (e.g. the rest of the parent)\n            if (addPath.length > 1) {\n                let restOfPath = addPath.slice(1);\n                restOfPath = restOfPath.map(selector => selector.createDerived(selector.elements, []));\n                newSelectorPath = newSelectorPath.concat(restOfPath);\n            }\n            return newSelectorPath;\n        }\n\n        // joins selector path from `beginningPath` with every selector path in `addPaths` array\n        // `replacedElement` contains element that is being replaced by `addPath`\n        // returns array with all concatenated paths\n        function addAllReplacementsIntoPath( beginningPath, addPaths, replacedElement, originalSelector, result) {\n            let j;\n            for (j = 0; j < beginningPath.length; j++) {\n                const newSelectorPath = addReplacementIntoPath(beginningPath[j], addPaths, replacedElement, originalSelector);\n                result.push(newSelectorPath);\n            }\n            return result;\n        }\n\n        function mergeElementsOnToSelectors(elements, selectors) {\n            let i;\n            let sel;\n\n            if (elements.length === 0) {\n                return ;\n            }\n            if (selectors.length === 0) {\n                selectors.push([ new Selector(elements) ]);\n                return;\n            }\n\n            for (i = 0; (sel = selectors[i]); i++) {\n                // if the previous thing in sel is a parent this needs to join on to it\n                if (sel.length > 0) {\n                    sel[sel.length - 1] = sel[sel.length - 1].createDerived(sel[sel.length - 1].elements.concat(elements));\n                }\n                else {\n                    sel.push(new Selector(elements));\n                }\n            }\n        }\n\n        // replace all parent selectors inside `inSelector` by content of `context` array\n        // resulting selectors are returned inside `paths` array\n        // returns true if `inSelector` contained at least one parent selector\n        function replaceParentSelector(paths, context, inSelector) {\n            // The paths are [[Selector]]\n            // The first list is a list of comma separated selectors\n            // The inner list is a list of inheritance separated selectors\n            // e.g.\n            // .a, .b {\n            //   .c {\n            //   }\n            // }\n            // == [[.a] [.c]] [[.b] [.c]]\n            //\n            let i;\n\n            let j;\n            let k;\n            let currentElements;\n            let newSelectors;\n            let selectorsMultiplied;\n            let sel;\n            let el;\n            let hadParentSelector = false;\n            let length;\n            let lastSelector;\n            function findNestedSelector(element) {\n                let maybeSelector;\n                if (!(element.value instanceof Paren)) {\n                    return null;\n                }\n\n                maybeSelector = element.value.value;\n                if (!(maybeSelector instanceof Selector)) {\n                    return null;\n                }\n\n                return maybeSelector;\n            }\n\n            // the elements from the current selector so far\n            currentElements = [];\n            // the current list of new selectors to add to the path.\n            // We will build it up. We initiate it with one empty selector as we \"multiply\" the new selectors\n            // by the parents\n            newSelectors = [\n                []\n            ];\n\n            for (i = 0; (el = inSelector.elements[i]); i++) {\n                // non parent reference elements just get added\n                if (el.value !== '&') {\n                    const nestedSelector = findNestedSelector(el);\n                    if (nestedSelector != null) {\n                        // merge the current list of non parent selector elements\n                        // on to the current list of selectors to add\n                        mergeElementsOnToSelectors(currentElements, newSelectors);\n\n                        const nestedPaths = [];\n                        let replaced;\n                        const replacedNewSelectors = [];\n                        replaced = replaceParentSelector(nestedPaths, context, nestedSelector);\n                        hadParentSelector = hadParentSelector || replaced;\n                        // the nestedPaths array should have only one member - replaceParentSelector does not multiply selectors\n                        for (k = 0; k < nestedPaths.length; k++) {\n                            const replacementSelector = createSelector(createParenthesis(nestedPaths[k], el), el);\n                            addAllReplacementsIntoPath(newSelectors, [replacementSelector], el, inSelector, replacedNewSelectors);\n                        }\n                        newSelectors = replacedNewSelectors;\n                        currentElements = [];\n                    } else {\n                        currentElements.push(el);\n                    }\n\n                } else {\n                    hadParentSelector = true;\n                    // the new list of selectors to add\n                    selectorsMultiplied = [];\n\n                    // merge the current list of non parent selector elements\n                    // on to the current list of selectors to add\n                    mergeElementsOnToSelectors(currentElements, newSelectors);\n\n                    // loop through our current selectors\n                    for (j = 0; j < newSelectors.length; j++) {\n                        sel = newSelectors[j];\n                        // if we don't have any parent paths, the & might be in a mixin so that it can be used\n                        // whether there are parents or not\n                        if (context.length === 0) {\n                            // the combinator used on el should now be applied to the next element instead so that\n                            // it is not lost\n                            if (sel.length > 0) {\n                                sel[0].elements.push(new Element(el.combinator, '', el.isVariable, el._index, el._fileInfo));\n                            }\n                            selectorsMultiplied.push(sel);\n                        }\n                        else {\n                            // and the parent selectors\n                            for (k = 0; k < context.length; k++) {\n                                // We need to put the current selectors\n                                // then join the last selector's elements on to the parents selectors\n                                const newSelectorPath = addReplacementIntoPath(sel, context[k], el, inSelector);\n                                // add that to our new set of selectors\n                                selectorsMultiplied.push(newSelectorPath);\n                            }\n                        }\n                    }\n\n                    // our new selectors has been multiplied, so reset the state\n                    newSelectors = selectorsMultiplied;\n                    currentElements = [];\n                }\n            }\n\n            // if we have any elements left over (e.g. .a& .b == .b)\n            // add them on to all the current selectors\n            mergeElementsOnToSelectors(currentElements, newSelectors);\n\n            for (i = 0; i < newSelectors.length; i++) {\n                length = newSelectors[i].length;\n                if (length > 0) {\n                    paths.push(newSelectors[i]);\n                    lastSelector = newSelectors[i][length - 1];\n                    newSelectors[i][length - 1] = lastSelector.createDerived(lastSelector.elements, inSelector.extendList);\n                }\n            }\n\n            return hadParentSelector;\n        }\n\n        function deriveSelector(visibilityInfo, deriveFrom) {\n            const newSelector = deriveFrom.createDerived(deriveFrom.elements, deriveFrom.extendList, deriveFrom.evaldCondition);\n            newSelector.copyVisibilityInfo(visibilityInfo);\n            return newSelector;\n        }\n\n        // joinSelector code follows\n        let i;\n\n        let newPaths;\n        let hadParentSelector;\n\n        newPaths = [];\n        hadParentSelector = replaceParentSelector(newPaths, context, selector);\n\n        if (!hadParentSelector) {\n            if (context.length > 0) {\n                newPaths = [];\n                for (i = 0; i < context.length; i++) {\n\n                    const concatenated = context[i].map(deriveSelector.bind(this, selector.visibilityInfo()));\n\n                    concatenated.push(selector);\n                    newPaths.push(concatenated);\n                }\n            }\n            else {\n                newPaths = [[selector]];\n            }\n        }\n\n        for (i = 0; i < newPaths.length; i++) {\n            paths.push(newPaths[i]);\n        }\n    }\n}\n\nRuleset.prototype.type = 'Ruleset';\nRuleset.prototype.isRuleset = true;\nexport default Ruleset;\n","import Node from './node';\nimport Selector from './selector';\nimport Ruleset from './ruleset';\nimport Anonymous from './anonymous';\n\nclass AtRule extends Node {\n    constructor(\n        name,\n        value,\n        rules,\n        index,\n        currentFileInfo,\n        debugInfo,\n        isRooted,\n        visibilityInfo\n    ) {\n        super();\n\n        let i;\n\n        this.name  = name;\n        this.value = (value instanceof Node) ? value : (value ? new Anonymous(value) : value);\n        if (rules) {\n            if (Array.isArray(rules)) {\n                this.rules = rules;\n            } else {\n                this.rules = [rules];\n                this.rules[0].selectors = (new Selector([], null, null, index, currentFileInfo)).createEmptySelectors();\n            }\n            for (i = 0; i < this.rules.length; i++) {\n                this.rules[i].allowImports = true;\n            }\n            this.setParent(this.rules, this);\n        }\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.debugInfo = debugInfo;\n        this.isRooted = isRooted || false;\n        this.copyVisibilityInfo(visibilityInfo);\n        this.allowRoot = true;\n    }\n\n    accept(visitor) {\n        const value = this.value;\n        const rules = this.rules;\n        if (rules) {\n            this.rules = visitor.visitArray(rules);\n        }\n        if (value) {\n            this.value = visitor.visit(value);\n        }\n    }\n\n    isRulesetLike() {\n        return this.rules || !this.isCharset();\n    }\n\n    isCharset() {\n        return '@charset' === this.name;\n    }\n\n    genCSS(context, output) {\n        const value = this.value;\n        const rules = this.rules;\n        output.add(this.name, this.fileInfo(), this.getIndex());\n        if (value) {\n            output.add(' ');\n            value.genCSS(context, output);\n        }\n        if (rules) {\n            this.outputRuleset(context, output, rules);\n        } else {\n            output.add(';');\n        }\n    }\n\n    eval(context) {\n        let mediaPathBackup;\n        let mediaBlocksBackup;\n        let value = this.value;\n        let rules = this.rules;\n\n        // media stored inside other atrule should not bubble over it\n        // backpup media bubbling information\n        mediaPathBackup = context.mediaPath;\n        mediaBlocksBackup = context.mediaBlocks;\n        // deleted media bubbling information\n        context.mediaPath = [];\n        context.mediaBlocks = [];\n\n        if (value) {\n            value = value.eval(context);\n        }\n        if (rules) {\n            // assuming that there is only one rule at this point - that is how parser constructs the rule\n            rules = [rules[0].eval(context)];\n            rules[0].root = true;\n        }\n        // restore media bubbling information\n        context.mediaPath = mediaPathBackup;\n        context.mediaBlocks = mediaBlocksBackup;\n\n        return new AtRule(this.name, value, rules,\n            this.getIndex(), this.fileInfo(), this.debugInfo, this.isRooted, this.visibilityInfo());\n    }\n\n    variable(name) {\n        if (this.rules) {\n            // assuming that there is only one rule at this point - that is how parser constructs the rule\n            return Ruleset.prototype.variable.call(this.rules[0], name);\n        }\n    }\n\n    find(...args) {\n        if (this.rules) {\n            // assuming that there is only one rule at this point - that is how parser constructs the rule\n            return Ruleset.prototype.find.apply(this.rules[0], args);\n        }\n    }\n\n    rulesets() {\n        if (this.rules) {\n            // assuming that there is only one rule at this point - that is how parser constructs the rule\n            return Ruleset.prototype.rulesets.apply(this.rules[0]);\n        }\n    }\n\n    outputRuleset(context, output, rules) {\n        const ruleCnt = rules.length;\n        let i;\n        context.tabLevel = (context.tabLevel | 0) + 1;\n\n        // Compressed\n        if (context.compress) {\n            output.add('{');\n            for (i = 0; i < ruleCnt; i++) {\n                rules[i].genCSS(context, output);\n            }\n            output.add('}');\n            context.tabLevel--;\n            return;\n        }\n\n        // Non-compressed\n        const tabSetStr = `\\n${Array(context.tabLevel).join('  ')}`;\n\n        const tabRuleStr = `${tabSetStr}  `;\n        if (!ruleCnt) {\n            output.add(` {${tabSetStr}}`);\n        } else {\n            output.add(` {${tabRuleStr}`);\n            rules[0].genCSS(context, output);\n            for (i = 1; i < ruleCnt; i++) {\n                output.add(tabRuleStr);\n                rules[i].genCSS(context, output);\n            }\n            output.add(`${tabSetStr}}`);\n        }\n\n        context.tabLevel--;\n    }\n}\n\nAtRule.prototype.type = 'AtRule';\nexport default AtRule;\n","import Node from './node';\nimport contexts from '../contexts';\nimport * as utils from '../utils';\n\nclass DetachedRuleset extends Node {\n    constructor(ruleset, frames) {\n        super();\n\n        this.ruleset = ruleset;\n        this.frames = frames;\n        this.setParent(this.ruleset, this);\n    }\n\n    accept(visitor) {\n        this.ruleset = visitor.visit(this.ruleset);\n    }\n\n    eval(context) {\n        const frames = this.frames || utils.copyArray(context.frames);\n        return new DetachedRuleset(this.ruleset, frames);\n    }\n\n    callEval(context) {\n        return this.ruleset.eval(this.frames ? new contexts.Eval(context, this.frames.concat(context.frames)) : context);\n    }\n}\n\nDetachedRuleset.prototype.type = 'DetachedRuleset';\nDetachedRuleset.prototype.evalFirst = true;\nexport default DetachedRuleset;\n","import Node from './node';\nimport unitConversions from '../data/unit-conversions';\nimport * as utils from '../utils';\n\nclass Unit extends Node {\n    constructor(numerator, denominator, backupUnit) {\n        super();\n\n        this.numerator = numerator ? utils.copyArray(numerator).sort() : [];\n        this.denominator = denominator ? utils.copyArray(denominator).sort() : [];\n        if (backupUnit) {\n            this.backupUnit = backupUnit;\n        } else if (numerator && numerator.length) {\n            this.backupUnit = numerator[0];\n        }\n    }\n\n    clone() {\n        return new Unit(utils.copyArray(this.numerator), utils.copyArray(this.denominator), this.backupUnit);\n    }\n\n    genCSS(context, output) {\n        // Dimension checks the unit is singular and throws an error if in strict math mode.\n        const strictUnits = context && context.strictUnits;\n        if (this.numerator.length === 1) {\n            output.add(this.numerator[0]); // the ideal situation\n        } else if (!strictUnits && this.backupUnit) {\n            output.add(this.backupUnit);\n        } else if (!strictUnits && this.denominator.length) {\n            output.add(this.denominator[0]);\n        }\n    }\n\n    toString() {\n        let i;\n        let returnStr = this.numerator.join('*');\n        for (i = 0; i < this.denominator.length; i++) {\n            returnStr += `/${this.denominator[i]}`;\n        }\n        return returnStr;\n    }\n\n    compare(other) {\n        return this.is(other.toString()) ? 0 : undefined;\n    }\n\n    is(unitString) {\n        return this.toString().toUpperCase() === unitString.toUpperCase();\n    }\n\n    isLength() {\n        return RegExp('^(px|em|ex|ch|rem|in|cm|mm|pc|pt|ex|vw|vh|vmin|vmax)$', 'gi').test(this.toCSS());\n    }\n\n    isEmpty() {\n        return this.numerator.length === 0 && this.denominator.length === 0;\n    }\n\n    isSingular() {\n        return this.numerator.length <= 1 && this.denominator.length === 0;\n    }\n\n    map(callback) {\n        let i;\n\n        for (i = 0; i < this.numerator.length; i++) {\n            this.numerator[i] = callback(this.numerator[i], false);\n        }\n\n        for (i = 0; i < this.denominator.length; i++) {\n            this.denominator[i] = callback(this.denominator[i], true);\n        }\n    }\n\n    usedUnits() {\n        let group;\n        const result = {};\n        let mapUnit;\n        let groupName;\n\n        mapUnit = atomicUnit => {\n            /* jshint loopfunc:true */\n            if (group.hasOwnProperty(atomicUnit) && !result[groupName]) {\n                result[groupName] = atomicUnit;\n            }\n\n            return atomicUnit;\n        };\n\n        for (groupName in unitConversions) {\n            if (unitConversions.hasOwnProperty(groupName)) {\n                group = unitConversions[groupName];\n\n                this.map(mapUnit);\n            }\n        }\n\n        return result;\n    }\n\n    cancel() {\n        const counter = {};\n        let atomicUnit;\n        let i;\n\n        for (i = 0; i < this.numerator.length; i++) {\n            atomicUnit = this.numerator[i];\n            counter[atomicUnit] = (counter[atomicUnit] || 0) + 1;\n        }\n\n        for (i = 0; i < this.denominator.length; i++) {\n            atomicUnit = this.denominator[i];\n            counter[atomicUnit] = (counter[atomicUnit] || 0) - 1;\n        }\n\n        this.numerator = [];\n        this.denominator = [];\n\n        for (atomicUnit in counter) {\n            if (counter.hasOwnProperty(atomicUnit)) {\n                const count = counter[atomicUnit];\n\n                if (count > 0) {\n                    for (i = 0; i < count; i++) {\n                        this.numerator.push(atomicUnit);\n                    }\n                } else if (count < 0) {\n                    for (i = 0; i < -count; i++) {\n                        this.denominator.push(atomicUnit);\n                    }\n                }\n            }\n        }\n\n        this.numerator.sort();\n        this.denominator.sort();\n    }\n}\n\nUnit.prototype.type = 'Unit';\nexport default Unit;\n","import Node from './node';\nimport unitConversions from '../data/unit-conversions';\nimport Unit from './unit';\nimport Color from './color';\n\n//\n// A number with a unit\n//\nclass Dimension extends Node {\n    constructor(value, unit) {\n        super();\n\n        this.value = parseFloat(value);\n        if (isNaN(this.value)) {\n            throw new Error('Dimension is not a number.');\n        }\n        this.unit = (unit && unit instanceof Unit) ? unit :\n            new Unit(unit ? [unit] : undefined);\n        this.setParent(this.unit, this);\n    }\n\n    accept(visitor) {\n        this.unit = visitor.visit(this.unit);\n    }\n\n    eval(context) {\n        return this;\n    }\n\n    toColor() {\n        return new Color([this.value, this.value, this.value]);\n    }\n\n    genCSS(context, output) {\n        if ((context && context.strictUnits) && !this.unit.isSingular()) {\n            throw new Error(`Multiple units in dimension. Correct the units or use the unit function. Bad unit: ${this.unit.toString()}`);\n        }\n\n        const value = this.fround(context, this.value);\n        let strValue = String(value);\n\n        if (value !== 0 && value < 0.000001 && value > -0.000001) {\n            // would be output 1e-6 etc.\n            strValue = value.toFixed(20).replace(/0+$/, '');\n        }\n\n        if (context && context.compress) {\n            // Zero values doesn't need a unit\n            if (value === 0 && this.unit.isLength()) {\n                output.add(strValue);\n                return;\n            }\n\n            // Float values doesn't need a leading zero\n            if (value > 0 && value < 1) {\n                strValue = (strValue).substr(1);\n            }\n        }\n\n        output.add(strValue);\n        this.unit.genCSS(context, output);\n    }\n\n    // In an operation between two Dimensions,\n    // we default to the first Dimension's unit,\n    // so `1px + 2` will yield `3px`.\n    operate(context, op, other) {\n        /* jshint noempty:false */\n        let value = this._operate(context, op, this.value, other.value);\n\n        let unit = this.unit.clone();\n\n        if (op === '+' || op === '-') {\n            if (unit.numerator.length === 0 && unit.denominator.length === 0) {\n                unit = other.unit.clone();\n                if (this.unit.backupUnit) {\n                    unit.backupUnit = this.unit.backupUnit;\n                }\n            } else if (other.unit.numerator.length === 0 && unit.denominator.length === 0) {\n                // do nothing\n            } else {\n                other = other.convertTo(this.unit.usedUnits());\n\n                if (context.strictUnits && other.unit.toString() !== unit.toString()) {\n                    throw new Error(`Incompatible units. Change the units or use the unit function. ` + \n                        `Bad units: '${unit.toString()}' and '${other.unit.toString()}'.`);\n                }\n\n                value = this._operate(context, op, this.value, other.value);\n            }\n        } else if (op === '*') {\n            unit.numerator = unit.numerator.concat(other.unit.numerator).sort();\n            unit.denominator = unit.denominator.concat(other.unit.denominator).sort();\n            unit.cancel();\n        } else if (op === '/') {\n            unit.numerator = unit.numerator.concat(other.unit.denominator).sort();\n            unit.denominator = unit.denominator.concat(other.unit.numerator).sort();\n            unit.cancel();\n        }\n        return new Dimension(value, unit);\n    }\n\n    compare(other) {\n        let a;\n        let b;\n\n        if (!(other instanceof Dimension)) {\n            return undefined;\n        }\n\n        if (this.unit.isEmpty() || other.unit.isEmpty()) {\n            a = this;\n            b = other;\n        } else {\n            a = this.unify();\n            b = other.unify();\n            if (a.unit.compare(b.unit) !== 0) {\n                return undefined;\n            }\n        }\n\n        return Node.numericCompare(a.value, b.value);\n    }\n\n    unify() {\n        return this.convertTo({ length: 'px', duration: 's', angle: 'rad' });\n    }\n\n    convertTo(conversions) {\n        let value = this.value;\n        const unit = this.unit.clone();\n        let i;\n        let groupName;\n        let group;\n        let targetUnit;\n        let derivedConversions = {};\n        let applyUnit;\n\n        if (typeof conversions === 'string') {\n            for (i in unitConversions) {\n                if (unitConversions[i].hasOwnProperty(conversions)) {\n                    derivedConversions = {};\n                    derivedConversions[i] = conversions;\n                }\n            }\n            conversions = derivedConversions;\n        }\n        applyUnit = (atomicUnit, denominator) => {\n            /* jshint loopfunc:true */\n            if (group.hasOwnProperty(atomicUnit)) {\n                if (denominator) {\n                    value = value / (group[atomicUnit] / group[targetUnit]);\n                } else {\n                    value = value * (group[atomicUnit] / group[targetUnit]);\n                }\n\n                return targetUnit;\n            }\n\n            return atomicUnit;\n        };\n\n        for (groupName in conversions) {\n            if (conversions.hasOwnProperty(groupName)) {\n                targetUnit = conversions[groupName];\n                group = unitConversions[groupName];\n\n                unit.map(applyUnit);\n            }\n        }\n\n        unit.cancel();\n\n        return new Dimension(value, unit);\n    }\n}\n\nDimension.prototype.type = 'Dimension';\nexport default Dimension;\n","import Node from './node';\nimport Color from './color';\nimport Dimension from './dimension';\nimport * as Constants from '../constants';\nconst MATH = Constants.Math;\n\n\nclass Operation extends Node {\n    constructor(op, operands, isSpaced) {\n        super();\n\n        this.op = op.trim();\n        this.operands = operands;\n        this.isSpaced = isSpaced;\n    }\n\n    accept(visitor) {\n        this.operands = visitor.visitArray(this.operands);\n    }\n\n    eval(context) {\n        let a = this.operands[0].eval(context);\n        let b = this.operands[1].eval(context);\n        let op;\n\n        if (context.isMathOn(this.op)) {\n            op = this.op === './' ? '/' : this.op;\n            if (a instanceof Dimension && b instanceof Color) {\n                a = a.toColor();\n            }\n            if (b instanceof Dimension && a instanceof Color) {\n                b = b.toColor();\n            }\n            if (!a.operate) {\n                if (a instanceof Operation && a.op === '/' && context.math === MATH.PARENS_DIVISION) {\n                    return new Operation(this.op, [a, b], this.isSpaced);\n                }\n                throw { type: 'Operation',\n                    message: 'Operation on an invalid type' };\n            }\n\n            return a.operate(context, op, b);\n        } else {\n            return new Operation(this.op, [a, b], this.isSpaced);\n        }\n    }\n\n    genCSS(context, output) {\n        this.operands[0].genCSS(context, output);\n        if (this.isSpaced) {\n            output.add(' ');\n        }\n        output.add(this.op);\n        if (this.isSpaced) {\n            output.add(' ');\n        }\n        this.operands[1].genCSS(context, output);\n    }\n}\n\nOperation.prototype.type = 'Operation';\nexport default Operation;\n","import Node from './node';\nimport Paren from './paren';\nimport Comment from './comment';\nimport Dimension from './dimension';\nimport * as Constants from '../constants';\nconst MATH = Constants.Math;\n\nclass Expression extends Node {\n    constructor(value, noSpacing) {\n        super();\n\n        this.value = value;\n        this.noSpacing = noSpacing;\n        if (!value) {\n            throw new Error('Expression requires an array parameter');\n        }\n    }\n\n    accept(visitor) {\n        this.value = visitor.visitArray(this.value);\n    }\n\n    eval(context) {\n        let returnValue;\n        const mathOn = context.isMathOn();\n\n        const inParenthesis = this.parens && \n            (context.math !== MATH.STRICT_LEGACY || !this.parensInOp);\n\n        let doubleParen = false;\n        if (inParenthesis) {\n            context.inParenthesis();\n        }\n        if (this.value.length > 1) {\n            returnValue = new Expression(this.value.map(e => {\n                if (!e.eval) {\n                    return e;\n                }\n                return e.eval(context);\n            }), this.noSpacing);\n        } else if (this.value.length === 1) {\n            if (this.value[0].parens && !this.value[0].parensInOp && !context.inCalc) {\n                doubleParen = true;\n            }\n            returnValue = this.value[0].eval(context);\n        } else {\n            returnValue = this;\n        }\n        if (inParenthesis) {\n            context.outOfParenthesis();\n        }\n        if (this.parens && this.parensInOp && !mathOn && !doubleParen \n            && (!(returnValue instanceof Dimension))) {\n            returnValue = new Paren(returnValue);\n        }\n        return returnValue;\n    }\n\n    genCSS(context, output) {\n        for (let i = 0; i < this.value.length; i++) {\n            this.value[i].genCSS(context, output);\n            if (!this.noSpacing && i + 1 < this.value.length) {\n                output.add(' ');\n            }\n        }\n    }\n\n    throwAwayComments() {\n        this.value = this.value.filter(v => !(v instanceof Comment));\n    }\n}\n\nExpression.prototype.type = 'Expression';\nexport default Expression;\n","import Expression from '../tree/expression';\n\nclass functionCaller {\n    constructor(name, context, index, currentFileInfo) {\n        this.name = name.toLowerCase();\n        this.index = index;\n        this.context = context;\n        this.currentFileInfo = currentFileInfo;\n\n        this.func = context.frames[0].functionRegistry.get(this.name);\n    }\n\n    isValid() {\n        return Boolean(this.func);\n    }\n\n    call(args) {\n        // This code is terrible and should be replaced as per this issue...\n        // https://github.com/less/less.js/issues/2477\n        if (Array.isArray(args)) {\n            args = args.filter(item => {\n                if (item.type === 'Comment') {\n                    return false;\n                }\n                return true;\n            })\n                .map(item => {\n                    if (item.type === 'Expression') {\n                        const subNodes = item.value.filter(item => {\n                            if (item.type === 'Comment') {\n                                return false;\n                            }\n                            return true;\n                        });\n                        if (subNodes.length === 1) {\n                            return subNodes[0];\n                        } else {\n                            return new Expression(subNodes);\n                        }\n                    }\n                    return item;\n                });\n        }\n\n        return this.func(...args);\n    }\n}\n\nexport default functionCaller;\n","import Node from './node';\nimport Anonymous from './anonymous';\nimport FunctionCaller from '../functions/function-caller';\n\n//\n// A function call node.\n//\nclass Call extends Node {\n    constructor(name, args, index, currentFileInfo) {\n        super();\n\n        this.name = name;\n        this.args = args;\n        this.calc = name === 'calc';\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n    }\n\n    accept(visitor) {\n        if (this.args) {\n            this.args = visitor.visitArray(this.args);\n        }\n    }\n\n    //\n    // When evaluating a function call,\n    // we either find the function in the functionRegistry,\n    // in which case we call it, passing the  evaluated arguments,\n    // if this returns null or we cannot find the function, we\n    // simply print it out as it appeared originally [2].\n    //\n    // The reason why we evaluate the arguments, is in the case where\n    // we try to pass a variable to a function, like: `saturate(@color)`.\n    // The function should receive the value, not the variable.\n    //\n    eval(context) {\n        /**\n         * Turn off math for calc(), and switch back on for evaluating nested functions\n         */\n        const currentMathContext = context.mathOn;\n        context.mathOn = !this.calc;\n        if (this.calc || context.inCalc) {\n            context.enterCalc();\n        }\n        const args = this.args.map(a => a.eval(context));\n        if (this.calc || context.inCalc) {\n            context.exitCalc();\n        }\n        context.mathOn = currentMathContext;\n\n        let result;\n        const funcCaller = new FunctionCaller(this.name, context, this.getIndex(), this.fileInfo());\n\n        if (funcCaller.isValid()) {\n            try {\n                result = funcCaller.call(args);\n            } catch (e) {\n                throw { \n                    type: e.type || 'Runtime',\n                    message: `error evaluating function \\`${this.name}\\`${e.message ? `: ${e.message}` : ''}`,\n                    index: this.getIndex(), \n                    filename: this.fileInfo().filename,\n                    line: e.lineNumber,\n                    column: e.columnNumber\n                };\n            }\n\n            if (result !== null && result !== undefined) {\n                // Results that that are not nodes are cast as Anonymous nodes\n                // Falsy values or booleans are returned as empty nodes\n                if (!(result instanceof Node)) {\n                    if (!result || result === true) {\n                        result = new Anonymous(null); \n                    }\n                    else {\n                        result = new Anonymous(result.toString()); \n                    }\n                    \n                }\n                result._index = this._index;\n                result._fileInfo = this._fileInfo;\n                return result;\n            }\n\n        }\n\n        return new Call(this.name, args, this.getIndex(), this.fileInfo());\n    }\n\n    genCSS(context, output) {\n        output.add(`${this.name}(`, this.fileInfo(), this.getIndex());\n\n        for (let i = 0; i < this.args.length; i++) {\n            this.args[i].genCSS(context, output);\n            if (i + 1 < this.args.length) {\n                output.add(', ');\n            }\n        }\n\n        output.add(')');\n    }\n}\n\nCall.prototype.type = 'Call';\nexport default Call;\n","import Node from './node';\nimport Call from './call';\n\nclass Variable extends Node {\n    constructor(name, index, currentFileInfo) {\n        super();\n\n        this.name = name;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n    }\n\n    eval(context) {\n        let variable;\n        let name = this.name;\n\n        if (name.indexOf('@@') === 0) {\n            name = `@${new Variable(name.slice(1), this.getIndex(), this.fileInfo()).eval(context).value}`;\n        }\n\n        if (this.evaluating) {\n            throw { type: 'Name',\n                message: `Recursive variable definition for ${name}`,\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n\n        this.evaluating = true;\n\n        variable = this.find(context.frames, frame => {\n            const v = frame.variable(name);\n            if (v) {\n                if (v.important) {\n                    const importantScope = context.importantScope[context.importantScope.length - 1];\n                    importantScope.important = v.important;\n                }\n                // If in calc, wrap vars in a function call to cascade evaluate args first\n                if (context.inCalc) {\n                    return (new Call('_SELF', [v.value])).eval(context);\n                }\n                else {\n                    return v.value.eval(context);\n                }\n            }\n        });\n        if (variable) {\n            this.evaluating = false;\n            return variable;\n        } else {\n            throw { type: 'Name',\n                message: `variable ${name} is undefined`,\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n    }\n\n    find(obj, fun) {\n        for (let i = 0, r; i < obj.length; i++) {\n            r = fun.call(obj, obj[i]);\n            if (r) { return r; }\n        }\n        return null;\n    }\n}\n\nVariable.prototype.type = 'Variable';\nexport default Variable;\n","import Node from './node';\nimport Declaration from './declaration';\n\nclass Property extends Node {\n    constructor(name, index, currentFileInfo) {\n        super();\n\n        this.name = name;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n    }\n\n    eval(context) {\n        let property;\n        const name = this.name;\n        // TODO: shorten this reference\n        const mergeRules = context.pluginManager.less.visitors.ToCSSVisitor.prototype._mergeRules;\n\n        if (this.evaluating) {\n            throw { type: 'Name',\n                message: `Recursive property reference for ${name}`,\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n\n        this.evaluating = true;\n\n        property = this.find(context.frames, frame => {\n            let v;\n            const vArr = frame.property(name);\n            if (vArr) {\n                for (let i = 0; i < vArr.length; i++) {\n                    v = vArr[i];\n\n                    vArr[i] = new Declaration(v.name,\n                        v.value,\n                        v.important,\n                        v.merge,\n                        v.index,\n                        v.currentFileInfo,\n                        v.inline,\n                        v.variable\n                    );\n                }\n                mergeRules(vArr);\n\n                v = vArr[vArr.length - 1];\n                if (v.important) {\n                    const importantScope = context.importantScope[context.importantScope.length - 1];\n                    importantScope.important = v.important;\n                }\n                v = v.value.eval(context);\n                return v;\n            }\n        });\n        if (property) {\n            this.evaluating = false;\n            return property;\n        } else {\n            throw { type: 'Name',\n                message: `Property '${name}' is undefined`,\n                filename: this.currentFileInfo.filename,\n                index: this.index };\n        }\n    }\n\n    find(obj, fun) {\n        for (let i = 0, r; i < obj.length; i++) {\n            r = fun.call(obj, obj[i]);\n            if (r) { return r; }\n        }\n        return null;\n    }\n}\n\nProperty.prototype.type = 'Property';\nexport default Property;\n","import Node from './node';\n\nclass Attribute extends Node {\n    constructor(key, op, value) {\n        super();\n\n        this.key = key;\n        this.op = op;\n        this.value = value;\n    }\n\n    eval(context) {\n        return new Attribute(this.key.eval ? this.key.eval(context) : this.key,\n            this.op, (this.value && this.value.eval) ? this.value.eval(context) : this.value);\n    }\n\n    genCSS(context, output) {\n        output.add(this.toCSS(context));\n    }\n\n    toCSS(context) {\n        let value = this.key.toCSS ? this.key.toCSS(context) : this.key;\n\n        if (this.op) {\n            value += this.op;\n            value += (this.value.toCSS ? this.value.toCSS(context) : this.value);\n        }\n\n        return `[${value}]`;\n    }\n}\n\nAttribute.prototype.type = 'Attribute';\nexport default Attribute;\n","import Node from './node';\nimport Variable from './variable';\nimport Property from './property';\n\nclass Quoted extends Node {\n    constructor(str, content, escaped, index, currentFileInfo) {\n        super();\n\n        this.escaped = (escaped == null) ? true : escaped;\n        this.value = content || '';\n        this.quote = str.charAt(0);\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.variableRegex = /@\\{([\\w-]+)\\}/g;\n        this.propRegex = /\\$\\{([\\w-]+)\\}/g;\n    }\n\n    genCSS(context, output) {\n        if (!this.escaped) {\n            output.add(this.quote, this.fileInfo(), this.getIndex());\n        }\n        output.add(this.value);\n        if (!this.escaped) {\n            output.add(this.quote);\n        }\n    }\n\n    containsVariables() {\n        return this.value.match(this.variableRegex);\n    }\n\n    eval(context) {\n        const that = this;\n        let value = this.value;\n        const variableReplacement = (_, name) => {\n            const v = new Variable(`@${name}`, that.getIndex(), that.fileInfo()).eval(context, true);\n            return (v instanceof Quoted) ? v.value : v.toCSS();\n        };\n        const propertyReplacement = (_, name) => {\n            const v = new Property(`$${name}`, that.getIndex(), that.fileInfo()).eval(context, true);\n            return (v instanceof Quoted) ? v.value : v.toCSS();\n        };\n        function iterativeReplace(value, regexp, replacementFnc) {\n            let evaluatedValue = value;\n            do {\n                value = evaluatedValue.toString();\n                evaluatedValue = value.replace(regexp, replacementFnc);\n            } while (value !== evaluatedValue);\n            return evaluatedValue;\n        }\n        value = iterativeReplace(value, this.variableRegex, variableReplacement);\n        value = iterativeReplace(value, this.propRegex, propertyReplacement);\n        return new Quoted(this.quote + value + this.quote, value, this.escaped, this.getIndex(), this.fileInfo());\n    }\n\n    compare(other) {\n        // when comparing quoted strings allow the quote to differ\n        if (other.type === 'Quoted' && !this.escaped && !other.escaped) {\n            return Node.numericCompare(this.value, other.value);\n        } else {\n            return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined;\n        }\n    }\n}\n\nQuoted.prototype.type = 'Quoted';\nexport default Quoted;\n","import Node from './node';\n\nclass URL extends Node {\n    constructor(val, index, currentFileInfo, isEvald) {\n        super();\n\n        this.value = val;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.isEvald = isEvald;\n    }\n\n    accept(visitor) {\n        this.value = visitor.visit(this.value);\n    }\n\n    genCSS(context, output) {\n        output.add('url(');\n        this.value.genCSS(context, output);\n        output.add(')');\n    }\n\n    eval(context) {\n        const val = this.value.eval(context);\n        let rootpath;\n\n        if (!this.isEvald) {\n            // Add the rootpath if the URL requires a rewrite\n            rootpath = this.fileInfo() && this.fileInfo().rootpath;\n            if (typeof rootpath === 'string' &&\n                typeof val.value === 'string' &&\n                context.pathRequiresRewrite(val.value)){\n                if (!val.quote) {\n                    rootpath = escapePath(rootpath);\n                }\n                val.value = context.rewritePath(val.value, rootpath);\n            } else {\n                val.value = context.normalizePath(val.value);\n            }\n\n            // Add url args if enabled\n            if (context.urlArgs) {\n                if (!val.value.match(/^\\s*data:/)) {\n                    const delimiter = val.value.indexOf('?') === -1 ? '?' : '&';\n                    const urlArgs = delimiter + context.urlArgs;\n                    if (val.value.indexOf('#') !== -1) {\n                        val.value = val.value.replace('#', `${urlArgs}#`);\n                    } else {\n                        val.value += urlArgs;\n                    }\n                }\n            }\n        }\n\n        return new URL(val, this.getIndex(), this.fileInfo(), true);\n    }\n}\n\nURL.prototype.type = 'Url';\n\nfunction escapePath(path) {\n    return path.replace(/[\\(\\)'\"\\s]/g, match => `\\\\${match}`);\n}\n\nexport default URL;\n","import Ruleset from './ruleset';\nimport Value from './value';\nimport Selector from './selector';\nimport Anonymous from './anonymous';\nimport Expression from './expression';\nimport AtRule from './atrule';\nimport * as utils from '../utils';\n\nclass Media extends AtRule {\n    constructor(value, features, index, currentFileInfo, visibilityInfo) {\n        super();\n\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n\n        const selectors = (new Selector([], null, null, this._index, this._fileInfo)).createEmptySelectors();\n\n        this.features = new Value(features);\n        this.rules = [new Ruleset(selectors, value)];\n        this.rules[0].allowImports = true;\n        this.copyVisibilityInfo(visibilityInfo);\n        this.allowRoot = true;\n        this.setParent(selectors, this);\n        this.setParent(this.features, this);\n        this.setParent(this.rules, this);\n    }\n\n    isRulesetLike() {\n        return true;\n    }\n\n    accept(visitor) {\n        if (this.features) {\n            this.features = visitor.visit(this.features);\n        }\n        if (this.rules) {\n            this.rules = visitor.visitArray(this.rules);\n        }\n    }\n\n    genCSS(context, output) {\n        output.add('@media ', this._fileInfo, this._index);\n        this.features.genCSS(context, output);\n        this.outputRuleset(context, output, this.rules);\n    }\n\n    eval(context) {\n        if (!context.mediaBlocks) {\n            context.mediaBlocks = [];\n            context.mediaPath = [];\n        }\n\n        const media = new Media(null, [], this._index, this._fileInfo, this.visibilityInfo());\n        if (this.debugInfo) {\n            this.rules[0].debugInfo = this.debugInfo;\n            media.debugInfo = this.debugInfo;\n        }\n        \n        media.features = this.features.eval(context);\n\n        context.mediaPath.push(media);\n        context.mediaBlocks.push(media);\n\n        this.rules[0].functionRegistry = context.frames[0].functionRegistry.inherit();\n        context.frames.unshift(this.rules[0]);\n        media.rules = [this.rules[0].eval(context)];\n        context.frames.shift();\n\n        context.mediaPath.pop();\n\n        return context.mediaPath.length === 0 ? media.evalTop(context) :\n            media.evalNested(context);\n    }\n\n    evalTop(context) {\n        let result = this;\n\n        // Render all dependent Media blocks.\n        if (context.mediaBlocks.length > 1) {\n            const selectors = (new Selector([], null, null, this.getIndex(), this.fileInfo())).createEmptySelectors();\n            result = new Ruleset(selectors, context.mediaBlocks);\n            result.multiMedia = true;\n            result.copyVisibilityInfo(this.visibilityInfo());\n            this.setParent(result, this);\n        }\n\n        delete context.mediaBlocks;\n        delete context.mediaPath;\n\n        return result;\n    }\n\n    evalNested(context) {\n        let i;\n        let value;\n        const path = context.mediaPath.concat([this]);\n\n        // Extract the media-query conditions separated with `,` (OR).\n        for (i = 0; i < path.length; i++) {\n            value = path[i].features instanceof Value ?\n                path[i].features.value : path[i].features;\n            path[i] = Array.isArray(value) ? value : [value];\n        }\n\n        // Trace all permutations to generate the resulting media-query.\n        //\n        // (a, b and c) with nested (d, e) ->\n        //    a and d\n        //    a and e\n        //    b and c and d\n        //    b and c and e\n        this.features = new Value(this.permute(path).map(path => {\n            path = path.map(fragment => fragment.toCSS ? fragment : new Anonymous(fragment));\n\n            for (i = path.length - 1; i > 0; i--) {\n                path.splice(i, 0, new Anonymous('and'));\n            }\n\n            return new Expression(path);\n        }));\n        this.setParent(this.features, this);\n\n        // Fake a tree-node that doesn't output anything.\n        return new Ruleset([], []);\n    }\n\n    permute(arr) {\n        if (arr.length === 0) {\n            return [];\n        } else if (arr.length === 1) {\n            return arr[0];\n        } else {\n            const result = [];\n            const rest = this.permute(arr.slice(1));\n            for (let i = 0; i < rest.length; i++) {\n                for (let j = 0; j < arr[0].length; j++) {\n                    result.push([arr[0][j]].concat(rest[i]));\n                }\n            }\n            return result;\n        }\n    }\n\n    bubbleSelectors(selectors) {\n        if (!selectors) {\n            return;\n        }\n        this.rules = [new Ruleset(utils.copyArray(selectors), [this.rules[0]])];\n        this.setParent(this.rules, this);\n    }\n}\n\nMedia.prototype.type = 'Media';\nexport default Media;\n","import Node from './node';\nimport Media from './media';\nimport URL from './url';\nimport Quoted from './quoted';\nimport Ruleset from './ruleset';\nimport Anonymous from './anonymous';\nimport * as utils from '../utils';\nimport LessError from '../less-error';\n\n//\n// CSS @import node\n//\n// The general strategy here is that we don't want to wait\n// for the parsing to be completed, before we start importing\n// the file. That's because in the context of a browser,\n// most of the time will be spent waiting for the server to respond.\n//\n// On creation, we push the import path to our import queue, though\n// `import,push`, we also pass it a callback, which it'll call once\n// the file has been fetched, and parsed.\n//\nclass Import extends Node {\n    constructor(path, features, options, index, currentFileInfo, visibilityInfo) {\n        super();\n\n        this.options = options;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.path = path;\n        this.features = features;\n        this.allowRoot = true;\n\n        if (this.options.less !== undefined || this.options.inline) {\n            this.css = !this.options.less || this.options.inline;\n        } else {\n            const pathValue = this.getPath();\n            if (pathValue && /[#\\.\\&\\?]css([\\?;].*)?$/.test(pathValue)) {\n                this.css = true;\n            }\n        }\n        this.copyVisibilityInfo(visibilityInfo);\n        this.setParent(this.features, this);\n        this.setParent(this.path, this);\n    }\n\n    accept(visitor) {\n        if (this.features) {\n            this.features = visitor.visit(this.features);\n        }\n        this.path = visitor.visit(this.path);\n        if (!this.options.isPlugin && !this.options.inline && this.root) {\n            this.root = visitor.visit(this.root);\n        }\n    }\n\n    genCSS(context, output) {\n        if (this.css && this.path._fileInfo.reference === undefined) {\n            output.add('@import ', this._fileInfo, this._index);\n            this.path.genCSS(context, output);\n            if (this.features) {\n                output.add(' ');\n                this.features.genCSS(context, output);\n            }\n            output.add(';');\n        }\n    }\n\n    getPath() {\n        return (this.path instanceof URL) ?\n            this.path.value.value : this.path.value;\n    }\n\n    isVariableImport() {\n        let path = this.path;\n        if (path instanceof URL) {\n            path = path.value;\n        }\n        if (path instanceof Quoted) {\n            return path.containsVariables();\n        }\n\n        return true;\n    }\n\n    evalForImport(context) {\n        let path = this.path;\n\n        if (path instanceof URL) {\n            path = path.value;\n        }\n\n        return new Import(path.eval(context), this.features, this.options, this._index, this._fileInfo, this.visibilityInfo());\n    }\n\n    evalPath(context) {\n        const path = this.path.eval(context);\n        const fileInfo = this._fileInfo;\n\n        if (!(path instanceof URL)) {\n            // Add the rootpath if the URL requires a rewrite\n            const pathValue = path.value;\n            if (fileInfo &&\n                pathValue &&\n                context.pathRequiresRewrite(pathValue)) {\n                path.value = context.rewritePath(pathValue, fileInfo.rootpath);\n            } else {\n                path.value = context.normalizePath(path.value);\n            }\n        }\n\n        return path;\n    }\n\n    eval(context) {\n        const result = this.doEval(context);\n        if (this.options.reference || this.blocksVisibility()) {\n            if (result.length || result.length === 0) {\n                result.forEach(node => {\n                    node.addVisibilityBlock();\n                }\n                );\n            } else {\n                result.addVisibilityBlock();\n            }\n        }\n        return result;\n    }\n\n    doEval(context) {\n        let ruleset;\n        let registry;\n        const features = this.features && this.features.eval(context);\n\n        if (this.options.isPlugin) {\n            if (this.root && this.root.eval) {\n                try {\n                    this.root.eval(context);\n                }\n                catch (e) {\n                    e.message = 'Plugin error during evaluation';\n                    throw new LessError(e, this.root.imports, this.root.filename);\n                }\n            }\n            registry = context.frames[0] && context.frames[0].functionRegistry;\n            if ( registry && this.root && this.root.functions ) {\n                registry.addMultiple( this.root.functions );\n            }\n\n            return [];\n        }\n\n        if (this.skip) {\n            if (typeof this.skip === 'function') {\n                this.skip = this.skip();\n            }\n            if (this.skip) {\n                return [];\n            }\n        }\n        if (this.options.inline) {\n            const contents = new Anonymous(this.root, 0,\n                {\n                    filename: this.importedFilename,\n                    reference: this.path._fileInfo && this.path._fileInfo.reference\n                }, true, true);\n\n            return this.features ? new Media([contents], this.features.value) : [contents];\n        } else if (this.css) {\n            const newImport = new Import(this.evalPath(context), features, this.options, this._index);\n            if (!newImport.css && this.error) {\n                throw this.error;\n            }\n            return newImport;\n        } else {\n            ruleset = new Ruleset(null, utils.copyArray(this.root.rules));\n            ruleset.evalImports(context);\n\n            return this.features ? new Media(ruleset.rules, this.features.value) : ruleset.rules;\n        }\n    }\n}\n\nImport.prototype.type = 'Import';\nexport default Import;\n","import Node from './node';\nimport Variable from './variable';\n\nclass JsEvalNode extends Node {\n    evaluateJavaScript(expression, context) {\n        let result;\n        const that = this;\n        const evalContext = {};\n\n        if (!context.javascriptEnabled) {\n            throw { message: 'Inline JavaScript is not enabled. Is it set in your options?',\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n\n        expression = expression.replace(/@\\{([\\w-]+)\\}/g, (_, name) => that.jsify(new Variable(`@${name}`, that.getIndex(), that.fileInfo()).eval(context)));\n\n        try {\n            expression = new Function(`return (${expression})`);\n        } catch (e) {\n            throw { message: `JavaScript evaluation error: ${e.message} from \\`${expression}\\`` ,\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n\n        const variables = context.frames[0].variables();\n        for (const k in variables) {\n            if (variables.hasOwnProperty(k)) {\n                /* jshint loopfunc:true */\n                evalContext[k.slice(1)] = {\n                    value: variables[k].value,\n                    toJS: function () {\n                        return this.value.eval(context).toCSS();\n                    }\n                };\n            }\n        }\n\n        try {\n            result = expression.call(evalContext);\n        } catch (e) {\n            throw { message: `JavaScript evaluation error: '${e.name}: ${e.message.replace(/[\"]/g, '\\'')}'` ,\n                filename: this.fileInfo().filename,\n                index: this.getIndex() };\n        }\n        return result;\n    }\n\n    jsify(obj) {\n        if (Array.isArray(obj.value) && (obj.value.length > 1)) {\n            return `[${obj.value.map(v => v.toCSS()).join(', ')}]`;\n        } else {\n            return obj.toCSS();\n        }\n    }\n}\n\nexport default JsEvalNode;\n","import JsEvalNode from './js-eval-node';\nimport Dimension from './dimension';\nimport Quoted from './quoted';\nimport Anonymous from './anonymous';\n\nclass JavaScript extends JsEvalNode {\n    constructor(string, escaped, index, currentFileInfo) {\n        super();\n\n        this.escaped = escaped;\n        this.expression = string;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n    }\n\n    eval(context) {\n        const result = this.evaluateJavaScript(this.expression, context);\n        const type = typeof result;\n\n        if (type === 'number' && !isNaN(result)) {\n            return new Dimension(result);\n        } else if (type === 'string') {\n            return new Quoted(`\"${result}\"`, result, this.escaped, this._index);\n        } else if (Array.isArray(result)) {\n            return new Anonymous(result.join(', '));\n        } else {\n            return new Anonymous(result);\n        }\n    }\n}\n\nJavaScript.prototype.type = 'JavaScript';\nexport default JavaScript;\n","import Node from './node';\n\nclass Assignment extends Node {\n    constructor(key, val) {\n        super();\n\n        this.key = key;\n        this.value = val;\n    }\n\n    accept(visitor) {\n        this.value = visitor.visit(this.value);\n    }\n\n    eval(context) {\n        if (this.value.eval) {\n            return new Assignment(this.key, this.value.eval(context));\n        }\n        return this;\n    }\n\n    genCSS(context, output) {\n        output.add(`${this.key}=`);\n        if (this.value.genCSS) {\n            this.value.genCSS(context, output);\n        } else {\n            output.add(this.value);\n        }\n    }\n}\n\nAssignment.prototype.type = 'Assignment';\nexport default Assignment;\n","import Node from './node';\n\nclass Condition extends Node {\n    constructor(op, l, r, i, negate) {\n        super();\n\n        this.op = op.trim();\n        this.lvalue = l;\n        this.rvalue = r;\n        this._index = i;\n        this.negate = negate;\n    }\n\n    accept(visitor) {\n        this.lvalue = visitor.visit(this.lvalue);\n        this.rvalue = visitor.visit(this.rvalue);\n    }\n\n    eval(context) {\n        const result = ((op, a, b) => {\n            switch (op) {\n                case 'and': return a && b;\n                case 'or':  return a || b;\n                default:\n                    switch (Node.compare(a, b)) {\n                        case -1:\n                            return op === '<' || op === '=<' || op === '<=';\n                        case 0:\n                            return op === '=' || op === '>=' || op === '=<' || op === '<=';\n                        case 1:\n                            return op === '>' || op === '>=';\n                        default:\n                            return false;\n                    }\n            }\n        })(this.op, this.lvalue.eval(context), this.rvalue.eval(context));\n\n        return this.negate ? !result : result;\n    }\n}\n\nCondition.prototype.type = 'Condition';\nexport default Condition;\n","import Node from './node';\n\nclass UnicodeDescriptor extends Node {\n    constructor(value) {\n        super();\n\n        this.value = value;\n    }\n}\n\nUnicodeDescriptor.prototype.type = 'UnicodeDescriptor';\n\nexport default UnicodeDescriptor;\n","import Node from './node';\nimport Operation from './operation';\nimport Dimension from './dimension';\n\nclass Negative extends Node {\n    constructor(node) {\n        super();\n\n        this.value = node;\n    }\n\n    genCSS(context, output) {\n        output.add('-');\n        this.value.genCSS(context, output);\n    }\n\n    eval(context) {\n        if (context.isMathOn()) {\n            return (new Operation('*', [new Dimension(-1), this.value])).eval(context);\n        }\n        return new Negative(this.value.eval(context));\n    }\n}\n\nNegative.prototype.type = 'Negative';\nexport default Negative;\n","import Node from './node';\nimport Selector from './selector';\n\nclass Extend extends Node {\n    constructor(selector, option, index, currentFileInfo, visibilityInfo) {\n        super();\n\n        this.selector = selector;\n        this.option = option;\n        this.object_id = Extend.next_id++;\n        this.parent_ids = [this.object_id];\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.copyVisibilityInfo(visibilityInfo);\n        this.allowRoot = true;\n\n        switch (option) {\n            case 'all':\n                this.allowBefore = true;\n                this.allowAfter = true;\n                break;\n            default:\n                this.allowBefore = false;\n                this.allowAfter = false;\n                break;\n        }\n        this.setParent(this.selector, this);\n    }\n\n    accept(visitor) {\n        this.selector = visitor.visit(this.selector);\n    }\n\n    eval(context) {\n        return new Extend(this.selector.eval(context), this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());\n    }\n\n    clone(context) {\n        return new Extend(this.selector, this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());\n    }\n\n    // it concatenates (joins) all selectors in selector array\n    findSelfSelectors(selectors) {\n        let selfElements = [];\n        let i;\n        let selectorElements;\n\n        for (i = 0; i < selectors.length; i++) {\n            selectorElements = selectors[i].elements;\n            // duplicate the logic in genCSS function inside the selector node.\n            // future TODO - move both logics into the selector joiner visitor\n            if (i > 0 && selectorElements.length && selectorElements[0].combinator.value === '') {\n                selectorElements[0].combinator.value = ' ';\n            }\n            selfElements = selfElements.concat(selectors[i].elements);\n        }\n\n        this.selfSelectors = [new Selector(selfElements)];\n        this.selfSelectors[0].copyVisibilityInfo(this.visibilityInfo());\n    }\n}\n\nExtend.next_id = 0;\n\nExtend.prototype.type = 'Extend';\nexport default Extend;\n","import Node from './node';\nimport Variable from './variable';\nimport Ruleset from './ruleset';\nimport DetachedRuleset from './detached-ruleset';\nimport LessError from '../less-error';\n\nclass VariableCall extends Node {\n    constructor(variable, index, currentFileInfo) {\n        super();\n\n        this.variable = variable;\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.allowRoot = true;\n    }\n\n    eval(context) {\n        let rules;\n        let detachedRuleset = new Variable(this.variable, this.getIndex(), this.fileInfo()).eval(context);\n        const error = new LessError({message: `Could not evaluate variable call ${this.variable}`});\n\n        if (!detachedRuleset.ruleset) {\n            if (detachedRuleset.rules) {\n                rules = detachedRuleset;\n            }\n            else if (Array.isArray(detachedRuleset)) {\n                rules = new Ruleset('', detachedRuleset);\n            }\n            else if (Array.isArray(detachedRuleset.value)) {\n                rules = new Ruleset('', detachedRuleset.value);\n            }\n            else {\n                throw error;\n            }\n            detachedRuleset = new DetachedRuleset(rules);\n        }\n\n        if (detachedRuleset.ruleset) {\n            return detachedRuleset.callEval(context);\n        }\n        throw error;\n    }\n}\n\nVariableCall.prototype.type = 'VariableCall';\nexport default VariableCall;\n","import Node from './node';\nimport Variable from './variable';\nimport Ruleset from './ruleset';\nimport Selector from './selector';\n\nclass NamespaceValue extends Node {\n    constructor(ruleCall, lookups, important, index, fileInfo) {\n        super();\n\n        this.value = ruleCall;\n        this.lookups = lookups;\n        this.important = important;\n        this._index = index;\n        this._fileInfo = fileInfo;\n    }\n\n    eval(context) {\n        let i;\n        let j;\n        let name;\n        let rules = this.value.eval(context);\n\n        for (i = 0; i < this.lookups.length; i++) {\n            name = this.lookups[i];\n\n            /**\n             * Eval'd DRs return rulesets.\n             * Eval'd mixins return rules, so let's make a ruleset if we need it.\n             * We need to do this because of late parsing of values\n             */\n            if (Array.isArray(rules)) {\n                rules = new Ruleset([new Selector()], rules);\n            }\n\n            if (name === '') {\n                rules = rules.lastDeclaration();\n            }\n            else if (name.charAt(0) === '@') {\n                if (name.charAt(1) === '@') {\n                    name = `@${new Variable(name.substr(1)).eval(context).value}`;\n                }\n                if (rules.variables) {\n                    rules = rules.variable(name);\n                }\n                \n                if (!rules) {\n                    throw { type: 'Name',\n                        message: `variable ${name} not found`,\n                        filename: this.fileInfo().filename,\n                        index: this.getIndex() };\n                }\n            }\n            else {\n                if (name.substring(0, 2) === '$@') {\n                    name = `$${new Variable(name.substr(1)).eval(context).value}`;\n                }\n                else {\n                    name = name.charAt(0) === '$' ? name : `$${name}`;\n                }\n                if (rules.properties) {\n                    rules = rules.property(name);\n                }\n            \n                if (!rules) {\n                    throw { type: 'Name',\n                        message: `property \"${name.substr(1)}\" not found`,\n                        filename: this.fileInfo().filename,\n                        index: this.getIndex() };\n                }\n                // Properties are an array of values, since a ruleset can have multiple props.\n                // We pick the last one (the \"cascaded\" value)\n                rules = rules[rules.length - 1];\n            }\n\n            if (rules.value) {\n                rules = rules.eval(context).value;\n            }\n            if (rules.ruleset) {\n                rules = rules.ruleset.eval(context);\n            }\n        }\n        return rules;\n    }\n}\n\nNamespaceValue.prototype.type = 'NamespaceValue';\nexport default NamespaceValue;\n","import Selector from './selector';\nimport Element from './element';\nimport Ruleset from './ruleset';\nimport Declaration from './declaration';\nimport DetachedRuleset from './detached-ruleset';\nimport Expression from './expression';\nimport contexts from '../contexts';\nimport * as utils from '../utils';\n\nclass Definition extends Ruleset {\n    constructor(name, params, rules, condition, variadic, frames, visibilityInfo) {\n        super();\n\n        this.name = name || 'anonymous mixin';\n        this.selectors = [new Selector([new Element(null, name, false, this._index, this._fileInfo)])];\n        this.params = params;\n        this.condition = condition;\n        this.variadic = variadic;\n        this.arity = params.length;\n        this.rules = rules;\n        this._lookups = {};\n        const optionalParameters = [];\n        this.required = params.reduce((count, p) => {\n            if (!p.name || (p.name && !p.value)) {\n                return count + 1;\n            }\n            else {\n                optionalParameters.push(p.name);\n                return count;\n            }\n        }, 0);\n        this.optionalParameters = optionalParameters;\n        this.frames = frames;\n        this.copyVisibilityInfo(visibilityInfo);\n        this.allowRoot = true;\n    }\n\n    accept(visitor) {\n        if (this.params && this.params.length) {\n            this.params = visitor.visitArray(this.params);\n        }\n        this.rules = visitor.visitArray(this.rules);\n        if (this.condition) {\n            this.condition = visitor.visit(this.condition);\n        }\n    }\n\n    evalParams(context, mixinEnv, args, evaldArguments) {\n        /* jshint boss:true */\n        const frame = new Ruleset(null, null);\n\n        let varargs;\n        let arg;\n        const params = utils.copyArray(this.params);\n        let i;\n        let j;\n        let val;\n        let name;\n        let isNamedFound;\n        let argIndex;\n        let argsLength = 0;\n\n        if (mixinEnv.frames && mixinEnv.frames[0] && mixinEnv.frames[0].functionRegistry) {\n            frame.functionRegistry = mixinEnv.frames[0].functionRegistry.inherit();\n        }\n        mixinEnv = new contexts.Eval(mixinEnv, [frame].concat(mixinEnv.frames));\n\n        if (args) {\n            args = utils.copyArray(args);\n            argsLength = args.length;\n\n            for (i = 0; i < argsLength; i++) {\n                arg = args[i];\n                if (name = (arg && arg.name)) {\n                    isNamedFound = false;\n                    for (j = 0; j < params.length; j++) {\n                        if (!evaldArguments[j] && name === params[j].name) {\n                            evaldArguments[j] = arg.value.eval(context);\n                            frame.prependRule(new Declaration(name, arg.value.eval(context)));\n                            isNamedFound = true;\n                            break;\n                        }\n                    }\n                    if (isNamedFound) {\n                        args.splice(i, 1);\n                        i--;\n                        continue;\n                    } else {\n                        throw { type: 'Runtime', message: `Named argument for ${this.name} ${args[i].name} not found` };\n                    }\n                }\n            }\n        }\n        argIndex = 0;\n        for (i = 0; i < params.length; i++) {\n            if (evaldArguments[i]) { continue; }\n\n            arg = args && args[argIndex];\n\n            if (name = params[i].name) {\n                if (params[i].variadic) {\n                    varargs = [];\n                    for (j = argIndex; j < argsLength; j++) {\n                        varargs.push(args[j].value.eval(context));\n                    }\n                    frame.prependRule(new Declaration(name, new Expression(varargs).eval(context)));\n                } else {\n                    val = arg && arg.value;\n                    if (val) {\n                        // This was a mixin call, pass in a detached ruleset of it's eval'd rules\n                        if (Array.isArray(val)) {\n                            val = new DetachedRuleset(new Ruleset('', val));\n                        }\n                        else {\n                            val = val.eval(context);\n                        }\n                    } else if (params[i].value) {\n                        val = params[i].value.eval(mixinEnv);\n                        frame.resetCache();\n                    } else {\n                        throw { type: 'Runtime', message: `wrong number of arguments for ${this.name} (${argsLength} for ${this.arity})` };\n                    }\n\n                    frame.prependRule(new Declaration(name, val));\n                    evaldArguments[i] = val;\n                }\n            }\n\n            if (params[i].variadic && args) {\n                for (j = argIndex; j < argsLength; j++) {\n                    evaldArguments[j] = args[j].value.eval(context);\n                }\n            }\n            argIndex++;\n        }\n\n        return frame;\n    }\n\n    makeImportant() {\n        const rules = !this.rules ? this.rules : this.rules.map(r => {\n            if (r.makeImportant) {\n                return r.makeImportant(true);\n            } else {\n                return r;\n            }\n        });\n        const result = new Definition(this.name, this.params, rules, this.condition, this.variadic, this.frames);\n        return result;\n    }\n\n    eval(context) {\n        return new Definition(this.name, this.params, this.rules, this.condition, this.variadic, this.frames || utils.copyArray(context.frames));\n    }\n\n    evalCall(context, args, important) {\n        const _arguments = [];\n        const mixinFrames = this.frames ? this.frames.concat(context.frames) : context.frames;\n        const frame = this.evalParams(context, new contexts.Eval(context, mixinFrames), args, _arguments);\n        let rules;\n        let ruleset;\n\n        frame.prependRule(new Declaration('@arguments', new Expression(_arguments).eval(context)));\n\n        rules = utils.copyArray(this.rules);\n\n        ruleset = new Ruleset(null, rules);\n        ruleset.originalRuleset = this;\n        ruleset = ruleset.eval(new contexts.Eval(context, [this, frame].concat(mixinFrames)));\n        if (important) {\n            ruleset = ruleset.makeImportant();\n        }\n        return ruleset;\n    }\n\n    matchCondition(args, context) {\n        if (this.condition && !this.condition.eval(\n            new contexts.Eval(context,\n                [this.evalParams(context, /* the parameter variables */\n                    new contexts.Eval(context, this.frames ? this.frames.concat(context.frames) : context.frames), args, [])]\n                    .concat(this.frames || []) // the parent namespace/mixin frames\n                    .concat(context.frames)))) { // the current environment frames\n            return false;\n        }\n        return true;\n    }\n\n    matchArgs(args, context) {\n        const allArgsCnt = (args && args.length) || 0;\n        let len;\n        const optionalParameters = this.optionalParameters;\n        const requiredArgsCnt = !args ? 0 : args.reduce((count, p) => {\n            if (optionalParameters.indexOf(p.name) < 0) {\n                return count + 1;\n            } else {\n                return count;\n            }\n        }, 0);\n\n        if (!this.variadic) {\n            if (requiredArgsCnt < this.required) {\n                return false;\n            }\n            if (allArgsCnt > this.params.length) {\n                return false;\n            }\n        } else {\n            if (requiredArgsCnt < (this.required - 1)) {\n                return false;\n            }\n        }\n\n        // check patterns\n        len = Math.min(requiredArgsCnt, this.arity);\n\n        for (let i = 0; i < len; i++) {\n            if (!this.params[i].name && !this.params[i].variadic) {\n                if (args[i].value.eval(context).toCSS() != this.params[i].value.eval(context).toCSS()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n\nDefinition.prototype.type = 'MixinDefinition';\nDefinition.prototype.evalFirst = true;\nexport default Definition;\n","import Node from './node';\nimport Selector from './selector';\nimport MixinDefinition from './mixin-definition';\nimport defaultFunc from '../functions/default';\n\nclass MixinCall extends Node {\n    constructor(elements, args, index, currentFileInfo, important) {\n        super();\n\n        this.selector = new Selector(elements);\n        this.arguments = args || [];\n        this._index = index;\n        this._fileInfo = currentFileInfo;\n        this.important = important;\n        this.allowRoot = true;\n        this.setParent(this.selector, this);\n    }\n\n    accept(visitor) {\n        if (this.selector) {\n            this.selector = visitor.visit(this.selector);\n        }\n        if (this.arguments.length) {\n            this.arguments = visitor.visitArray(this.arguments);\n        }\n    }\n\n    eval(context) {\n        let mixins;\n        let mixin;\n        let mixinPath;\n        const args = [];\n        let arg;\n        let argValue;\n        const rules = [];\n        let match = false;\n        let i;\n        let m;\n        let f;\n        let isRecursive;\n        let isOneFound;\n        const candidates = [];\n        let candidate;\n        const conditionResult = [];\n        let defaultResult;\n        const defFalseEitherCase = -1;\n        const defNone = 0;\n        const defTrue = 1;\n        const defFalse = 2;\n        let count;\n        let originalRuleset;\n        let noArgumentsFilter;\n\n        this.selector = this.selector.eval(context);\n\n        function calcDefGroup(mixin, mixinPath) {\n            let f;\n            let p;\n            let namespace;\n\n            for (f = 0; f < 2; f++) {\n                conditionResult[f] = true;\n                defaultFunc.value(f);\n                for (p = 0; p < mixinPath.length && conditionResult[f]; p++) {\n                    namespace = mixinPath[p];\n                    if (namespace.matchCondition) {\n                        conditionResult[f] = conditionResult[f] && namespace.matchCondition(null, context);\n                    }\n                }\n                if (mixin.matchCondition) {\n                    conditionResult[f] = conditionResult[f] && mixin.matchCondition(args, context);\n                }\n            }\n            if (conditionResult[0] || conditionResult[1]) {\n                if (conditionResult[0] != conditionResult[1]) {\n                    return conditionResult[1] ?\n                        defTrue : defFalse;\n                }\n\n                return defNone;\n            }\n            return defFalseEitherCase;\n        }\n\n        for (i = 0; i < this.arguments.length; i++) {\n            arg = this.arguments[i];\n            argValue = arg.value.eval(context);\n            if (arg.expand && Array.isArray(argValue.value)) {\n                argValue = argValue.value;\n                for (m = 0; m < argValue.length; m++) {\n                    args.push({value: argValue[m]});\n                }\n            } else {\n                args.push({name: arg.name, value: argValue});\n            }\n        }\n\n        noArgumentsFilter = rule => rule.matchArgs(null, context);\n\n        for (i = 0; i < context.frames.length; i++) {\n            if ((mixins = context.frames[i].find(this.selector, null, noArgumentsFilter)).length > 0) {\n                isOneFound = true;\n\n                // To make `default()` function independent of definition order we have two \"subpasses\" here.\n                // At first we evaluate each guard *twice* (with `default() == true` and `default() == false`),\n                // and build candidate list with corresponding flags. Then, when we know all possible matches,\n                // we make a final decision.\n\n                for (m = 0; m < mixins.length; m++) {\n                    mixin = mixins[m].rule;\n                    mixinPath = mixins[m].path;\n                    isRecursive = false;\n                    for (f = 0; f < context.frames.length; f++) {\n                        if ((!(mixin instanceof MixinDefinition)) && mixin === (context.frames[f].originalRuleset || context.frames[f])) {\n                            isRecursive = true;\n                            break;\n                        }\n                    }\n                    if (isRecursive) {\n                        continue;\n                    }\n\n                    if (mixin.matchArgs(args, context)) {\n                        candidate = {mixin, group: calcDefGroup(mixin, mixinPath)};\n\n                        if (candidate.group !== defFalseEitherCase) {\n                            candidates.push(candidate);\n                        }\n\n                        match = true;\n                    }\n                }\n\n                defaultFunc.reset();\n\n                count = [0, 0, 0];\n                for (m = 0; m < candidates.length; m++) {\n                    count[candidates[m].group]++;\n                }\n\n                if (count[defNone] > 0) {\n                    defaultResult = defFalse;\n                } else {\n                    defaultResult = defTrue;\n                    if ((count[defTrue] + count[defFalse]) > 1) {\n                        throw { type: 'Runtime',\n                            message: `Ambiguous use of \\`default()\\` found when matching for \\`${this.format(args)}\\``,\n                            index: this.getIndex(), filename: this.fileInfo().filename };\n                    }\n                }\n\n                for (m = 0; m < candidates.length; m++) {\n                    candidate = candidates[m].group;\n                    if ((candidate === defNone) || (candidate === defaultResult)) {\n                        try {\n                            mixin = candidates[m].mixin;\n                            if (!(mixin instanceof MixinDefinition)) {\n                                originalRuleset = mixin.originalRuleset || mixin;\n                                mixin = new MixinDefinition('', [], mixin.rules, null, false, null, originalRuleset.visibilityInfo());\n                                mixin.originalRuleset = originalRuleset;\n                            }\n                            const newRules = mixin.evalCall(context, args, this.important).rules;\n                            this._setVisibilityToReplacement(newRules);\n                            Array.prototype.push.apply(rules, newRules);\n                        } catch (e) {\n                            throw { message: e.message, index: this.getIndex(), filename: this.fileInfo().filename, stack: e.stack };\n                        }\n                    }\n                }\n\n                if (match) {\n                    return rules;\n                }\n            }\n        }\n        if (isOneFound) {\n            throw { type:    'Runtime',\n                message: `No matching definition was found for \\`${this.format(args)}\\``,\n                index:   this.getIndex(), filename: this.fileInfo().filename };\n        } else {\n            throw { type:    'Name',\n                message: `${this.selector.toCSS().trim()} is undefined`,\n                index:   this.getIndex(), filename: this.fileInfo().filename };\n        }\n    }\n\n    _setVisibilityToReplacement(replacement) {\n        let i;\n        let rule;\n        if (this.blocksVisibility()) {\n            for (i = 0; i < replacement.length; i++) {\n                rule = replacement[i];\n                rule.addVisibilityBlock();\n            }\n        }\n    }\n\n    format(args) {\n        return `${this.selector.toCSS().trim()}(${args ? args.map(a => {\n            let argValue = '';\n            if (a.name) {\n                argValue += `${a.name}:`;\n            }\n            if (a.value.toCSS) {\n                argValue += a.value.toCSS();\n            } else {\n                argValue += '???';\n            }\n            return argValue;\n        }).join(', ') : ''})`;\n    }\n}\n\nMixinCall.prototype.type = 'MixinCall';\nexport default MixinCall;\n","const tree = Object.create(null);\n\nimport Node from './node';\nimport Color from './color';\nimport AtRule from './atrule';\nimport DetachedRuleset from './detached-ruleset';\nimport Operation from './operation';\nimport Dimension from './dimension';\nimport Unit from './unit';\nimport Keyword from './keyword';\nimport Variable from './variable';\nimport Property from './property';\nimport Ruleset from './ruleset';\nimport Element from './element';\nimport Attribute from './attribute';\nimport Combinator from './combinator';\nimport Selector from './selector';\nimport Quoted from './quoted';\nimport Expression from './expression';\nimport Declaration from './declaration';\nimport Call from './call';\nimport URL from './url';\nimport Import from './import';\nimport Comment from './comment';\nimport Anonymous from './anonymous';\nimport Value from './value';\nimport JavaScript from './javascript';\nimport Assignment from './assignment';\nimport Condition from './condition';\nimport Paren from './paren';\nimport Media from './media';\nimport UnicodeDescriptor from './unicode-descriptor';\nimport Negative from './negative';\nimport Extend from './extend';\nimport VariableCall from './variable-call';\nimport NamespaceValue from './namespace-value';\n\n// mixins\nimport MixinCall from './mixin-call';\nimport MixinDefinition from './mixin-definition';\n\nexport default {\n    Node, Color, AtRule, DetachedRuleset, Operation,\n    Dimension, Unit, Keyword, Variable, Property,\n    Ruleset, Element, Attribute, Combinator, Selector,\n    Quoted, Expression, Declaration, Call, URL, Import,\n    Comment, Anonymous, Value, JavaScript, Assignment,\n    Condition, Paren, Media, UnicodeDescriptor, Negative,\n    Extend, VariableCall, NamespaceValue,\n    mixin: {\n        Call: MixinCall,\n        Definition: MixinDefinition\n    }\n};","export default {\n    error: function(msg) {\n        this._fireEvent('error', msg);\n    },\n    warn: function(msg) {\n        this._fireEvent('warn', msg);\n    },\n    info: function(msg) {\n        this._fireEvent('info', msg);\n    },\n    debug: function(msg) {\n        this._fireEvent('debug', msg);\n    },\n    addListener: function(listener) {\n        this._listeners.push(listener);\n    },\n    removeListener: function(listener) {\n        for (let i = 0; i < this._listeners.length; i++) {\n            if (this._listeners[i] === listener) {\n                this._listeners.splice(i, 1);\n                return;\n            }\n        }\n    },\n    _fireEvent: function(type, msg) {\n        for (let i = 0; i < this._listeners.length; i++) {\n            const logFunction = this._listeners[i][type];\n            if (logFunction) {\n                logFunction(msg);\n            }\n        }\n    },\n    _listeners: []\n};\n","/**\n * @todo Document why this abstraction exists, and the relationship between\n *       environment, file managers, and plugin manager\n */\n\nimport logger from '../logger';\n\nclass environment {\n    constructor(externalEnvironment, fileManagers) {\n        this.fileManagers = fileManagers || [];\n        externalEnvironment = externalEnvironment || {};\n\n        const optionalFunctions = ['encodeBase64', 'mimeLookup', 'charsetLookup', 'getSourceMapGenerator'];\n        const requiredFunctions = [];\n        const functions = requiredFunctions.concat(optionalFunctions);\n\n        for (let i = 0; i < functions.length; i++) {\n            const propName = functions[i];\n            const environmentFunc = externalEnvironment[propName];\n            if (environmentFunc) {\n                this[propName] = environmentFunc.bind(externalEnvironment);\n            } else if (i < requiredFunctions.length) {\n                this.warn(`missing required function in environment - ${propName}`);\n            }\n        }\n    }\n\n    getFileManager(filename, currentDirectory, options, environment, isSync) {\n\n        if (!filename) {\n            logger.warn('getFileManager called with no filename.. Please report this issue. continuing.');\n        }\n        if (currentDirectory == null) {\n            logger.warn('getFileManager called with null directory.. Please report this issue. continuing.');\n        }\n\n        let fileManagers = this.fileManagers;\n        if (options.pluginManager) {\n            fileManagers = [].concat(fileManagers).concat(options.pluginManager.getFileManagers());\n        }\n        for (let i = fileManagers.length - 1; i >= 0 ; i--) {\n            const fileManager = fileManagers[i];\n            if (fileManager[isSync ? 'supportsSync' : 'supports'](filename, currentDirectory, options, environment)) {\n                return fileManager;\n            }\n        }\n        return null;\n    }\n\n    addFileManager(fileManager) {\n        this.fileManagers.push(fileManager);\n    }\n\n    clearFileManagers() {\n        this.fileManagers = [];\n    }\n}\n\nexport default environment;\n","class AbstractFileManager {\n    getPath(filename) {\n        let j = filename.lastIndexOf('?');\n        if (j > 0) {\n            filename = filename.slice(0, j);\n        }\n        j = filename.lastIndexOf('/');\n        if (j < 0) {\n            j = filename.lastIndexOf('\\\\');\n        }\n        if (j < 0) {\n            return '';\n        }\n        return filename.slice(0, j + 1);\n    }\n\n    tryAppendExtension(path, ext) {\n        return /(\\.[a-z]*$)|([\\?;].*)$/.test(path) ? path : path + ext;\n    }\n\n    tryAppendLessExtension(path) {\n        return this.tryAppendExtension(path, '.less');\n    };\n\n    supportsSync() { return false; }\n\n    alwaysMakePathsAbsolute() { return false; }\n\n    isPathAbsolute(filename) {\n        return (/^(?:[a-z-]+:|\\/|\\\\|#)/i).test(filename);\n    }\n    // TODO: pull out / replace?\n    join(basePath, laterPath) {\n        if (!basePath) {\n            return laterPath;\n        }\n        return basePath + laterPath;\n    };\n\n    pathDiff(url, baseUrl) {\n        // diff between two paths to create a relative path\n        const urlParts = this.extractUrlParts(url);\n        const baseUrlParts = this.extractUrlParts(baseUrl);\n\n        let i;\n        let max;\n        let urlDirectories;\n        let baseUrlDirectories;\n        let diff = '';\n        if (urlParts.hostPart !== baseUrlParts.hostPart) {\n            return '';\n        }\n        max = Math.max(baseUrlParts.directories.length, urlParts.directories.length);\n        for (i = 0; i < max; i++) {\n            if (baseUrlParts.directories[i] !== urlParts.directories[i]) { break; }\n        }\n        baseUrlDirectories = baseUrlParts.directories.slice(i);\n        urlDirectories = urlParts.directories.slice(i);\n        for (i = 0; i < baseUrlDirectories.length - 1; i++) {\n            diff += '../';\n        }\n        for (i = 0; i < urlDirectories.length - 1; i++) {\n            diff += `${urlDirectories[i]}/`;\n        }\n        return diff;\n    };\n    // helper function, not part of API\n    extractUrlParts(url, baseUrl) {\n        // urlParts[1] = protocol://hostname/ OR /\n        // urlParts[2] = / if path relative to host base\n        // urlParts[3] = directories\n        // urlParts[4] = filename\n        // urlParts[5] = parameters\n\n        const urlPartsRegex = /^((?:[a-z-]+:)?\\/{2}(?:[^\\/\\?#]*\\/)|([\\/\\\\]))?((?:[^\\/\\\\\\?#]*[\\/\\\\])*)([^\\/\\\\\\?#]*)([#\\?].*)?$/i;\n\n        const urlParts = url.match(urlPartsRegex);\n        const returner = {};\n        let rawDirectories = [];\n        const directories = [];\n        let i;\n        let baseUrlParts;\n\n        if (!urlParts) {\n            throw new Error(`Could not parse sheet href - '${url}'`);\n        }\n\n        // Stylesheets in IE don't always return the full path\n        if (baseUrl && (!urlParts[1] || urlParts[2])) {\n            baseUrlParts = baseUrl.match(urlPartsRegex);\n            if (!baseUrlParts) {\n                throw new Error(`Could not parse page url - '${baseUrl}'`);\n            }\n            urlParts[1] = urlParts[1] || baseUrlParts[1] || '';\n            if (!urlParts[2]) {\n                urlParts[3] = baseUrlParts[3] + urlParts[3];\n            }\n        }\n\n        if (urlParts[3]) {\n            rawDirectories = urlParts[3].replace(/\\\\/g, '/').split('/');\n\n            // collapse '..' and skip '.'\n            for (i = 0; i < rawDirectories.length; i++) {\n\n                if (rawDirectories[i] === '..') {\n                    directories.pop();\n                }\n                else if (rawDirectories[i] !== '.') {\n                    directories.push(rawDirectories[i]);\n                }\n            \n            }\n        }\n\n        returner.hostPart = urlParts[1];\n        returner.directories = directories;\n        returner.rawPath = (urlParts[1] || '') + rawDirectories.join('/');\n        returner.path = (urlParts[1] || '') + directories.join('/');\n        returner.filename = urlParts[4];\n        returner.fileUrl = returner.path + (urlParts[4] || '');\n        returner.url = returner.fileUrl + (urlParts[5] || '');\n        return returner;\n    };\n}\n\nexport default AbstractFileManager;\n","import functionRegistry from '../functions/function-registry';\nimport LessError from '../less-error';\n\nclass AbstractPluginLoader {\n    constructor() {\n        // Implemented by Node.js plugin loader\n        this.require = () => null\n    }\n\n    evalPlugin(contents, context, imports, pluginOptions, fileInfo) {\n        let loader;\n        let registry;\n        let pluginObj;\n        let localModule;\n        let pluginManager;\n        let filename;\n        let result;\n\n        pluginManager = context.pluginManager;\n\n        if (fileInfo) {\n            if (typeof fileInfo === 'string') {\n                filename = fileInfo;\n            }\n            else {\n                filename = fileInfo.filename;\n            }\n        }\n        const shortname = (new this.less.FileManager()).extractUrlParts(filename).filename;\n\n        if (filename) {\n            pluginObj = pluginManager.get(filename);\n\n            if (pluginObj) {\n                result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);\n                if (result) {\n                    return result;\n                }\n                try {\n                    if (pluginObj.use) {\n                        pluginObj.use.call(this.context, pluginObj);\n                    }\n                }\n                catch (e) {\n                    e.message = e.message || 'Error during @plugin call';\n                    return new LessError(e, imports, filename);\n                }\n                return pluginObj;\n            }\n        }\n        localModule = {\n            exports: {},\n            pluginManager,\n            fileInfo\n        };\n        registry = functionRegistry.create();\n\n        const registerPlugin = obj => {\n            pluginObj = obj;\n        };\n\n        try {\n            loader = new Function('module', 'require', 'registerPlugin', 'functions', 'tree', 'less', 'fileInfo', contents);\n            loader(localModule, this.require(filename), registerPlugin, registry, this.less.tree, this.less, fileInfo);\n        }\n        catch (e) {\n            return new LessError(e, imports, filename);\n        }\n\n        if (!pluginObj) {\n            pluginObj = localModule.exports;\n        }\n        pluginObj = this.validatePlugin(pluginObj, filename, shortname);\n\n        if (pluginObj instanceof LessError) {\n            return pluginObj;\n        }\n\n        if (pluginObj) {\n            pluginObj.imports = imports;\n            pluginObj.filename = filename;\n\n            // For < 3.x (or unspecified minVersion) - setOptions() before install()\n            if (!pluginObj.minVersion || this.compareVersion('3.0.0', pluginObj.minVersion) < 0) {\n                result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);\n\n                if (result) {\n                    return result;\n                }\n            }\n\n            // Run on first load\n            pluginManager.addPlugin(pluginObj, fileInfo.filename, registry);\n            pluginObj.functions = registry.getLocalFunctions();\n\n            // Need to call setOptions again because the pluginObj might have functions\n            result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);\n            if (result) {\n                return result;\n            }\n\n            // Run every @plugin call\n            try {\n                if (pluginObj.use) {\n                    pluginObj.use.call(this.context, pluginObj);\n                }\n            }\n            catch (e) {\n                e.message = e.message || 'Error during @plugin call';\n                return new LessError(e, imports, filename);\n            }\n\n        }\n        else {\n            return new LessError({ message: 'Not a valid plugin' }, imports, filename);\n        }\n\n        return pluginObj;\n    }\n\n    trySetOptions(plugin, filename, name, options) {\n        if (options && !plugin.setOptions) {\n            return new LessError({\n                message: `Options have been provided but the plugin ${name} does not support any options.`\n            });\n        }\n        try {\n            plugin.setOptions && plugin.setOptions(options);\n        }\n        catch (e) {\n            return new LessError(e);\n        }\n    }\n\n    validatePlugin(plugin, filename, name) {\n        if (plugin) {\n            // support plugins being a function\n            // so that the plugin can be more usable programmatically\n            if (typeof plugin === 'function') {\n                plugin = new plugin();\n            }\n\n            if (plugin.minVersion) {\n                if (this.compareVersion(plugin.minVersion, this.less.version) < 0) {\n                    return new LessError({\n                        message: `Plugin ${name} requires version ${this.versionToString(plugin.minVersion)}`\n                    });\n                }\n            }\n            return plugin;\n        }\n        return null;\n    }\n\n    compareVersion(aVersion, bVersion) {\n        if (typeof aVersion === 'string') {\n            aVersion = aVersion.match(/^(\\d+)\\.?(\\d+)?\\.?(\\d+)?/);\n            aVersion.shift();\n        }\n        for (let i = 0; i < aVersion.length; i++) {\n            if (aVersion[i] !== bVersion[i]) {\n                return parseInt(aVersion[i]) > parseInt(bVersion[i]) ? -1 : 1;\n            }\n        }\n        return 0;\n    }\n\n    versionToString(version) {\n        let versionString = '';\n        for (let i = 0; i < version.length; i++) {\n            versionString += (versionString ? '.' : '') + version[i];\n        }\n        return versionString;\n    }\n\n    printUsage(plugins) {\n        for (let i = 0; i < plugins.length; i++) {\n            const plugin = plugins[i];\n            if (plugin.printUsage) {\n                plugin.printUsage();\n            }\n        }\n    }\n}\n\nexport default AbstractPluginLoader;\n\n","import tree from '../tree';\nconst _visitArgs = { visitDeeper: true };\nlet _hasIndexed = false;\n\nfunction _noop(node) {\n    return node;\n}\n\nfunction indexNodeTypes(parent, ticker) {\n    // add .typeIndex to tree node types for lookup table\n    let key;\n\n    let child;\n    for (key in parent) { \n        /* eslint guard-for-in: 0 */\n        child = parent[key];\n        switch (typeof child) {\n            case 'function':\n                // ignore bound functions directly on tree which do not have a prototype\n                // or aren't nodes\n                if (child.prototype && child.prototype.type) {\n                    child.prototype.typeIndex = ticker++;\n                }\n                break;\n            case 'object':\n                ticker = indexNodeTypes(child, ticker);\n                break;\n        \n        }\n    }\n    return ticker;\n}\n\nclass Visitor {\n    constructor(impl) {\n        // Backwards compatibility for a non-extends pattern\n        this._impl = impl || this;\n\n        this._visitInCache = {};\n        this._visitOutCache = {};\n\n        if (!_hasIndexed) {\n            indexNodeTypes(tree, 1);\n            _hasIndexed = true;\n        }\n    }\n\n    visit(node) {\n        if (!node) {\n            return node;\n        }\n\n        const nodeTypeIndex = node.typeIndex;\n        if (!nodeTypeIndex) {\n            // MixinCall args aren't a node type?\n            if (node.value && node.value.typeIndex) {\n                this.visit(node.value);\n            }\n            return node;\n        }\n\n        const _impl = this._impl;\n        let func = this._visitInCache[nodeTypeIndex];\n        let funcOut = this._visitOutCache[nodeTypeIndex];\n        const visitArgs = _visitArgs;\n        let fnName;\n\n        visitArgs.visitDeeper = true;\n\n        if (!func) {\n            fnName = `visit${node.type}`;\n            func = _impl[fnName] || _noop;\n            funcOut = _impl[`${fnName}Out`] || _noop;\n            this._visitInCache[nodeTypeIndex] = func;\n            this._visitOutCache[nodeTypeIndex] = funcOut;\n        }\n\n        if (func !== _noop) {\n            const newNode = func.call(_impl, node, visitArgs);\n            if (node && _impl.isReplacing) {\n                node = newNode;\n            }\n        }\n\n        if (visitArgs.visitDeeper && node && node.accept) {\n            node.accept(this);\n        }\n\n        if (funcOut != _noop) {\n            funcOut.call(_impl, node);\n        }\n\n        return node;\n    }\n\n    visitArray(nodes, nonReplacing) {\n        if (!nodes) {\n            return nodes;\n        }\n\n        const cnt = nodes.length;\n        let i;\n\n        // Non-replacing\n        if (nonReplacing || !this._impl.isReplacing) {\n            for (i = 0; i < cnt; i++) {\n                this.visit(nodes[i]);\n            }\n            return nodes;\n        }\n\n        // Replacing\n        const out = [];\n        for (i = 0; i < cnt; i++) {\n            const evald = this.visit(nodes[i]);\n            if (evald === undefined) { continue; }\n            if (!evald.splice) {\n                out.push(evald);\n            } else if (evald.length) {\n                this.flatten(evald, out);\n            }\n        }\n        return out;\n    }\n\n    flatten(arr, out) {\n        if (!out) {\n            out = [];\n        }\n\n        let cnt;\n        let i;\n        let item;\n        let nestedCnt;\n        let j;\n        let nestedItem;\n\n        for (i = 0, cnt = arr.length; i < cnt; i++) {\n            item = arr[i];\n            if (item === undefined) {\n                continue;\n            }\n            if (!item.splice) {\n                out.push(item);\n                continue;\n            }\n\n            for (j = 0, nestedCnt = item.length; j < nestedCnt; j++) {\n                nestedItem = item[j];\n                if (nestedItem === undefined) {\n                    continue;\n                }\n                if (!nestedItem.splice) {\n                    out.push(nestedItem);\n                } else if (nestedItem.length) {\n                    this.flatten(nestedItem, out);\n                }\n            }\n        }\n\n        return out;\n    }\n}\n\nexport default Visitor;\n","class ImportSequencer {\n    constructor(onSequencerEmpty) {\n        this.imports = [];\n        this.variableImports = [];\n        this._onSequencerEmpty = onSequencerEmpty;\n        this._currentDepth = 0;\n    }\n\n    addImport(callback) {\n        const importSequencer = this;\n\n        const importItem = {\n            callback,\n            args: null,\n            isReady: false\n        };\n\n        this.imports.push(importItem);\n        return function(...args) {\n            importItem.args = Array.prototype.slice.call(args, 0);\n            importItem.isReady = true;\n            importSequencer.tryRun();\n        };\n    }\n\n    addVariableImport(callback) {\n        this.variableImports.push(callback);\n    }\n\n    tryRun() {\n        this._currentDepth++;\n        try {\n            while (true) {\n                while (this.imports.length > 0) {\n                    const importItem = this.imports[0];\n                    if (!importItem.isReady) {\n                        return;\n                    }\n                    this.imports = this.imports.slice(1);\n                    importItem.callback.apply(null, importItem.args);\n                }\n                if (this.variableImports.length === 0) {\n                    break;\n                }\n                const variableImport = this.variableImports[0];\n                this.variableImports = this.variableImports.slice(1);\n                variableImport();\n            }\n        } finally {\n            this._currentDepth--;\n        }\n        if (this._currentDepth === 0 && this._onSequencerEmpty) {\n            this._onSequencerEmpty();\n        }\n    }\n}\n\nexport default ImportSequencer;\n","import contexts from '../contexts';\nimport Visitor from './visitor';\nimport ImportSequencer from './import-sequencer';\nimport * as utils from '../utils';\n\nclass ImportVisitor extends Visitor {\n    constructor(importer, finish) {\n        super();\n\n        this._importer = importer;\n        this._finish = finish;\n        this.context = new contexts.Eval();\n        this.importCount = 0;\n        this.onceFileDetectionMap = {};\n        this.recursionDetector = {};\n        this._sequencer = new ImportSequencer(this._onSequencerEmpty.bind(this));\n        this.isReplacing = false;\n    }\n\n    run(root) {\n        try {\n            // process the contents\n            this.visit(root);\n        }\n        catch (e) {\n            this.error = e;\n        }\n\n        this.isFinished = true;\n        this._sequencer.tryRun();\n    }\n\n    _onSequencerEmpty() {\n        if (!this.isFinished) {\n            return;\n        }\n        this._finish(this.error);\n    }\n\n    visitImport(importNode, visitArgs) {\n        const inlineCSS = importNode.options.inline;\n\n        if (!importNode.css || inlineCSS) {\n\n            const context = new contexts.Eval(this.context, utils.copyArray(this.context.frames));\n            const importParent = context.frames[0];\n\n            this.importCount++;\n            if (importNode.isVariableImport()) {\n                this._sequencer.addVariableImport(this.processImportNode.bind(this, importNode, context, importParent));\n            } else {\n                this.processImportNode(importNode, context, importParent);\n            }\n        }\n        visitArgs.visitDeeper = false;\n    }\n\n    processImportNode(importNode, context, importParent) {\n        let evaldImportNode;\n        const inlineCSS = importNode.options.inline;\n\n        try {\n            evaldImportNode = importNode.evalForImport(context);\n        } catch (e) {\n            if (!e.filename) { e.index = importNode.getIndex(); e.filename = importNode.fileInfo().filename; }\n            // attempt to eval properly and treat as css\n            importNode.css = true;\n            // if that fails, this error will be thrown\n            importNode.error = e;\n        }\n\n        if (evaldImportNode && (!evaldImportNode.css || inlineCSS)) {\n            if (evaldImportNode.options.multiple) {\n                context.importMultiple = true;\n            }\n\n            // try appending if we haven't determined if it is css or not\n            const tryAppendLessExtension = evaldImportNode.css === undefined;\n\n            for (let i = 0; i < importParent.rules.length; i++) {\n                if (importParent.rules[i] === importNode) {\n                    importParent.rules[i] = evaldImportNode;\n                    break;\n                }\n            }\n\n            const onImported = this.onImported.bind(this, evaldImportNode, context);\n            const sequencedOnImported = this._sequencer.addImport(onImported);\n\n            this._importer.push(evaldImportNode.getPath(), tryAppendLessExtension, evaldImportNode.fileInfo(),\n                evaldImportNode.options, sequencedOnImported);\n        } else {\n            this.importCount--;\n            if (this.isFinished) {\n                this._sequencer.tryRun();\n            }\n        }\n    }\n\n    onImported(importNode, context, e, root, importedAtRoot, fullPath) {\n        if (e) {\n            if (!e.filename) {\n                e.index = importNode.getIndex(); e.filename = importNode.fileInfo().filename;\n            }\n            this.error = e;\n        }\n\n        const importVisitor = this;\n        const inlineCSS = importNode.options.inline;\n        const isPlugin = importNode.options.isPlugin;\n        const isOptional = importNode.options.optional;\n        const duplicateImport = importedAtRoot || fullPath in importVisitor.recursionDetector;\n\n        if (!context.importMultiple) {\n            if (duplicateImport) {\n                importNode.skip = true;\n            } else {\n                importNode.skip = () => {\n                    if (fullPath in importVisitor.onceFileDetectionMap) {\n                        return true;\n                    }\n                    importVisitor.onceFileDetectionMap[fullPath] = true;\n                    return false;\n                };\n            }\n        }\n\n        if (!fullPath && isOptional) {\n            importNode.skip = true;\n        }\n\n        if (root) {\n            importNode.root = root;\n            importNode.importedFilename = fullPath;\n\n            if (!inlineCSS && !isPlugin && (context.importMultiple || !duplicateImport)) {\n                importVisitor.recursionDetector[fullPath] = true;\n\n                const oldContext = this.context;\n                this.context = context;\n                try {\n                    this.visit(root);\n                } catch (e) {\n                    this.error = e;\n                }\n                this.context = oldContext;\n            }\n        }\n\n        importVisitor.importCount--;\n\n        if (importVisitor.isFinished) {\n            importVisitor._sequencer.tryRun();\n        }\n    }\n\n    visitDeclaration(declNode, visitArgs) {\n        if (declNode.value.type === 'DetachedRuleset') {\n            this.context.frames.unshift(declNode);\n        } else {\n            visitArgs.visitDeeper = false;\n        }\n    }\n\n    visitDeclarationOut(declNode) {\n        if (declNode.value.type === 'DetachedRuleset') {\n            this.context.frames.shift();\n        }\n    }\n\n    visitAtRule(atRuleNode, visitArgs) {\n        this.context.frames.unshift(atRuleNode);\n    }\n\n    visitAtRuleOut(atRuleNode) {\n        this.context.frames.shift();\n    }\n\n    visitMixinDefinition(mixinDefinitionNode, visitArgs) {\n        this.context.frames.unshift(mixinDefinitionNode);\n    }\n\n    visitMixinDefinitionOut(mixinDefinitionNode) {\n        this.context.frames.shift();\n    }\n\n    visitRuleset(rulesetNode, visitArgs) {\n        this.context.frames.unshift(rulesetNode);\n    }\n\n    visitRulesetOut(rulesetNode) {\n        this.context.frames.shift();\n    }\n\n    visitMedia(mediaNode, visitArgs) {\n        this.context.frames.unshift(mediaNode.rules[0]);\n    }\n\n    visitMediaOut(mediaNode) {\n        this.context.frames.shift();\n    }\n};\nexport default ImportVisitor;\n","class SetTreeVisibilityVisitor {\n    constructor(visible) {\n        this.visible = visible;\n    }\n\n    run(root) {\n        this.visit(root);\n    }\n\n    visitArray(nodes) {\n        if (!nodes) {\n            return nodes;\n        }\n\n        const cnt = nodes.length;\n        let i;\n        for (i = 0; i < cnt; i++) {\n            this.visit(nodes[i]);\n        }\n        return nodes;\n    }\n\n    visit(node) {\n        if (!node) {\n            return node;\n        }\n        if (node.constructor === Array) {\n            return this.visitArray(node);\n        }\n\n        if (!node.blocksVisibility || node.blocksVisibility()) {\n            return node;\n        }\n        if (this.visible) {\n            node.ensureVisibility();\n        } else {\n            node.ensureInvisibility();\n        }\n\n        node.accept(this);\n        return node;\n    }\n}\n\nexport default SetTreeVisibilityVisitor;","import Visitor from './visitor';\nimport Extend from '../tree/extend';\nimport Combinator from '../tree/combinator';\nimport Selector from '../tree/selector';\nimport Attribute from '../tree/attribute';\n\nclass ExtendFinderVisitor extends Visitor {\n    constructor() {\n        super();\n        this.extendMap = [Object.create(null)];\n        this.hasExtend = false;\n    }\n  \n    _elementValue(elValue) {\n        if (elValue instanceof Attribute) {\n            const value = elValue.value && elValue.value.value || elValue.value;\n            elValue = `[${elValue.key}${elValue.op ? elValue.op : ''}${value ? value : ''}]`;\n        }\n  \n        return elValue;\n    }\n\n    /** Creates a simplified string to quickly match selector candidates */\n    _joinPath(selArray) {\n        let css = '';\n        selArray.forEach(sel => {\n            sel.elements.forEach(el => {\n                css += el.combinator.value + this._elementValue(el.value) + '|';\n            });\n        });\n        return css.trim();\n    }\n  \n    run(root) {\n        root = this.visit(root);\n        root.extendMap = this.extendMap;\n        root.hasExtend = this.hasExtend;\n        return root;\n    }\n  \n    _visitAtRule(node) {\n        this.extendMap.unshift(Object.create(null));\n        node.extendMap = this.extendMap.slice(0);\n    }\n  \n    _visitAtRuleOut() {\n        this.extendMap.shift();\n    }\n  \n    visitMedia(node) {\n        this._visitAtRule(node);\n    }\n  \n    visitMediaOut() {\n        this._visitAtRuleOut();\n    }\n  \n    visitAtRule(node) {\n        this._visitAtRule(node);\n    }\n  \n    visitAtRuleOut() {\n        this._visitAtRuleOut();\n    }\n  \n    visitRuleset(rulesetNode) {\n        if (rulesetNode.root) {\n            return;\n        }\n\n        /**\n         * @todo document difference between `.paths` and `.selectors`\n         *       Essentially, paths are the entire tree of selectors for a nested selector,\n         *       and this appears to be created during visitor processing. \n         */\n        if (!Array.isArray(rulesetNode.paths)) {\n            return;\n        }\n  \n        const ext = this.extendMap[0];\n        const rules = rulesetNode.rules;\n        const ruleCnt = rules ? rules.length : 0;\n        const targets = [];\n        const selectorTargets = [];\n        const paths = rulesetNode.paths;\n        let css;\n  \n        const pushExtend = (node, ruleset, path) => {\n            this.hasExtend = true;\n            css = this._joinPath([node.selector]);\n            const target = [css, node.option, node.selector.elements, ruleset];\n  \n            if (path) {\n                selectorTargets.push([path, target]);\n            } else {\n                targets.push(target);\n            }\n        };\n  \n        for (let i = 0; i < ruleCnt; i++) {\n            const node = rulesetNode.rules[i];\n  \n            if (node instanceof Extend) {\n                pushExtend(node, rulesetNode);\n            }\n        }\n  \n        paths.forEach(path => {\n            const sel = path[path.length - 1];\n  \n            if (Array.isArray(sel.extendList)) {\n                sel.extendList.forEach(extend => {\n                    pushExtend(extend, rulesetNode, path);\n                });\n            }\n        });\n  \n        const addPath = (path, targets) => {\n            css = this._joinPath(path);\n            targets.forEach(target => {\n                const key = target[0];\n                const coll = [css, path, target[1], target[2], target[3]];\n  \n                if (!ext[key]) {\n                    ext[key] = [coll];\n                } else {\n                    ext[key].push(coll);\n                }\n            });\n        };\n  \n        if (this.hasExtend) {\n            paths.forEach(path => {\n                addPath(path, targets);\n            });\n            selectorTargets.forEach(pathExtend => {\n                addPath(pathExtend[0], [pathExtend[1]]);\n            });\n        }\n    }\n  \n}\n  \nclass ProcessExtendsVisitor extends Visitor {\n    constructor() {\n        super();\n        this.finder = new ExtendFinderVisitor();\n        this.ruleMap = {};\n    }\n  \n    run(root) {\n        root = this.finder.run(root);\n  \n        if (!root.hasExtend) {\n            return root;\n        }\n  \n        this.extendMap = root.extendMap;\n        return this.visit(root);\n    }\n\n    /**\n     * Create new paths given an existing selector path\n     */\n    _createDerived(targetPath, findElements, extend, extendVisible) {\n        const valueMap = new Map();\n        const extendElements = [];\n        const firstSelector = extend[0];\n  \n        extend.forEach(sel => {\n            Array.prototype.push.apply(extendElements, sel.elements);\n        });\n        const findLength = findElements.length;\n        const matches = [];\n        const allMatches = [];\n        let index;\n        let nextMatch;\n  \n        const setIndex = num => {\n            index = num;\n            nextMatch = findElements[num];\n  \n            if (num === 0) {\n                matches.length = 0;\n            }\n        };\n  \n        setIndex(0);\n  \n        /** Return a normalized value */\n        const getValue = node => {\n            if (!node) {\n                return node;\n            }\n            const value = node.value;\n            if (value instanceof Attribute) {\n                let lookup = valueMap.get(value);\n  \n                if (!lookup) {\n                    lookup = this.finder._elementValue(value);\n                    valueMap.set(value, lookup);\n                }\n  \n                return lookup;\n            }\n  \n            return value;\n        };\n  \n        const createPaths = matchArr => {\n            const outputPaths = [];\n            const listLength = matchArr.length;\n            let mapCollection;\n  \n            /** We search for all combinatorial possibilities of matches */\n            if (matchArr.length === 1) {\n                mapCollection = [new Map(matchArr[0])];\n            } else if (matchArr.length < 5) {\n                /**\n                 * This is a bit of combinatorial math.\n                 * Essentially, assign each find position to a bit, then we\n                 * generate all combinations by flipping bits. \n                 */\n                const range = Math.pow(2, listLength);\n                mapCollection = [];\n                for (let r = 1; r < range; r++) {\n                    mapCollection.push(\n                        new Map(\n                            matchArr.reduce((accumulator, match, index) => {\n                                const bit = Math.pow(2, index);\n                                if (bit & r) {\n                                    return accumulator.concat(match);\n                                }\n                                return accumulator;\n                            }, [])\n                        )\n                    );\n                }\n            } else {\n                /** To prevent combinatorial explosion, just replace globally */\n                mapCollection = [new Map(matchArr.reduce((coll, matches) => coll.concat(matches), []))];\n            }\n  \n            mapCollection.forEach(map => {\n                const paths = [];\n                targetPath.forEach(sel => {\n                    let selectorModified = false;\n                    const els = [];\n                    let startingElement;\n                    sel.elements.forEach(currentEl => {\n                        let el = map.get(currentEl);\n  \n                        if (el) {\n                            selectorModified = true;\n                            Array.prototype.push.apply(els, extendElements.map((newEl, i) => {\n                                newEl = newEl.clone();\n                                const start = startingElement || currentEl;\n  \n                                if (i === 0) {\n                                    newEl.combinator = new Combinator(start.combinator.value);\n                                }\n  \n                                return newEl;\n                            }));\n                            startingElement = null;\n                        } else if (el !== false) {\n                            els.push(currentEl);\n                        } else {\n                            selectorModified = true;\n                            startingElement = currentEl;\n                        }\n                    });\n  \n                    if (selectorModified) {\n                        if (els.length !== 0) {\n                            paths.push(\n                                new Selector(\n                                    els,\n                                    null,\n                                    sel.condition,\n                                    firstSelector.getIndex(),\n                                    firstSelector.fileInfo(),\n                                    { nodeVisible: extendVisible }\n                                ));\n                        }\n                    } else {\n                        sel.nodeVisible = extendVisible;\n                        paths.push(sel);\n                    }\n                });\n  \n                if (paths.length !== 0) {\n                    outputPaths.push(paths);\n                }\n            });\n            return outputPaths;\n        };\n  \n        targetPath.forEach(sel => {\n            for (let o = 0; o < sel.elements.length; o++) {\n                const currentEl = sel.elements[o];\n                const nextValue = getValue(nextMatch);\n                const currentValue = getValue(currentEl);\n                const combinator = currentEl.combinator.value;\n          \n                // A full match\n                if (nextValue === currentValue && (!nextMatch.combinator.value || nextMatch.combinator.value === combinator)) {\n                    /**\n                     * Determine if extend is an exact match of the selector\n                     */\n                    const extendEl = extendElements[index];\n                    let matchExtendValue = false;\n                    let matchExtendCombinator = false;\n                    if (extendEl) {\n                        matchExtendCombinator = index === 0 ? true : extendEl.combinator.value === combinator;\n                        matchExtendValue = getValue(extendEl) === currentValue;\n                    }\n                    matches.push([currentEl, index === findLength - 1, matchExtendCombinator && matchExtendValue]);\n                    setIndex(index + 1);\n            \n                    // Store as a match, and reset the finder to find more matches\n                    if (index === findLength) {\n                        allMatches.push(matches.slice(0));\n                        /**\n                         * Only find more matches if entire extend selector didn't match entire find selector\n                         */\n                        if (matches.reduce((prev, match) => {\n                            return prev && match[2]\n                        }, true)) {\n                            nextMatch = null;\n                            index = -1;\n                        } else {\n                            setIndex(0);\n                        }\n                    }\n                } else if (index > 0) {\n                    setIndex(0);\n                }\n            }\n        });\n        return createPaths(allMatches);\n    }\n  \n    _visitAtRule(node) {\n        this.extendMap = node.extendMap;\n    }\n  \n    _visitAtRuleOut() {\n        this.extendMap.shift();\n    }\n  \n    visitMedia(node) {\n        this._visitAtRule(node);\n    }\n  \n    visitMediaOut() {\n        this._visitAtRuleOut();\n    }\n  \n    visitAtRule(node) {\n        this._visitAtRule(node);\n    }\n  \n    visitAtRuleOut() {\n        this._visitAtRuleOut();\n    }\n  \n    visitRuleset(rulesetNode) {\n        if (rulesetNode.root) {\n            return;\n        }\n  \n        if (!Array.isArray(rulesetNode.paths)) {\n            return;\n        }\n  \n        const insertions = [];\n        let visitedKeys;\n  \n        const addInsertion = (selString, basePath) => {\n            this.extendMap.forEach((map, mapIndex) => {\n                const vKeys = visitedKeys[mapIndex];\n  \n                for (let key in map) {\n                    // This is a potential match\n                    if (selString.indexOf(key) > -1) {\n                        const exactMatch = selString === key;\n                        const mapKey = map[key];\n                        const mapKeyLength = mapKey.length;\n  \n                        for (let k = 0; k < mapKeyLength; k++) {\n                            const match = mapKey[k];\n  \n                            if (match[2] === 'all' || exactMatch) {\n                                const extendRuleset = match[4];\n                                const extendVisible = !extendRuleset.blocksVisibility();\n  \n                                if (k === 0) {\n                                    if (vKeys.indexOf(key) !== -1) {\n                                        /**\n                                         * This is a circular reference. Current Less behavior is just to return what we have,\n                                         * ignoring the last insertion. \n                                         */\n                                        insertions.pop();\n                                        break;\n                                    }\n  \n                                    vKeys.push(key);\n                                }\n  \n                                const newFind = match[3];\n                                const nextMatch = match[0];\n  \n                                const insertion = this._createDerived(basePath, newFind, match[1], extendVisible);\n                                insertions.push(insertion);\n\n                                /** Chain if next match doesn't currently match (self-referencing) */\n                                if (nextMatch.indexOf(key) === -1) {\n                                    insertion.forEach(path => {\n                                        addInsertion(nextMatch, path);\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n        };\n  \n        rulesetNode.paths.forEach(basePath => {\n            const selector = this.finder._joinPath(basePath);\n  \n            visitedKeys = this.extendMap.map(() => []);\n            addInsertion(selector, basePath);\n        });\n\n        /**\n         *  At this point, ruleset selectors will not match paths,\n         *  but this is necessary without re-writing the tree.\n         */\n        insertions.forEach(newPaths => {\n            newPaths.forEach(path => {\n                rulesetNode.paths.push(path);\n            });\n        });\n    }\n  \n}\n\nexport default ProcessExtendsVisitor;","import Visitor from './visitor';\n\nclass JoinSelectorVisitor extends Visitor {\n    constructor() {\n        super();\n\n        this.contexts = [[]];\n    }\n\n    run(root) {\n        return this.visit(root);\n    }\n\n    visitDeclaration(declNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    }\n\n    visitMixinDefinition(mixinDefinitionNode, visitArgs) {\n        visitArgs.visitDeeper = false;\n    }\n\n    visitRuleset(rulesetNode, visitArgs) {\n        const context = this.contexts[this.contexts.length - 1];\n        const paths = [];\n        let selectors;\n\n        this.contexts.push(paths);\n\n        if (!rulesetNode.root) {\n            selectors = rulesetNode.selectors;\n            if (selectors) {\n                selectors = selectors.filter(selector => selector.getIsOutput());\n                rulesetNode.selectors = selectors.length ? selectors : (selectors = null);\n                if (selectors) { rulesetNode.joinSelectors(paths, context, selectors); }\n            }\n            if (!selectors) { rulesetNode.rules = null; }\n            rulesetNode.paths = paths;\n        }\n    }\n\n    visitRulesetOut(rulesetNode) {\n        this.contexts.length = this.contexts.length - 1;\n    }\n\n    visitMedia(mediaNode, visitArgs) {\n        const context = this.contexts[this.contexts.length - 1];\n        mediaNode.rules[0].root = (context.length === 0 || context[0].multiMedia);\n    }\n\n    visitAtRule(atRuleNode, visitArgs) {\n        const context = this.contexts[this.contexts.length - 1];\n        if (atRuleNode.rules && atRuleNode.rules.length) {\n            atRuleNode.rules[0].root = (atRuleNode.isRooted || context.length === 0 || null);\n        }\n    }\n}\n\nexport default JoinSelectorVisitor;\n","import tree from '../tree';\nimport Visitor from './visitor';\n\nclass CSSVisitorUtils extends Visitor {\n    constructor(context) {\n        super();\n\n        this._context = context;\n    }\n\n    containsSilentNonBlockedChild(bodyRules) {\n        let rule;\n        if (!bodyRules) {\n            return false;\n        }\n        for (let r = 0; r < bodyRules.length; r++) {\n            rule = bodyRules[r];\n            if (rule.isSilent && rule.isSilent(this._context) && !rule.blocksVisibility()) {\n                // the atrule contains something that was referenced (likely by extend)\n                // therefore it needs to be shown in output too\n                return true;\n            }\n        }\n        return false;\n    }\n\n    keepOnlyVisibleChilds(owner) {\n        if (owner && owner.rules) {\n            owner.rules = owner.rules.filter(thing => thing.isVisible());\n        }\n    }\n\n    isEmpty(owner) {\n        return (owner && owner.rules) \n            ? (owner.rules.length === 0) : true;\n    }\n\n    hasVisibleSelector(rulesetNode) {\n        return (rulesetNode && rulesetNode.paths)\n            ? (rulesetNode.paths.length > 0) : false;\n    }\n\n    resolveVisibility(node, originalRules) {\n        if (!node.blocksVisibility()) {\n            if (this.isEmpty(node) && !this.containsSilentNonBlockedChild(originalRules)) {\n                return ;\n            }\n\n            return node;\n        }\n\n        const compiledRulesBody = node.rules[0];\n        this.keepOnlyVisibleChilds(compiledRulesBody);\n\n        if (this.isEmpty(compiledRulesBody)) {\n            return ;\n        }\n\n        node.ensureVisibility();\n        node.removeVisibilityBlock();\n\n        return node;\n    }\n\n    isVisibleRuleset(rulesetNode) {\n        if (rulesetNode.firstRoot) {\n            return true;\n        }\n\n        if (this.isEmpty(rulesetNode)) {\n            return false;\n        }\n\n        if (!rulesetNode.root && !this.hasVisibleSelector(rulesetNode)) {\n            return false;\n        }\n\n        return true;\n    }\n}\n\nclass ToCSSVisitor extends Visitor {\n    constructor(context) {\n        super();\n\n        this._context = context;\n        this.utils = new CSSVisitorUtils(context);\n        this.isReplacing = true;\n    }\n\n    run(root) {\n        return this.visit(root);\n    }\n\n    visitDeclaration(declNode, visitArgs) {\n        if (declNode.blocksVisibility() || declNode.variable) {\n            return;\n        }\n        return declNode;\n    }\n\n    visitMixinDefinition(mixinNode, visitArgs) {\n        // mixin definitions do not get eval'd - this means they keep state\n        // so we have to clear that state here so it isn't used if toCSS is called twice\n        mixinNode.frames = [];\n    }\n\n    visitExtend(extendNode, visitArgs) {\n    }\n\n    visitComment(commentNode, visitArgs) {\n        if (commentNode.blocksVisibility() || commentNode.isSilent(this._context)) {\n            return;\n        }\n        return commentNode;\n    }\n\n    visitMedia(mediaNode, visitArgs) {\n        const originalRules = mediaNode.rules[0].rules;\n        mediaNode.accept(this);\n        visitArgs.visitDeeper = false;\n\n        return this.utils.resolveVisibility(mediaNode, originalRules);\n    }\n\n    visitImport(importNode, visitArgs) {\n        if (importNode.blocksVisibility()) {\n            return ;\n        }\n        return importNode;\n    }\n\n    visitAtRule(atRuleNode, visitArgs) {\n        if (atRuleNode.rules && atRuleNode.rules.length) {\n            return this.visitAtRuleWithBody(atRuleNode, visitArgs);\n        } else {\n            return this.visitAtRuleWithoutBody(atRuleNode, visitArgs);\n        }\n    }\n\n    visitAnonymous(anonymousNode, visitArgs) {\n        if (!anonymousNode.blocksVisibility()) {\n            anonymousNode.accept(this);\n            return anonymousNode;\n        }\n    }\n\n    visitAtRuleWithBody(atRuleNode, visitArgs) {\n        // if there is only one nested ruleset and that one has no path, then it is\n        // just fake ruleset\n        function hasFakeRuleset(atRuleNode) {\n            const bodyRules = atRuleNode.rules;\n            return bodyRules.length === 1 && (!bodyRules[0].paths || bodyRules[0].paths.length === 0);\n        }\n        function getBodyRules(atRuleNode) {\n            const nodeRules = atRuleNode.rules;\n            if (hasFakeRuleset(atRuleNode)) {\n                return nodeRules[0].rules;\n            }\n\n            return nodeRules;\n        }\n        // it is still true that it is only one ruleset in array\n        // this is last such moment\n        // process childs\n        const originalRules = getBodyRules(atRuleNode);\n        atRuleNode.accept(this);\n        visitArgs.visitDeeper = false;\n\n        if (!this.utils.isEmpty(atRuleNode)) {\n            this._mergeRules(atRuleNode.rules[0].rules);\n        }\n\n        return this.utils.resolveVisibility(atRuleNode, originalRules);\n    }\n\n    visitAtRuleWithoutBody(atRuleNode, visitArgs) {\n        if (atRuleNode.blocksVisibility()) {\n            return;\n        }\n\n        if (atRuleNode.name === '@charset') {\n            // Only output the debug info together with subsequent @charset definitions\n            // a comment (or @media statement) before the actual @charset atrule would\n            // be considered illegal css as it has to be on the first line\n            if (this.charset) {\n                if (atRuleNode.debugInfo) {\n                    const comment = new tree.Comment(`/* ${atRuleNode.toCSS(this._context).replace(/\\n/g, '')} */\\n`);\n                    comment.debugInfo = atRuleNode.debugInfo;\n                    return this.visit(comment);\n                }\n                return;\n            }\n            this.charset = true;\n        }\n\n        return atRuleNode;\n    }\n\n    checkValidNodes(rules, isRoot) {\n        if (!rules) {\n            return;\n        }\n\n        for (let i = 0; i < rules.length; i++) {\n            const ruleNode = rules[i];\n            if (isRoot && ruleNode instanceof tree.Declaration && !ruleNode.variable) {\n                throw { message: 'Properties must be inside selector blocks. They cannot be in the root',\n                    index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename};\n            }\n            if (ruleNode instanceof tree.Call) {\n                throw { message: `Function '${ruleNode.name}' is undefined`,\n                    index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename};\n            }\n            if (ruleNode.type && !ruleNode.allowRoot) {\n                throw { message: `${ruleNode.type} node returned by a function is not valid here`,\n                    index: ruleNode.getIndex(), filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename};\n            }\n        }\n    }\n\n    visitRuleset(rulesetNode, visitArgs) {\n        // at this point rulesets are nested into each other\n        let rule;\n\n        const rulesets = [];\n\n        this.checkValidNodes(rulesetNode.rules, rulesetNode.firstRoot);\n\n        if (!rulesetNode.root) {\n            // remove invisible paths\n            this._compileRulesetPaths(rulesetNode);\n\n            // remove rulesets from this ruleset body and compile them separately\n            const nodeRules = rulesetNode.rules;\n\n            let nodeRuleCnt = nodeRules ? nodeRules.length : 0;\n            for (let i = 0; i < nodeRuleCnt; ) {\n                rule = nodeRules[i];\n                if (rule && rule.rules) {\n                    // visit because we are moving them out from being a child\n                    rulesets.push(this.visit(rule));\n                    nodeRules.splice(i, 1);\n                    nodeRuleCnt--;\n                    continue;\n                }\n                i++;\n            }\n            // accept the visitor to remove rules and refactor itself\n            // then we can decide nogw whether we want it or not\n            // compile body\n            if (nodeRuleCnt > 0) {\n                rulesetNode.accept(this);\n            } else {\n                rulesetNode.rules = null;\n            }\n            visitArgs.visitDeeper = false;\n        } else { // if (! rulesetNode.root) {\n            rulesetNode.accept(this);\n            visitArgs.visitDeeper = false;\n        }\n\n        if (rulesetNode.rules) {\n            this._mergeRules(rulesetNode.rules);\n            this._removeDuplicateRules(rulesetNode.rules);\n        }\n\n        // now decide whether we keep the ruleset\n        if (this.utils.isVisibleRuleset(rulesetNode)) {\n            rulesetNode.ensureVisibility();\n            rulesets.splice(0, 0, rulesetNode);\n        }\n\n        if (rulesets.length === 1) {\n            return rulesets[0];\n        }\n        return rulesets;\n    }\n\n    _compileRulesetPaths(rulesetNode) {\n        if (rulesetNode.paths) {\n            rulesetNode.paths = rulesetNode.paths\n                .filter(p => {\n                    let i;\n                    if (p[0].elements[0].combinator.value === ' ') {\n                        p[0].elements[0].combinator = new(tree.Combinator)('');\n                    }\n                    for (i = 0; i < p.length; i++) {\n                        if (p[i].isVisible() && p[i].getIsOutput()) {\n                            return true;\n                        }\n                    }\n                    return false;\n                });\n        }\n    }\n\n    _removeDuplicateRules(rules) {\n        if (!rules) { return; }\n\n        // remove duplicates\n        const ruleCache = {};\n\n        let ruleList;\n        let rule;\n        let i;\n\n        for (i = rules.length - 1; i >= 0 ; i--) {\n            rule = rules[i];\n            if (rule instanceof tree.Declaration) {\n                if (!ruleCache[rule.name]) {\n                    ruleCache[rule.name] = rule;\n                } else {\n                    ruleList = ruleCache[rule.name];\n                    if (ruleList instanceof tree.Declaration) {\n                        ruleList = ruleCache[rule.name] = [ruleCache[rule.name].toCSS(this._context)];\n                    }\n                    const ruleCSS = rule.toCSS(this._context);\n                    if (ruleList.indexOf(ruleCSS) !== -1) {\n                        rules.splice(i, 1);\n                    } else {\n                        ruleList.push(ruleCSS);\n                    }\n                }\n            }\n        }\n    }\n\n    _mergeRules(rules) {\n        if (!rules) {\n            return; \n        }\n\n        const groups    = {};\n        const groupsArr = [];\n\n        for (let i = 0; i < rules.length; i++) {\n            const rule = rules[i];\n            if (rule.merge) {\n                const key = rule.name;\n                groups[key] ? rules.splice(i--, 1) : \n                    groupsArr.push(groups[key] = []);\n                groups[key].push(rule);\n            }\n        }\n\n        groupsArr.forEach(group => {\n            if (group.length > 0) {\n                const result = group[0];\n                let space  = [];\n                const comma  = [new tree.Expression(space)];\n                group.forEach(rule => {\n                    if ((rule.merge === '+') && (space.length > 0)) {\n                        comma.push(new tree.Expression(space = []));\n                    }\n                    space.push(rule.value);\n                    result.important = result.important || rule.important;\n                });\n                result.value = new tree.Value(comma);\n            }\n        });\n    }\n};\n\nexport default ToCSSVisitor;\n","import Visitor from './visitor';\nimport ImportVisitor from './import-visitor';\nimport MarkVisibleSelectorsVisitor from './set-tree-visibility-visitor';\nimport ExtendVisitor from './extend-visitor';\nimport JoinSelectorVisitor from './join-selector-visitor';\nimport ToCSSVisitor from './to-css-visitor';\n\nexport default {\n    Visitor,\n    ImportVisitor,\n    MarkVisibleSelectorsVisitor,\n    ExtendVisitor,\n    JoinSelectorVisitor,\n    ToCSSVisitor\n};\n","import chunker from './chunker';\n\nexport default () => {\n    let // Less input string\n        input;\n\n    let // current chunk\n        j;\n\n    const // holds state for backtracking\n        saveStack = [];\n\n    let // furthest index the parser has gone to\n        furthest;\n\n    let // if this is furthest we got to, this is the probably cause\n        furthestPossibleErrorMessage;\n\n    let // chunkified input\n        chunks;\n\n    let // current chunk\n        current;\n\n    let // index of current chunk, in `input`\n        currentPos;\n\n    const parserInput = {};\n    const CHARCODE_SPACE = 32;\n    const CHARCODE_TAB = 9;\n    const CHARCODE_LF = 10;\n    const CHARCODE_CR = 13;\n    const CHARCODE_PLUS = 43;\n    const CHARCODE_COMMA = 44;\n    const CHARCODE_FORWARD_SLASH = 47;\n    const CHARCODE_9 = 57;\n\n    function skipWhitespace(length) {\n        const oldi = parserInput.i;\n        const oldj = j;\n        const curr = parserInput.i - currentPos;\n        const endIndex = parserInput.i + current.length - curr;\n        const mem = (parserInput.i += length);\n        const inp = input;\n        let c;\n        let nextChar;\n        let comment;\n\n        for (; parserInput.i < endIndex; parserInput.i++) {\n            c = inp.charCodeAt(parserInput.i);\n\n            if (parserInput.autoCommentAbsorb && c === CHARCODE_FORWARD_SLASH) {\n                nextChar = inp.charAt(parserInput.i + 1);\n                if (nextChar === '/') {\n                    comment = {index: parserInput.i, isLineComment: true};\n                    let nextNewLine = inp.indexOf('\\n', parserInput.i + 2);\n                    if (nextNewLine < 0) {\n                        nextNewLine = endIndex;\n                    }\n                    parserInput.i = nextNewLine;\n                    comment.text = inp.substr(comment.index, parserInput.i - comment.index);\n                    parserInput.commentStore.push(comment);\n                    continue;\n                } else if (nextChar === '*') {\n                    const nextStarSlash = inp.indexOf('*/', parserInput.i + 2);\n                    if (nextStarSlash >= 0) {\n                        comment = {\n                            index: parserInput.i,\n                            text: inp.substr(parserInput.i, nextStarSlash + 2 - parserInput.i),\n                            isLineComment: false\n                        };\n                        parserInput.i += comment.text.length - 1;\n                        parserInput.commentStore.push(comment);\n                        continue;\n                    }\n                }\n                break;\n            }\n\n            if ((c !== CHARCODE_SPACE) && (c !== CHARCODE_LF) && (c !== CHARCODE_TAB) && (c !== CHARCODE_CR)) {\n                break;\n            }\n        }\n\n        current = current.slice(length + parserInput.i - mem + curr);\n        currentPos = parserInput.i;\n\n        if (!current.length) {\n            if (j < chunks.length - 1) {\n                current = chunks[++j];\n                skipWhitespace(0); // skip space at the beginning of a chunk\n                return true; // things changed\n            }\n            parserInput.finished = true;\n        }\n\n        return oldi !== parserInput.i || oldj !== j;\n    }\n\n    parserInput.save = () => {\n        currentPos = parserInput.i;\n        saveStack.push( { current, i: parserInput.i, j });\n    };\n    parserInput.restore = possibleErrorMessage => {\n\n        if (parserInput.i > furthest || (parserInput.i === furthest && possibleErrorMessage && !furthestPossibleErrorMessage)) {\n            furthest = parserInput.i;\n            furthestPossibleErrorMessage = possibleErrorMessage;\n        }\n        const state = saveStack.pop();\n        current = state.current;\n        currentPos = parserInput.i = state.i;\n        j = state.j;\n    };\n    parserInput.forget = () => {\n        saveStack.pop();\n    };\n    parserInput.isWhitespace = offset => {\n        const pos = parserInput.i + (offset || 0);\n        const code = input.charCodeAt(pos);\n        return (code === CHARCODE_SPACE || code === CHARCODE_CR || code === CHARCODE_TAB || code === CHARCODE_LF);\n    };\n\n    // Specialization of $(tok)\n    parserInput.$re = tok => {\n        if (parserInput.i > currentPos) {\n            current = current.slice(parserInput.i - currentPos);\n            currentPos = parserInput.i;\n        }\n\n        const m = tok.exec(current);\n        if (!m) {\n            return null;\n        }\n\n        skipWhitespace(m[0].length);\n        if (typeof m === 'string') {\n            return m;\n        }\n\n        return m.length === 1 ? m[0] : m;\n    };\n\n    parserInput.$char = tok => {\n        if (input.charAt(parserInput.i) !== tok) {\n            return null;\n        }\n        skipWhitespace(1);\n        return tok;\n    };\n\n    parserInput.$str = tok => {\n        const tokLength = tok.length;\n\n        // https://jsperf.com/string-startswith/21\n        for (let i = 0; i < tokLength; i++) {\n            if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n                return null;\n            }\n        }\n\n        skipWhitespace(tokLength);\n        return tok;\n    };\n\n    parserInput.$quoted = loc => {\n        const pos = loc || parserInput.i;\n        const startChar = input.charAt(pos);\n\n        if (startChar !== '\\'' && startChar !== '\"') {\n            return;\n        }\n        const length = input.length;\n        const currentPosition = pos;\n\n        for (let i = 1; i + currentPosition < length; i++) {\n            const nextChar = input.charAt(i + currentPosition);\n            switch (nextChar) {\n                case '\\\\':\n                    i++;\n                    continue;\n                case '\\r':\n                case '\\n':\n                    break;\n                case startChar:\n                    const str = input.substr(currentPosition, i + 1);\n                    if (!loc && loc !== 0) {\n                        skipWhitespace(i + 1);\n                        return str\n                    }\n                    return [startChar, str];\n                default:\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Permissive parsing. Ignores everything except matching {} [] () and quotes\n     * until matching token (outside of blocks)\n     */\n    parserInput.$parseUntil = tok => {\n        let quote = '';\n        let returnVal = null;\n        let inComment = false;\n        let blockDepth = 0;\n        const blockStack = [];\n        const parseGroups = [];\n        const length = input.length;\n        const startPos = parserInput.i;\n        let lastPos = parserInput.i;\n        let i = parserInput.i;\n        let loop = true;\n        let testChar;\n\n        if (typeof tok === 'string') {\n            testChar = char => char === tok\n        } else {\n            testChar = char => tok.test(char)\n        }\n\n        do {\n            let prevChar;\n            let nextChar = input.charAt(i);\n            if (blockDepth === 0 && testChar(nextChar)) {\n                returnVal = input.substr(lastPos, i - lastPos);\n                if (returnVal) {\n                    parseGroups.push(returnVal);\n                }\n                else {\n                    parseGroups.push(' ');\n                }\n                returnVal = parseGroups;\n                skipWhitespace(i - startPos);\n                loop = false\n            } else {\n                if (inComment) {\n                    if (nextChar === '*' && \n                        input.charAt(i + 1) === '/') {\n                        i++;\n                        blockDepth--;\n                        inComment = false;\n                    }\n                    i++;\n                    continue;\n                }\n                switch (nextChar) {\n                    case '\\\\':\n                        i++;\n                        nextChar = input.charAt(i);\n                        parseGroups.push(input.substr(lastPos, i - lastPos + 1));\n                        lastPos = i + 1;\n                        break;\n                    case '/':\n                        if (input.charAt(i + 1) === '*') {\n                            i++;\n                            inComment = true;\n                            blockDepth++;\n                        }\n                        break;\n                    case '\\'':\n                    case '\"':\n                        quote = parserInput.$quoted(i);\n                        if (quote) {\n                            parseGroups.push(input.substr(lastPos, i - lastPos), quote);\n                            i += quote[1].length - 1;\n                            lastPos = i + 1;\n                        }\n                        else {\n                            skipWhitespace(i - startPos);\n                            returnVal = nextChar;\n                            loop = false;\n                        }\n                        break;\n                    case '{':\n                        blockStack.push('}');\n                        blockDepth++;\n                        break;\n                    case '(':\n                        blockStack.push(')');\n                        blockDepth++;\n                        break;\n                    case '[':\n                        blockStack.push(']');\n                        blockDepth++;\n                        break;\n                    case '}':\n                    case ')':\n                    case ']':\n                        const expected = blockStack.pop();\n                        if (nextChar === expected) {\n                            blockDepth--;\n                        } else {\n                            // move the parser to the error and return expected\n                            skipWhitespace(i - startPos);\n                            returnVal = expected;\n                            loop = false;\n                        }\n                }\n                i++;\n                if (i > length) {\n                    loop = false;\n                }\n            }\n            prevChar = nextChar;\n        } while (loop);\n\n        return returnVal ? returnVal : null;\n    }\n\n    parserInput.autoCommentAbsorb = true;\n    parserInput.commentStore = [];\n    parserInput.finished = false;\n\n    // Same as $(), but don't change the state of the parser,\n    // just return the match.\n    parserInput.peek = tok => {\n        if (typeof tok === 'string') {\n            // https://jsperf.com/string-startswith/21\n            for (let i = 0; i < tok.length; i++) {\n                if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            return tok.test(current);\n        }\n    };\n\n    // Specialization of peek()\n    // TODO remove or change some currentChar calls to peekChar\n    parserInput.peekChar = tok => input.charAt(parserInput.i) === tok;\n\n    parserInput.currentChar = () => input.charAt(parserInput.i);\n\n    parserInput.prevChar = () => input.charAt(parserInput.i - 1);\n\n    parserInput.getInput = () => input;\n\n    parserInput.peekNotNumeric = () => {\n        const c = input.charCodeAt(parserInput.i);\n        // Is the first char of the dimension 0-9, '.', '+' or '-'\n        return (c > CHARCODE_9 || c < CHARCODE_PLUS) || c === CHARCODE_FORWARD_SLASH || c === CHARCODE_COMMA;\n    };\n\n    parserInput.start = (str, chunkInput, failFunction) => {\n        input = str;\n        parserInput.i = j = currentPos = furthest = 0;\n\n        // chunking apparently makes things quicker (but my tests indicate\n        // it might actually make things slower in node at least)\n        // and it is a non-perfect parse - it can't recognise\n        // unquoted urls, meaning it can't distinguish comments\n        // meaning comments with quotes or {}() in them get 'counted'\n        // and then lead to parse errors.\n        // In addition if the chunking chunks in the wrong place we might\n        // not be able to parse a parser statement in one go\n        // this is officially deprecated but can be switched on via an option\n        // in the case it causes too much performance issues.\n        if (chunkInput) {\n            chunks = chunker(str, failFunction);\n        } else {\n            chunks = [str];\n        }\n\n        current = chunks[0];\n\n        skipWhitespace(0);\n    };\n\n    parserInput.end = () => {\n        let message;\n        const isFinished = parserInput.i >= input.length;\n\n        if (parserInput.i < furthest) {\n            message = furthestPossibleErrorMessage;\n            parserInput.i = furthest;\n        }\n        return {\n            isFinished,\n            furthest: parserInput.i,\n            furthestPossibleErrorMessage: message,\n            furthestReachedEnd: parserInput.i >= input.length - 1,\n            furthestChar: input[parserInput.i]\n        };\n    };\n\n    return parserInput;\n};\n","// Split the input into chunks.\nexport default (input, fail) => {\n    const len = input.length;\n    let level = 0;\n    let parenLevel = 0;\n    let lastOpening;\n    let lastOpeningParen;\n    let lastMultiComment;\n    let lastMultiCommentEndBrace;\n    const chunks = [];\n    let emitFrom = 0;\n    let chunkerCurrentIndex;\n    let currentChunkStartIndex;\n    let cc;\n    let cc2;\n    let matched;\n\n    function emitChunk(force) {\n        const len = chunkerCurrentIndex - emitFrom;\n        if (((len < 512) && !force) || !len) {\n            return;\n        }\n        chunks.push(input.slice(emitFrom, chunkerCurrentIndex + 1));\n        emitFrom = chunkerCurrentIndex + 1;\n    }\n\n    for (chunkerCurrentIndex = 0; chunkerCurrentIndex < len; chunkerCurrentIndex++) {\n        cc = input.charCodeAt(chunkerCurrentIndex);\n        if (((cc >= 97) && (cc <= 122)) || (cc < 34)) {\n            // a-z or whitespace\n            continue;\n        }\n\n        switch (cc) {\n            case 40:                        // (\n                parenLevel++;\n                lastOpeningParen = chunkerCurrentIndex;\n                continue;\n            case 41:                        // )\n                if (--parenLevel < 0) {\n                    return fail('missing opening `(`', chunkerCurrentIndex);\n                }\n                continue;\n            case 59:                        // ;\n                if (!parenLevel) { emitChunk(); }\n                continue;\n            case 123:                       // {\n                level++;\n                lastOpening = chunkerCurrentIndex;\n                continue;\n            case 125:                       // }\n                if (--level < 0) {\n                    return fail('missing opening `{`', chunkerCurrentIndex);\n                }\n                if (!level && !parenLevel) { emitChunk(); }\n                continue;\n            case 92:                        // \\\n                if (chunkerCurrentIndex < len - 1) { chunkerCurrentIndex++; continue; }\n                return fail('unescaped `\\\\`', chunkerCurrentIndex);\n            case 34:\n            case 39:\n            case 96:                        // \", ' and `\n                matched = 0;\n                currentChunkStartIndex = chunkerCurrentIndex;\n                for (chunkerCurrentIndex = chunkerCurrentIndex + 1; chunkerCurrentIndex < len; chunkerCurrentIndex++) {\n                    cc2 = input.charCodeAt(chunkerCurrentIndex);\n                    if (cc2 > 96) { continue; }\n                    if (cc2 == cc) { matched = 1; break; }\n                    if (cc2 == 92) {        // \\\n                        if (chunkerCurrentIndex == len - 1) {\n                            return fail('unescaped `\\\\`', chunkerCurrentIndex);\n                        }\n                        chunkerCurrentIndex++;\n                    }\n                }\n                if (matched) { continue; }\n                return fail(`unmatched \\`${String.fromCharCode(cc)}\\``, currentChunkStartIndex);\n            case 47:                        // /, check for comment\n                if (parenLevel || (chunkerCurrentIndex == len - 1)) { continue; }\n                cc2 = input.charCodeAt(chunkerCurrentIndex + 1);\n                if (cc2 == 47) {\n                    // //, find lnfeed\n                    for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len; chunkerCurrentIndex++) {\n                        cc2 = input.charCodeAt(chunkerCurrentIndex);\n                        if ((cc2 <= 13) && ((cc2 == 10) || (cc2 == 13))) { break; }\n                    }\n                } else if (cc2 == 42) {\n                    // /*, find */\n                    lastMultiComment = currentChunkStartIndex = chunkerCurrentIndex;\n                    for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len - 1; chunkerCurrentIndex++) {\n                        cc2 = input.charCodeAt(chunkerCurrentIndex);\n                        if (cc2 == 125) { lastMultiCommentEndBrace = chunkerCurrentIndex; }\n                        if (cc2 != 42) { continue; }\n                        if (input.charCodeAt(chunkerCurrentIndex + 1) == 47) { break; }\n                    }\n                    if (chunkerCurrentIndex == len - 1) {\n                        return fail('missing closing `*/`', currentChunkStartIndex);\n                    }\n                    chunkerCurrentIndex++;\n                }\n                continue;\n            case 42:                       // *, check for unmatched */\n                if ((chunkerCurrentIndex < len - 1) && (input.charCodeAt(chunkerCurrentIndex + 1) == 47)) {\n                    return fail('unmatched `/*`', chunkerCurrentIndex);\n                }\n                continue;\n        }\n    }\n\n    if (level !== 0) {\n        if ((lastMultiComment > lastOpening) && (lastMultiCommentEndBrace > lastMultiComment)) {\n            return fail('missing closing `}` or `*/`', lastOpening);\n        } else {\n            return fail('missing closing `}`', lastOpening);\n        }\n    } else if (parenLevel !== 0) {\n        return fail('missing closing `)`', lastOpeningParen);\n    }\n\n    emitChunk(true);\n    return chunks;\n};\n","import LessError from '../less-error';\nimport tree from '../tree';\nimport visitors from '../visitors';\nimport getParserInput from './parser-input';\nimport * as utils from '../utils';\nimport functionRegistry from '../functions/function-registry';\n\n//\n// less.js - parser\n//\n//    A relatively straight-forward predictive parser.\n//    There is no tokenization/lexing stage, the input is parsed\n//    in one sweep.\n//\n//    To make the parser fast enough to run in the browser, several\n//    optimization had to be made:\n//\n//    - Matching and slicing on a huge input is often cause of slowdowns.\n//      The solution is to chunkify the input into smaller strings.\n//      The chunks are stored in the `chunks` var,\n//      `j` holds the current chunk index, and `currentPos` holds\n//      the index of the current chunk in relation to `input`.\n//      This gives us an almost 4x speed-up.\n//\n//    - In many cases, we don't need to match individual tokens;\n//      for example, if a value doesn't hold any variables, operations\n//      or dynamic references, the parser can effectively 'skip' it,\n//      treating it as a literal.\n//      An example would be '1px solid #000' - which evaluates to itself,\n//      we don't need to know what the individual components are.\n//      The drawback, of course is that you don't get the benefits of\n//      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,\n//      and a smaller speed-up in the code-gen.\n//\n//\n//    Token matching is done with the `$` function, which either takes\n//    a terminal string or regexp, or a non-terminal function to call.\n//    It also takes care of moving all the indices forwards.\n//\n\nconst Parser = function Parser(context, imports, fileInfo) {\n    let parsers;\n    const parserInput = getParserInput();\n\n    function error(msg, type) {\n        throw new LessError(\n            {\n                index: parserInput.i,\n                filename: fileInfo.filename,\n                type: type || 'Syntax',\n                message: msg\n            },\n            imports\n        );\n    }\n\n    function expect(arg, msg) {\n        // some older browsers return typeof 'function' for RegExp\n        const result = (arg instanceof Function) ? arg.call(parsers) : parserInput.$re(arg);\n        if (result) {\n            return result;\n        }\n        \n        error(msg || (typeof arg === 'string'\n            ? `expected '${arg}' got '${parserInput.currentChar()}'`\n            : 'unexpected token'));\n    }\n\n    // Specialization of expect()\n    function expectChar(arg, msg) {\n        if (parserInput.$char(arg)) {\n            return arg;\n        }\n        error(msg || `expected '${arg}' got '${parserInput.currentChar()}'`);\n    }\n\n    function getDebugInfo(index) {\n        const filename = fileInfo.filename;\n\n        return {\n            lineNumber: utils.getLocation(index, parserInput.getInput()).line + 1,\n            fileName: filename\n        };\n    }\n\n    /**\n     *  Used after initial parsing to create nodes on the fly\n     * \n     *  @param {String} str          - string to parse \n     *  @param {Array}  parseList    - array of parsers to run input through e.g. [\"value\", \"important\"]\n     *  @param {Number} currentIndex - start number to begin indexing\n     *  @param {Object} fileInfo     - fileInfo to attach to created nodes\n     */\n    function parseNode(str, parseList, currentIndex, fileInfo, callback) {\n        let result;\n        const returnNodes = [];\n        const parser = parserInput;\n\n        try {\n            parser.start(str, false, function fail(msg, index) {\n                callback({\n                    message: msg,\n                    index: index + currentIndex\n                });\n            });\n            for (let x = 0, p, i; (p = parseList[x]); x++) {\n                i = parser.i;\n                result = parsers[p]();\n                if (result) {\n                    result._index = i + currentIndex;\n                    result._fileInfo = fileInfo;\n                    returnNodes.push(result);\n                }\n                else {\n                    returnNodes.push(null);\n                }\n            }\n\n            const endInfo = parser.end();\n            if (endInfo.isFinished) {\n                callback(null, returnNodes);\n            }\n            else {\n                callback(true, null);\n            }\n        } catch (e) {\n            throw new LessError({\n                index: e.index + currentIndex,\n                message: e.message\n            }, imports, fileInfo.filename);\n        }\n    }\n\n    //\n    // The Parser\n    //\n    return {\n        parserInput,\n        imports,\n        fileInfo,\n        parseNode,\n        //\n        // Parse an input string into an abstract syntax tree,\n        // @param str A string containing 'less' markup\n        // @param callback call `callback` when done.\n        // @param [additionalData] An optional map which can contains vars - a map (key, value) of variables to apply\n        //\n        parse: function (str, callback, additionalData) {\n            let root;\n            let error = null;\n            let globalVars;\n            let modifyVars;\n            let ignored;\n            let preText = '';\n\n            globalVars = (additionalData && additionalData.globalVars) ? `${Parser.serializeVars(additionalData.globalVars)}\\n` : '';\n            modifyVars = (additionalData && additionalData.modifyVars) ? `\\n${Parser.serializeVars(additionalData.modifyVars)}` : '';\n\n            if (context.pluginManager) {\n                const preProcessors = context.pluginManager.getPreProcessors();\n                for (let i = 0; i < preProcessors.length; i++) {\n                    str = preProcessors[i].process(str, { context, imports, fileInfo });\n                }\n            }\n\n            if (globalVars || (additionalData && additionalData.banner)) {\n                preText = ((additionalData && additionalData.banner) ? additionalData.banner : '') + globalVars;\n                ignored = imports.contentsIgnoredChars;\n                ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0;\n                ignored[fileInfo.filename] += preText.length;\n            }\n\n            str = str.replace(/\\r\\n?/g, '\\n');\n            // Remove potential UTF Byte Order Mark\n            str = preText + str.replace(/^\\uFEFF/, '') + modifyVars;\n            imports.contents[fileInfo.filename] = str;\n\n            // Start with the primary rule.\n            // The whole syntax tree is held under a Ruleset node,\n            // with the `root` property set to true, so no `{}` are\n            // output. The callback is called when the input is parsed.\n            try {\n                parserInput.start(str, context.chunkInput, function fail(msg, index) {\n                    throw new LessError({\n                        index,\n                        type: 'Parse',\n                        message: msg,\n                        filename: fileInfo.filename\n                    }, imports);\n                });\n\n                tree.Node.prototype.parse = this;\n                root = new tree.Ruleset(null, this.parsers.primary());\n                tree.Node.prototype.rootNode = root;\n                root.root = true;\n                root.firstRoot = true;\n                root.functionRegistry = functionRegistry.inherit();\n                \n            } catch (e) {\n                return callback(new LessError(e, imports, fileInfo.filename));\n            }\n\n            // If `i` is smaller than the `input.length - 1`,\n            // it means the parser wasn't able to parse the whole\n            // string, so we've got a parsing error.\n            //\n            // We try to extract a \\n delimited string,\n            // showing the line where the parse error occurred.\n            // We split it up into two parts (the part which parsed,\n            // and the part which didn't), so we can color them differently.\n            const endInfo = parserInput.end();\n            if (!endInfo.isFinished) {\n\n                let message = endInfo.furthestPossibleErrorMessage;\n\n                if (!message) {\n                    message = 'Unrecognised input';\n                    if (endInfo.furthestChar === '}') {\n                        message += '. Possibly missing opening \\'{\\'';\n                    } else if (endInfo.furthestChar === ')') {\n                        message += '. Possibly missing opening \\'(\\'';\n                    } else if (endInfo.furthestReachedEnd) {\n                        message += '. Possibly missing something';\n                    }\n                }\n\n                error = new LessError({\n                    type: 'Parse',\n                    message,\n                    index: endInfo.furthest,\n                    filename: fileInfo.filename\n                }, imports);\n            }\n\n            const finish = e => {\n                e = error || e || imports.error;\n\n                if (e) {\n                    if (!(e instanceof LessError)) {\n                        e = new LessError(e, imports, fileInfo.filename);\n                    }\n\n                    return callback(e);\n                }\n                else {\n                    return callback(null, root);\n                }\n            };\n\n            if (context.processImports !== false) {\n                new visitors.ImportVisitor(imports, finish)\n                    .run(root);\n            } else {\n                return finish();\n            }\n        },\n\n        //\n        // Here in, the parsing rules/functions\n        //\n        // The basic structure of the syntax tree generated is as follows:\n        //\n        //   Ruleset ->  Declaration -> Value -> Expression -> Entity\n        //\n        // Here's some Less code:\n        //\n        //    .class {\n        //      color: #fff;\n        //      border: 1px solid #000;\n        //      width: @w + 4px;\n        //      > .child {...}\n        //    }\n        //\n        // And here's what the parse tree might look like:\n        //\n        //     Ruleset (Selector '.class', [\n        //         Declaration (\"color\",  Value ([Expression [Color #fff]]))\n        //         Declaration (\"border\", Value ([Expression [Dimension 1px][Keyword \"solid\"][Color #000]]))\n        //         Declaration (\"width\",  Value ([Expression [Operation \" + \" [Variable \"@w\"][Dimension 4px]]]))\n        //         Ruleset (Selector [Element '>', '.child'], [...])\n        //     ])\n        //\n        //  In general, most rules will try to parse a token with the `$re()` function, and if the return\n        //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check\n        //  first, before parsing, that's when we use `peek()`.\n        //\n        parsers: parsers = {\n            //\n            // The `primary` rule is the *entry* and *exit* point of the parser.\n            // The rules here can appear at any level of the parse tree.\n            //\n            // The recursive nature of the grammar is an interplay between the `block`\n            // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,\n            // as represented by this simplified grammar:\n            //\n            //     primary    (ruleset | declaration)+\n            //     ruleset    selector+ block\n            //     block      '{' primary '}'\n            //\n            // Only at one point is the primary rule not called from the\n            // block rule: at the root level.\n            //\n            primary: function () {\n                const mixin = this.mixin;\n                let root = [];\n                let node;\n\n                while (true) {\n                    while (true) {\n                        node = this.comment();\n                        if (!node) { break; }\n                        root.push(node);\n                    }\n                    // always process comments before deciding if finished\n                    if (parserInput.finished) {\n                        break;\n                    }\n                    if (parserInput.peek('}')) {\n                        break;\n                    }\n\n                    node = this.extendRule();\n                    if (node) {\n                        root = root.concat(node);\n                        continue;\n                    }\n\n                    node = mixin.definition() || this.declaration() || this.ruleset() ||\n                        mixin.call(false, false) || this.variableCall() || this.entities.call() || this.atrule();\n                    if (node) {\n                        root.push(node);\n                    } else {\n                        let foundSemiColon = false;\n                        while (parserInput.$char(';')) {\n                            foundSemiColon = true;\n                        }\n                        if (!foundSemiColon) {\n                            break;\n                        }\n                    }\n                }\n\n                return root;\n            },\n\n            // comments are collected by the main parsing mechanism and then assigned to nodes\n            // where the current structure allows it\n            comment: function () {\n                if (parserInput.commentStore.length) {\n                    const comment = parserInput.commentStore.shift();\n                    return new(tree.Comment)(comment.text, comment.isLineComment, comment.index, fileInfo);\n                }\n            },\n\n            //\n            // Entities are tokens which can be found inside an Expression\n            //\n            entities: {\n                mixinLookup: function() {\n                    return parsers.mixin.call(true, true);\n                },\n                //\n                // A string, which supports escaping \" and '\n                //\n                //     \"milky way\" 'he\\'s the one!'\n                //\n                quoted: function (forceEscaped) {\n                    let str;\n                    const index = parserInput.i;\n                    let isEscaped = false;\n\n                    parserInput.save();\n                    if (parserInput.$char('~')) {\n                        isEscaped = true;\n                    } else if (forceEscaped) {\n                        parserInput.restore();\n                        return;\n                    }\n\n                    str = parserInput.$quoted();\n                    if (!str) {\n                        parserInput.restore();\n                        return;\n                    }\n                    parserInput.forget();\n\n                    return new(tree.Quoted)(str.charAt(0), str.substr(1, str.length - 2), isEscaped, index, fileInfo);\n                },\n\n                //\n                // A catch-all word, such as:\n                //\n                //     black border-collapse\n                //\n                keyword: function () {\n                    const k = parserInput.$char('%') || parserInput.$re(/^\\[?(?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+\\]?/);\n                    if (k) {\n                        return tree.Color.fromKeyword(k) || new(tree.Keyword)(k);\n                    }\n                },\n\n                //\n                // A function call\n                //\n                //     rgb(255, 0, 255)\n                //\n                // The arguments are parsed with the `entities.arguments` parser.\n                //\n                call: function () {\n                    let name;\n                    let args;\n                    let func;\n                    const index = parserInput.i;\n\n                    // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\n                    if (parserInput.peek(/^url\\(/i)) {\n                        return;\n                    }\n\n                    parserInput.save();\n\n                    name = parserInput.$re(/^([\\w-]+|%|progid:[\\w\\.]+)\\(/);\n                    if (!name) {\n                        parserInput.forget(); \n                        return;\n                    }\n\n                    name = name[1];\n                    func = this.customFuncCall(name);\n                    if (func) {\n                        args = func.parse();\n                        if (args && func.stop) {\n                            parserInput.forget();\n                            return args;\n                        }\n                    }\n\n                    args = this.arguments(args);\n\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore('Could not parse call arguments or missing \\')\\'');\n                        return;\n                    }\n\n                    parserInput.forget();\n\n                    return new(tree.Call)(name, args, index, fileInfo);\n                },\n                \n                //\n                // Parsing rules for functions with non-standard args, e.g.:\n                //\n                //     boolean(not(2 > 1))\n                //\n                //     This is a quick prototype, to be modified/improved when\n                //     more custom-parsed funcs come (e.g. `selector(...)`)\n                //\n\n                customFuncCall: function (name) {\n                    /* Ideally the table is to be moved out of here for faster perf.,\n                       but it's quite tricky since it relies on all these `parsers`\n                       and `expect` available only here */\n                    return {\n                        alpha:   f(parsers.ieAlpha, true),\n                        boolean: f(condition),\n                        'if':    f(condition)\n                    }[name.toLowerCase()];\n\n                    function f(parse, stop) {\n                        return {\n                            parse, // parsing function\n                            stop   // when true - stop after parse() and return its result, \n                            // otherwise continue for plain args\n                        };\n                    }\n                \n                    function condition() {\n                        return [expect(parsers.condition, 'expected condition')];\n                    }\n                },\n\n                arguments: function (prevArgs) {\n                    let argsComma = prevArgs || [];\n                    const argsSemiColon = [];\n                    let isSemiColonSeparated;\n                    let value;\n\n                    parserInput.save();\n\n                    while (true) {\n                        if (prevArgs) {\n                            prevArgs = false;\n                        } else {\n                            value = parsers.detachedRuleset() || this.assignment() || parsers.expression();\n                            if (!value) {\n                                break;\n                            }\n\n                            if (value.value && value.value.length == 1) {\n                                value = value.value[0];\n                            }\n\n                            argsComma.push(value);\n                        }\n\n                        if (parserInput.$char(',')) {\n                            continue;\n                        }\n\n                        if (parserInput.$char(';') || isSemiColonSeparated) {\n                            isSemiColonSeparated = true;\n                            value = (argsComma.length < 1) ? argsComma[0]\n                                : new tree.Value(argsComma);\n                            argsSemiColon.push(value);\n                            argsComma = [];\n                        }\n                    }\n\n                    parserInput.forget();\n                    return isSemiColonSeparated ? argsSemiColon : argsComma;\n                },\n                literal: function () {\n                    return this.dimension() ||\n                           this.color() ||\n                           this.quoted() ||\n                           this.unicodeDescriptor();\n                },\n\n                // Assignments are argument entities for calls.\n                // They are present in ie filter properties as shown below.\n                //\n                //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )\n                //\n\n                assignment: function () {\n                    let key;\n                    let value;\n                    parserInput.save();\n                    key = parserInput.$re(/^\\w+(?=\\s?=)/i);\n                    if (!key) {\n                        parserInput.restore();\n                        return;\n                    }\n                    if (!parserInput.$char('=')) {\n                        parserInput.restore();\n                        return;\n                    }\n                    value = parsers.entity();\n                    if (value) {\n                        parserInput.forget();\n                        return new(tree.Assignment)(key, value);\n                    } else {\n                        parserInput.restore();\n                    }\n                },\n\n                //\n                // Parse url() tokens\n                //\n                // We use a specific rule for urls, because they don't really behave like\n                // standard function calls. The difference is that the argument doesn't have\n                // to be enclosed within a string, so it can't be parsed as an Expression.\n                //\n                url: function () {\n                    let value;\n                    const index = parserInput.i;\n\n                    parserInput.autoCommentAbsorb = false;\n\n                    if (!parserInput.$str('url(')) {\n                        parserInput.autoCommentAbsorb = true;\n                        return;\n                    }\n\n                    value = this.quoted() || this.variable() || this.property() ||\n                            parserInput.$re(/^(?:(?:\\\\[\\(\\)'\"])|[^\\(\\)'\"])+/) || '';\n\n                    parserInput.autoCommentAbsorb = true;\n\n                    expectChar(')');\n\n                    return new(tree.URL)((value.value != null || \n                        value instanceof tree.Variable || \n                        value instanceof tree.Property) ?\n                        value : new(tree.Anonymous)(value, index), index, fileInfo);\n                },\n\n                //\n                // A Variable entity, such as `@fink`, in\n                //\n                //     width: @fink + 2px\n                //\n                // We use a different parser for variable definitions,\n                // see `parsers.variable`.\n                //\n                variable: function () {\n                    let ch;\n                    let name;\n                    const index = parserInput.i;\n\n                    parserInput.save();\n                    if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^@@?[\\w-]+/))) {\n                        ch = parserInput.currentChar();\n                        if (ch === '(' || ch === '[' && !parserInput.prevChar().match(/^\\s/)) {\n                            // this may be a VariableCall lookup\n                            const result = parsers.variableCall(name);\n                            if (result) {\n                                parserInput.forget();\n                                return result;\n                            }\n                        }\n                        parserInput.forget();\n                        return new(tree.Variable)(name, index, fileInfo);\n                    }\n                    parserInput.restore();\n                },\n\n                // A variable entity using the protective {} e.g. @{var}\n                variableCurly: function () {\n                    let curly;\n                    const index = parserInput.i;\n\n                    if (parserInput.currentChar() === '@' && (curly = parserInput.$re(/^@\\{([\\w-]+)\\}/))) {\n                        return new(tree.Variable)(`@${curly[1]}`, index, fileInfo);\n                    }\n                },\n                //\n                // A Property accessor, such as `$color`, in\n                //\n                //     background-color: $color\n                //\n                property: function () {\n                    let name;\n                    const index = parserInput.i;\n\n                    if (parserInput.currentChar() === '$' && (name = parserInput.$re(/^\\$[\\w-]+/))) {\n                        return new(tree.Property)(name, index, fileInfo);\n                    }\n                },\n\n                // A property entity useing the protective {} e.g. ${prop}\n                propertyCurly: function () {\n                    let curly;\n                    const index = parserInput.i;\n\n                    if (parserInput.currentChar() === '$' && (curly = parserInput.$re(/^\\$\\{([\\w-]+)\\}/))) {\n                        return new(tree.Property)(`$${curly[1]}`, index, fileInfo);\n                    }\n                },\n                //\n                // A Hexadecimal color\n                //\n                //     #4F3C2F\n                //\n                // `rgb` and `hsl` colors are parsed through the `entities.call` parser.\n                //\n                color: function () {\n                    let rgb;\n                    parserInput.save();\n\n                    if (parserInput.currentChar() === '#' && (rgb = parserInput.$re(/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})([\\w.#\\[])?/))) {\n                        if (!rgb[2]) {\n                            parserInput.forget();\n                            return new(tree.Color)(rgb[1], undefined, rgb[0]);\n                        } \n                    }\n                    parserInput.restore();\n                },\n\n                colorKeyword: function () {\n                    parserInput.save();\n                    const autoCommentAbsorb = parserInput.autoCommentAbsorb;\n                    parserInput.autoCommentAbsorb = false;\n                    const k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/);\n                    parserInput.autoCommentAbsorb = autoCommentAbsorb;\n                    if (!k) {\n                        parserInput.forget();\n                        return;\n                    }\n                    parserInput.restore();\n                    const color = tree.Color.fromKeyword(k);\n                    if (color) {\n                        parserInput.$str(k);\n                        return color;\n                    }\n                },\n\n                //\n                // A Dimension, that is, a number and a unit\n                //\n                //     0.5em 95%\n                //\n                dimension: function () {\n                    if (parserInput.peekNotNumeric()) {\n                        return;\n                    }\n\n                    const value = parserInput.$re(/^([+-]?\\d*\\.?\\d+)(%|[a-z_]+)?/i);\n                    if (value) {\n                        return new(tree.Dimension)(value[1], value[2]);\n                    }\n                },\n\n                //\n                // A unicode descriptor, as is used in unicode-range\n                //\n                // U+0??  or U+00A1-00A9\n                //\n                unicodeDescriptor: function () {\n                    let ud;\n\n                    ud = parserInput.$re(/^U\\+[0-9a-fA-F?]+(\\-[0-9a-fA-F?]+)?/);\n                    if (ud) {\n                        return new(tree.UnicodeDescriptor)(ud[0]);\n                    }\n                },\n\n                //\n                // JavaScript code to be evaluated\n                //\n                //     `window.location.href`\n                //\n                javascript: function () {\n                    let js;\n                    const index = parserInput.i;\n\n                    parserInput.save();\n\n                    const escape = parserInput.$char('~');\n                    const jsQuote = parserInput.$char('`');\n\n                    if (!jsQuote) {\n                        parserInput.restore();\n                        return;\n                    }\n\n                    js = parserInput.$re(/^[^`]*`/);\n                    if (js) {\n                        parserInput.forget();\n                        return new(tree.JavaScript)(js.substr(0, js.length - 1), Boolean(escape), index, fileInfo);\n                    }\n                    parserInput.restore('invalid javascript definition');\n                }\n            },\n\n            //\n            // The variable part of a variable definition. Used in the `rule` parser\n            //\n            //     @fink:\n            //\n            variable: function () {\n                let name;\n\n                if (parserInput.currentChar() === '@' && (name = parserInput.$re(/^(@[\\w-]+)\\s*:/))) { return name[1]; }\n            },\n\n            //\n            // Call a variable value to retrieve a detached ruleset\n            // or a value from a detached ruleset's rules.\n            //\n            //     @fink();\n            //     @fink;\n            //     color: @fink[@color];\n            //\n            variableCall: function (parsedName) {\n                let lookups;\n                let important;\n                const i = parserInput.i;\n                const inValue = !!parsedName;\n                let name = parsedName;\n\n                parserInput.save();\n\n                if (name || (parserInput.currentChar() === '@'\n                    && (name = parserInput.$re(/^(@[\\w-]+)(\\(\\s*\\))?/)))) {\n\n                    lookups = this.mixin.ruleLookups();\n\n                    if (!lookups && ((inValue && parserInput.$str('()') !== '()') || (name[2] !== '()'))) {\n                        parserInput.restore('Missing \\'[...]\\' lookup in variable call');\n                        return;\n                    }\n\n                    if (!inValue) {\n                        name = name[1];\n                    }\n\n                    if (lookups && parsers.important()) {\n                        important = true;\n                    }\n\n                    const call = new tree.VariableCall(name, i, fileInfo);\n                    if (!inValue && parsers.end()) {\n                        parserInput.forget();\n                        return call;\n                    }\n                    else {\n                        parserInput.forget();\n                        return new tree.NamespaceValue(call, lookups, important, i, fileInfo);\n                    }\n                }\n\n                parserInput.restore();\n            },\n\n            //\n            // extend syntax - used to extend selectors\n            //\n            extend: function(isRule) {\n                let elements;\n                let e;\n                const index = parserInput.i;\n                let option;\n                let extendList;\n                let extend;\n\n                if (!parserInput.$str(isRule ? '&:extend(' : ':extend(')) {\n                    return;\n                }\n\n                do {\n                    option = null;\n                    elements = null;\n                    while (!(option = parserInput.$re(/^(all)(?=\\s*(\\)|,))/))) {\n                        e = this.element();\n                        if (!e) {\n                            break;\n                        }\n                        if (elements) {\n                            elements.push(e);\n                        } else {\n                            elements = [ e ];\n                        }\n                    }\n\n                    option = option && option[1];\n                    if (!elements) {\n                        error('Missing target selector for :extend().');\n                    }\n                    extend = new(tree.Extend)(new(tree.Selector)(elements), option, index, fileInfo);\n                    if (extendList) {\n                        extendList.push(extend);\n                    } else {\n                        extendList = [ extend ];\n                    }\n                } while (parserInput.$char(','));\n\n                expect(/^\\)/);\n\n                if (isRule) {\n                    expect(/^;/);\n                }\n\n                return extendList;\n            },\n\n            //\n            // extendRule - used in a rule to extend all the parent selectors\n            //\n            extendRule: function() {\n                return this.extend(true);\n            },\n\n            //\n            // Mixins\n            //\n            mixin: {\n                //\n                // A Mixin call, with an optional argument list\n                //\n                //     #mixins > .square(#fff);\n                //     #mixins.square(#fff);\n                //     .rounded(4px, black);\n                //     .button;\n                //\n                // We can lookup / return a value using the lookup syntax:\n                //\n                //     color: #mixin.square(#fff)[@color];\n                //\n                // The `while` loop is there because mixins can be\n                // namespaced, but we only support the child and descendant\n                // selector for now.\n                //\n                call: function (inValue, getLookup) {\n                    const s = parserInput.currentChar();\n                    let important = false;\n                    let lookups;\n                    const index = parserInput.i;\n                    let elements;\n                    let args;\n                    let hasParens;\n\n                    if (s !== '.' && s !== '#') { return; }\n\n                    parserInput.save(); // stop us absorbing part of an invalid selector\n\n                    elements = this.elements();\n\n                    if (elements) {\n                        if (parserInput.$char('(')) {\n                            args = this.args(true).args;\n                            expectChar(')');\n                            hasParens = true;\n                        }\n\n                        if (getLookup !== false) {\n                            lookups = this.ruleLookups();\n                        }\n                        if (getLookup === true && !lookups) {\n                            parserInput.restore();\n                            return;\n                        }\n\n                        if (inValue && !lookups && !hasParens) {\n                            // This isn't a valid in-value mixin call\n                            parserInput.restore();\n                            return;\n                        }\n\n                        if (!inValue && parsers.important()) {\n                            important = true;\n                        }\n\n                        if (inValue || parsers.end()) {\n                            parserInput.forget();\n                            const mixin = new(tree.mixin.Call)(elements, args, index, fileInfo, !lookups && important);\n                            if (lookups) {\n                                return new tree.NamespaceValue(mixin, lookups, important);\n                            }\n                            else {\n                                return mixin;\n                            }\n                        }\n                    }\n\n                    parserInput.restore();\n                },\n                /**\n                 * Matching elements for mixins\n                 * (Start with . or # and can have > )\n                 */\n                elements: function() {\n                    let elements;\n                    let e;\n                    let c;\n                    let elem;\n                    let elemIndex;\n                    const re = /^[#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/;\n                    while (true) {\n                        elemIndex = parserInput.i;\n                        e = parserInput.$re(re);\n                        \n                        if (!e) {\n                            break;\n                        }\n                        elem = new(tree.Element)(c, e, false, elemIndex, fileInfo);\n                        if (elements) {\n                            elements.push(elem);\n                        } else {\n                            elements = [ elem ];\n                        }\n                        c = parserInput.$char('>');\n                    }\n                    return elements;\n                },\n                args: function (isCall) {\n                    const entities = parsers.entities;\n                    const returner = { args:null, variadic: false };\n                    let expressions = [];\n                    const argsSemiColon = [];\n                    const argsComma = [];\n                    let isSemiColonSeparated;\n                    let expressionContainsNamed;\n                    let name;\n                    let nameLoop;\n                    let value;\n                    let arg;\n                    let expand;\n                    let hasSep = true;\n\n                    parserInput.save();\n\n                    while (true) {\n                        if (isCall) {\n                            arg = parsers.detachedRuleset() || parsers.expression();\n                        } else {\n                            parserInput.commentStore.length = 0;\n                            if (parserInput.$str('...')) {\n                                returner.variadic = true;\n                                if (parserInput.$char(';') && !isSemiColonSeparated) {\n                                    isSemiColonSeparated = true;\n                                }\n                                (isSemiColonSeparated ? argsSemiColon : argsComma)\n                                    .push({ variadic: true });\n                                break;\n                            }\n                            arg = entities.variable() || entities.property() || entities.literal() || entities.keyword() || this.call(true);\n                        }\n\n                        if (!arg || !hasSep) {\n                            break;\n                        }\n\n                        nameLoop = null;\n                        if (arg.throwAwayComments) {\n                            arg.throwAwayComments();\n                        }\n                        value = arg;\n                        let val = null;\n\n                        if (isCall) {\n                            // Variable\n                            if (arg.value && arg.value.length == 1) {\n                                val = arg.value[0];\n                            }\n                        } else {\n                            val = arg;\n                        }\n\n                        if (val && (val instanceof tree.Variable || val instanceof tree.Property)) {\n                            if (parserInput.$char(':')) {\n                                if (expressions.length > 0) {\n                                    if (isSemiColonSeparated) {\n                                        error('Cannot mix ; and , as delimiter types');\n                                    }\n                                    expressionContainsNamed = true;\n                                }\n\n                                value = parsers.detachedRuleset() || parsers.expression();\n\n                                if (!value) {\n                                    if (isCall) {\n                                        error('could not understand value for named argument');\n                                    } else {\n                                        parserInput.restore();\n                                        returner.args = [];\n                                        return returner;\n                                    }\n                                }\n                                nameLoop = (name = val.name);\n                            } else if (parserInput.$str('...')) {\n                                if (!isCall) {\n                                    returner.variadic = true;\n                                    if (parserInput.$char(';') && !isSemiColonSeparated) {\n                                        isSemiColonSeparated = true;\n                                    }\n                                    (isSemiColonSeparated ? argsSemiColon : argsComma)\n                                        .push({ name: arg.name, variadic: true });\n                                    break;\n                                } else {\n                                    expand = true;\n                                }\n                            } else if (!isCall) {\n                                name = nameLoop = val.name;\n                                value = null;\n                            }\n                        }\n\n                        if (value) {\n                            expressions.push(value);\n                        }\n\n                        argsComma.push({ name:nameLoop, value, expand });\n\n                        if (parserInput.$char(',')) {\n                            hasSep = true;\n                            continue;\n                        }\n                        hasSep = parserInput.$char(';') === ';';\n\n                        if (hasSep || isSemiColonSeparated) {\n\n                            if (expressionContainsNamed) {\n                                error('Cannot mix ; and , as delimiter types');\n                            }\n\n                            isSemiColonSeparated = true;\n\n                            if (expressions.length > 1) {\n                                value = new(tree.Value)(expressions);\n                            }\n                            argsSemiColon.push({ name, value, expand });\n\n                            name = null;\n                            expressions = [];\n                            expressionContainsNamed = false;\n                        }\n                    }\n\n                    parserInput.forget();\n                    returner.args = isSemiColonSeparated ? argsSemiColon : argsComma;\n                    return returner;\n                },\n                //\n                // A Mixin definition, with a list of parameters\n                //\n                //     .rounded (@radius: 2px, @color) {\n                //        ...\n                //     }\n                //\n                // Until we have a finer grained state-machine, we have to\n                // do a look-ahead, to make sure we don't have a mixin call.\n                // See the `rule` function for more information.\n                //\n                // We start by matching `.rounded (`, and then proceed on to\n                // the argument list, which has optional default values.\n                // We store the parameters in `params`, with a `value` key,\n                // if there is a value, such as in the case of `@radius`.\n                //\n                // Once we've got our params list, and a closing `)`, we parse\n                // the `{...}` block.\n                //\n                definition: function () {\n                    let name;\n                    let params = [];\n                    let match;\n                    let ruleset;\n                    let cond;\n                    let variadic = false;\n                    if ((parserInput.currentChar() !== '.' && parserInput.currentChar() !== '#') ||\n                        parserInput.peek(/^[^{]*\\}/)) {\n                        return;\n                    }\n\n                    parserInput.save();\n\n                    match = parserInput.$re(/^([#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\\s*\\(/);\n                    if (match) {\n                        name = match[1];\n\n                        const argInfo = this.args(false);\n                        params = argInfo.args;\n                        variadic = argInfo.variadic;\n\n                        // .mixincall(\"@{a}\");\n                        // looks a bit like a mixin definition..\n                        // also\n                        // .mixincall(@a: {rule: set;});\n                        // so we have to be nice and restore\n                        if (!parserInput.$char(')')) {\n                            parserInput.restore('Missing closing \\')\\'');\n                            return;\n                        }\n\n                        parserInput.commentStore.length = 0;\n\n                        if (parserInput.$str('when')) { // Guard\n                            cond = expect(parsers.conditions, 'expected condition');\n                        }\n\n                        ruleset = parsers.block();\n\n                        if (ruleset) {\n                            parserInput.forget();\n                            return new(tree.mixin.Definition)(name, params, ruleset, cond, variadic);\n                        } else {\n                            parserInput.restore();\n                        }\n                    } else {\n                        parserInput.forget();\n                    }\n                },\n            \n                ruleLookups: function() {\n                    let rule;\n                    let args;\n                    const lookups = [];\n\n                    if (parserInput.currentChar() !== '[') { \n                        return;\n                    }\n\n                    while (true) {\n                        parserInput.save();\n                        args = null;\n                        rule = this.lookupValue();\n                        if (!rule && rule !== '') {\n                            parserInput.restore();\n                            break;\n                        }\n                        lookups.push(rule);\n                        parserInput.forget();\n                    }\n                    if (lookups.length > 0) {\n                        return lookups;\n                    }\n                },\n    \n                lookupValue: function() {\n                    parserInput.save();\n    \n                    if (!parserInput.$char('[')) { \n                        parserInput.restore();\n                        return;\n                    }\n    \n                    const name = parserInput.$re(/^(?:[@$]{0,2})[_a-zA-Z0-9-]*/);\n    \n                    if (!parserInput.$char(']')) {\n                        parserInput.restore();\n                        return;\n                    } \n\n                    if (name || name === '') {\n                        parserInput.forget();\n                        return name;\n                    }\n    \n                    parserInput.restore();\n                }\n            },\n            //\n            // Entities are the smallest recognized token,\n            // and can be found inside a rule's value.\n            //\n            entity: function () {\n                const entities = this.entities;\n\n                return this.comment() || entities.literal() || entities.variable() || entities.url() ||\n                    entities.property() || entities.call() || entities.keyword() || this.mixin.call(true) ||\n                    entities.javascript();\n            },\n\n            //\n            // A Declaration terminator. Note that we use `peek()` to check for '}',\n            // because the `block` rule will be expecting it, but we still need to make sure\n            // it's there, if ';' was omitted.\n            //\n            end: function () {\n                return parserInput.$char(';') || parserInput.peek('}');\n            },\n\n            //\n            // IE's alpha function\n            //\n            //     alpha(opacity=88)\n            //\n            ieAlpha: function () {\n                let value;\n\n                // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\n                if (!parserInput.$re(/^opacity=/i)) { return; }\n                value = parserInput.$re(/^\\d+/);\n                if (!value) {\n                    value = expect(parsers.entities.variable, 'Could not parse alpha');\n                    value = `@{${value.name.slice(1)}}`;\n                }\n                expectChar(')');\n                return new tree.Quoted('', `alpha(opacity=${value})`);\n            },\n\n            //\n            // A Selector Element\n            //\n            //     div\n            //     + h1\n            //     #socks\n            //     input[type=\"text\"]\n            //\n            // Elements are the building blocks for Selectors,\n            // they are made out of a `Combinator` (see combinator rule),\n            // and an element name, such as a tag a class, or `*`.\n            //\n            element: function () {\n                let e;\n                let c;\n                let v;\n                const index = parserInput.i;\n\n                c = this.combinator();\n\n                e = parserInput.$re(/^(?:\\d+\\.\\d+|\\d+)%/) ||\n                    parserInput.$re(/^(?:[.#]?|:*)(?:[\\w-]|[^\\x00-\\x9f]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) ||\n                    parserInput.$char('*') || parserInput.$char('&') || this.attribute() ||\n                    parserInput.$re(/^\\([^&()@]+\\)/) ||  parserInput.$re(/^[\\.#:](?=@)/) ||\n                    this.entities.variableCurly();\n\n                if (!e) {\n                    parserInput.save();\n                    if (parserInput.$char('(')) {\n                        if ((v = this.selector(false)) && parserInput.$char(')')) {\n                            e = new(tree.Paren)(v);\n                            parserInput.forget();\n                        } else {\n                            parserInput.restore('Missing closing \\')\\'');\n                        }\n                    } else {\n                        parserInput.forget();\n                    }\n                }\n\n                if (e) { return new(tree.Element)(c, e, e instanceof tree.Variable, index, fileInfo); }\n            },\n\n            //\n            // Combinators combine elements together, in a Selector.\n            //\n            // Because our parser isn't white-space sensitive, special care\n            // has to be taken, when parsing the descendant combinator, ` `,\n            // as it's an empty space. We have to check the previous character\n            // in the input, to see if it's a ` ` character. More info on how\n            // we deal with this in *combinator.js*.\n            //\n            combinator: function () {\n                let c = parserInput.currentChar();\n\n                if (c === '/') {\n                    parserInput.save();\n                    const slashedCombinator = parserInput.$re(/^\\/[a-z]+\\//i);\n                    if (slashedCombinator) {\n                        parserInput.forget();\n                        return new(tree.Combinator)(slashedCombinator);\n                    }\n                    parserInput.restore();\n                }\n\n                if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {\n                    parserInput.i++;\n                    if (c === '^' && parserInput.currentChar() === '^') {\n                        c = '^^';\n                        parserInput.i++;\n                    }\n                    while (parserInput.isWhitespace()) { parserInput.i++; }\n                    return new(tree.Combinator)(c);\n                } else if (parserInput.isWhitespace(-1)) {\n                    return new(tree.Combinator)(' ');\n                } else {\n                    return new(tree.Combinator)(null);\n                }\n            },\n            //\n            // A CSS Selector\n            // with less extensions e.g. the ability to extend and guard\n            //\n            //     .class > div + h1\n            //     li a:hover\n            //\n            // Selectors are made out of one or more Elements, see above.\n            //\n            selector: function (isLess) {\n                const index = parserInput.i;\n                let elements;\n                let extendList;\n                let c;\n                let e;\n                let allExtends;\n                let when;\n                let condition;\n                isLess = isLess !== false;\n                while ((isLess && (extendList = this.extend())) || (isLess && (when = parserInput.$str('when'))) || (e = this.element())) {\n                    if (when) {\n                        condition = expect(this.conditions, 'expected condition');\n                    } else if (condition) {\n                        error('CSS guard can only be used at the end of selector');\n                    } else if (extendList) {\n                        if (allExtends) {\n                            allExtends = allExtends.concat(extendList);\n                        } else {\n                            allExtends = extendList;\n                        }\n                    } else {\n                        if (allExtends) { error('Extend can only be used at the end of selector'); }\n                        c = parserInput.currentChar();\n                        if (elements) {\n                            elements.push(e);\n                        } else {\n                            elements = [ e ];\n                        }\n                        e = null;\n                    }\n                    if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {\n                        break;\n                    }\n                }\n\n                if (elements) { return new(tree.Selector)(elements, allExtends, condition, index, fileInfo); }\n                if (allExtends) { error('Extend must be used to extend a selector, it cannot be used on its own'); }\n            },\n            selectors: function () {\n                let s;\n                let selectors;\n                while (true) {\n                    s = this.selector();\n                    if (!s) {\n                        break;\n                    }\n                    if (selectors) {\n                        selectors.push(s);\n                    } else {\n                        selectors = [ s ];\n                    }\n                    parserInput.commentStore.length = 0;\n                    if (s.condition && selectors.length > 1) {\n                        error(\"Guards are only currently allowed on a single selector.\");\n                    }\n                    if (!parserInput.$char(',')) { break; }\n                    if (s.condition) {\n                        error(\"Guards are only currently allowed on a single selector.\");\n                    }\n                    parserInput.commentStore.length = 0;\n                }\n                return selectors;\n            },\n            attribute: function () {\n                if (!parserInput.$char('[')) { return; }\n\n                const entities = this.entities;\n                let key;\n                let val;\n                let op;\n\n                if (!(key = entities.variableCurly())) {\n                    key = expect(/^(?:[_A-Za-z0-9-\\*]*\\|)?(?:[_A-Za-z0-9-]|\\\\.)+/);\n                }\n\n                op = parserInput.$re(/^[|~*$^]?=/);\n                if (op) {\n                    val = entities.quoted() || parserInput.$re(/^[0-9]+%/) || parserInput.$re(/^[\\w-]+/) || entities.variableCurly();\n                }\n\n                expectChar(']');\n\n                return new(tree.Attribute)(key, op, val);\n            },\n\n            //\n            // The `block` rule is used by `ruleset` and `mixin.definition`.\n            // It's a wrapper around the `primary` rule, with added `{}`.\n            //\n            block: function () {\n                let content;\n                if (parserInput.$char('{') && (content = this.primary()) && parserInput.$char('}')) {\n                    return content;\n                }\n            },\n\n            blockRuleset: function() {\n                let block = this.block();\n\n                if (block) {\n                    block = new tree.Ruleset(null, block);\n                }\n                return block;\n            },\n\n            detachedRuleset: function() {\n                let argInfo;\n                let params;\n                let variadic;\n\n                parserInput.save();\n                if (parserInput.$re(/^[.#]\\(/)) {\n                    /**\n                     * DR args currently only implemented for each() function, and not \n                     * yet settable as `@dr: #(@arg) {}`\n                     * This should be done when DRs are merged with mixins.\n                     * See: https://github.com/less/less-meta/issues/16\n                     */\n                    argInfo = this.mixin.args(false);\n                    params = argInfo.args;\n                    variadic = argInfo.variadic;\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore();\n                        return;\n                    }\n                }\n                const blockRuleset = this.blockRuleset();\n                if (blockRuleset) {\n                    parserInput.forget();\n                    if (params) {\n                        return new tree.mixin.Definition(null, params, blockRuleset, null, variadic);\n                    }\n                    return new tree.DetachedRuleset(blockRuleset);\n                }\n                parserInput.restore();\n            },\n\n            //\n            // div, .class, body > p {...}\n            //\n            ruleset: function () {\n                let selectors;\n                let rules;\n                let debugInfo;\n\n                parserInput.save();\n\n                if (context.dumpLineNumbers) {\n                    debugInfo = getDebugInfo(parserInput.i);\n                }\n\n                selectors = this.selectors();\n\n                if (selectors && (rules = this.block())) {\n                    parserInput.forget();\n                    const ruleset = new(tree.Ruleset)(selectors, rules, context.strictImports);\n                    if (context.dumpLineNumbers) {\n                        ruleset.debugInfo = debugInfo;\n                    }\n                    return ruleset;\n                } else {\n                    parserInput.restore();\n                }\n            },\n            declaration: function () {\n                let name;\n                let value;\n                const index = parserInput.i;\n                let hasDR;\n                const c = parserInput.currentChar();\n                let important;\n                let merge;\n                let isVariable;\n\n                if (c === '.' || c === '#' || c === '&' || c === ':') { return; }\n\n                parserInput.save();\n\n                name = this.variable() || this.ruleProperty();\n                if (name) {\n                    isVariable = typeof name === 'string';\n\n                    if (isVariable) {\n                        value = this.detachedRuleset();\n                        if (value) {\n                            hasDR = true;\n                        }\n                    }\n\n                    parserInput.commentStore.length = 0;\n                    if (!value) {\n                        // a name returned by this.ruleProperty() is always an array of the form:\n                        // [string-1, ..., string-n, \"\"] or [string-1, ..., string-n, \"+\"]\n                        // where each item is a tree.Keyword or tree.Variable\n                        merge = !isVariable && name.length > 1 && name.pop().value;\n\n                        // Custom property values get permissive parsing\n                        if (name[0].value && name[0].value.slice(0, 2) === '--') {\n                            value = this.permissiveValue();\n                        }\n                        // Try to store values as anonymous\n                        // If we need the value later we'll re-parse it in ruleset.parseValue\n                        else {\n                            value = this.anonymousValue();\n                        }\n                        if (value) {\n                            parserInput.forget();\n                            // anonymous values absorb the end ';' which is required for them to work\n                            return new(tree.Declaration)(name, value, false, merge, index, fileInfo);\n                        }\n\n                        if (!value) {\n                            value = this.value();\n                        }\n\n                        if (value) {\n                            important = this.important();\n                        } else if (isVariable) {\n                            // As a last resort, try permissiveValue\n                            value = this.permissiveValue();\n                        }\n                    }\n\n                    if (value && (this.end() || hasDR)) {\n                        parserInput.forget();\n                        return new(tree.Declaration)(name, value, important, merge, index, fileInfo);\n                    }\n                    else {\n                        parserInput.restore();\n                    }\n                } else {\n                    parserInput.restore();\n                }\n            },\n            anonymousValue: function () {\n                const index = parserInput.i;\n                const match = parserInput.$re(/^([^.#@\\$+\\/'\"*`(;{}-]*);/);\n                if (match) {\n                    return new(tree.Anonymous)(match[1], index);\n                }\n            },\n            /**\n             * Used for custom properties, at-rules, and variables (as fallback)\n             * Parses almost anything inside of {} [] () \"\" blocks\n             * until it reaches outer-most tokens.\n             * \n             * First, it will try to parse comments and entities to reach\n             * the end. This is mostly like the Expression parser except no\n             * math is allowed.\n             */\n            permissiveValue: function (untilTokens) {\n                let i;\n                let e;\n                let done;\n                let value;\n                const tok = untilTokens || ';';\n                const index = parserInput.i;\n                const result = [];\n\n                function testCurrentChar() {\n                    const char = parserInput.currentChar();\n                    if (typeof tok === 'string') {\n                        return char === tok;\n                    } else {\n                        return tok.test(char);\n                    }\n                }\n                if (testCurrentChar()) {\n                    return;\n                }\n                value = [];\n                do {\n                    e = this.comment();\n                    if (e) {\n                        value.push(e);\n                        continue;\n                    }\n                    e = this.entity();\n                    if (e) {\n                        value.push(e);\n                    }\n                } while (e);\n\n                done = testCurrentChar();\n\n                if (value.length > 0) {\n                    value = new(tree.Expression)(value);\n                    if (done) {\n                        return value;\n                    }\n                    else {\n                        result.push(value);\n                    }\n                    // Preserve space before $parseUntil as it will not\n                    if (parserInput.prevChar() === ' ') {\n                        result.push(new tree.Anonymous(' ', index));\n                    }\n                }\n                parserInput.save();\n\n                value = parserInput.$parseUntil(tok);\n\n                if (value) {\n                    if (typeof value === 'string') {\n                        error(`Expected '${value}'`, 'Parse');\n                    }\n                    if (value.length === 1 && value[0] === ' ') {\n                        parserInput.forget();\n                        return new tree.Anonymous('', index);\n                    }\n                    let item;\n                    for (i = 0; i < value.length; i++) {\n                        item = value[i];\n                        if (Array.isArray(item)) {\n                            // Treat actual quotes as normal quoted values\n                            result.push(new tree.Quoted(item[0], item[1], true, index, fileInfo));\n                        }\n                        else {\n                            if (i === value.length - 1) {\n                                item = item.trim();\n                            }\n                            // Treat like quoted values, but replace vars like unquoted expressions\n                            const quote = new tree.Quoted('\\'', item, true, index, fileInfo);\n                            quote.variableRegex = /@([\\w-]+)/g;\n                            quote.propRegex = /\\$([\\w-]+)/g;\n                            result.push(quote);\n                        }\n                    }\n                    parserInput.forget();\n                    return new tree.Expression(result, true);\n                }\n                parserInput.restore();\n            },\n\n            //\n            // An @import atrule\n            //\n            //     @import \"lib\";\n            //\n            // Depending on our environment, importing is done differently:\n            // In the browser, it's an XHR request, in Node, it would be a\n            // file-system operation. The function used for importing is\n            // stored in `import`, which we pass to the Import constructor.\n            //\n            'import': function () {\n                let path;\n                let features;\n                const index = parserInput.i;\n\n                const dir = parserInput.$re(/^@import?\\s+/);\n\n                if (dir) {\n                    const options = (dir ? this.importOptions() : null) || {};\n\n                    if ((path = this.entities.quoted() || this.entities.url())) {\n                        features = this.mediaFeatures();\n\n                        if (!parserInput.$char(';')) {\n                            parserInput.i = index;\n                            error('missing semi-colon or unrecognised media features on import');\n                        }\n                        features = features && new(tree.Value)(features);\n                        return new(tree.Import)(path, features, options, index, fileInfo);\n                    }\n                    else {\n                        parserInput.i = index;\n                        error('malformed import statement');\n                    }\n                }\n            },\n\n            importOptions: function() {\n                let o;\n                const options = {};\n                let optionName;\n                let value;\n\n                // list of options, surrounded by parens\n                if (!parserInput.$char('(')) { return null; }\n                do {\n                    o = this.importOption();\n                    if (o) {\n                        optionName = o;\n                        value = true;\n                        switch (optionName) {\n                            case 'css':\n                                optionName = 'less';\n                                value = false;\n                                break;\n                            case 'once':\n                                optionName = 'multiple';\n                                value = false;\n                                break;\n                        }\n                        options[optionName] = value;\n                        if (!parserInput.$char(',')) { break; }\n                    }\n                } while (o);\n                expectChar(')');\n                return options;\n            },\n\n            importOption: function() {\n                const opt = parserInput.$re(/^(less|css|multiple|once|inline|reference|optional)/);\n                if (opt) {\n                    return opt[1];\n                }\n            },\n\n            mediaFeature: function () {\n                const entities = this.entities;\n                const nodes = [];\n                let e;\n                let p;\n                parserInput.save();\n                do {\n                    e = entities.keyword() || entities.variable() || entities.mixinLookup();\n                    if (e) {\n                        nodes.push(e);\n                    } else if (parserInput.$char('(')) {\n                        p = this.property();\n                        e = this.value();\n                        if (parserInput.$char(')')) {\n                            if (p && e) {\n                                nodes.push(new(tree.Paren)(new(tree.Declaration)(p, e, null, null, parserInput.i, fileInfo, true)));\n                            } else if (e) {\n                                nodes.push(new(tree.Paren)(e));\n                            } else {\n                                error('badly formed media feature definition');\n                            }\n                        } else {\n                            error('Missing closing \\')\\'', 'Parse');\n                        }\n                    }\n                } while (e);\n\n                parserInput.forget();\n                if (nodes.length > 0) {\n                    return new(tree.Expression)(nodes);\n                }\n            },\n\n            mediaFeatures: function () {\n                const entities = this.entities;\n                const features = [];\n                let e;\n                do {\n                    e = this.mediaFeature();\n                    if (e) {\n                        features.push(e);\n                        if (!parserInput.$char(',')) { break; }\n                    } else {\n                        e = entities.variable() || entities.mixinLookup();\n                        if (e) {\n                            features.push(e);\n                            if (!parserInput.$char(',')) { break; }\n                        }\n                    }\n                } while (e);\n\n                return features.length > 0 ? features : null;\n            },\n\n            media: function () {\n                let features;\n                let rules;\n                let media;\n                let debugInfo;\n                const index = parserInput.i;\n\n                if (context.dumpLineNumbers) {\n                    debugInfo = getDebugInfo(index);\n                }\n\n                parserInput.save();\n\n                if (parserInput.$str('@media')) {\n                    features = this.mediaFeatures();\n\n                    rules = this.block();\n\n                    if (!rules) {\n                        error('media definitions require block statements after any features');\n                    }\n\n                    parserInput.forget();\n\n                    media = new(tree.Media)(rules, features, index, fileInfo);\n                    if (context.dumpLineNumbers) {\n                        media.debugInfo = debugInfo;\n                    }\n\n                    return media;\n                }\n\n                parserInput.restore();\n            },\n\n            //\n\n            // A @plugin directive, used to import plugins dynamically.\n            //\n            //     @plugin (args) \"lib\";\n            //\n            plugin: function () {\n                let path;\n                let args;\n                let options;\n                const index = parserInput.i;\n                const dir   = parserInput.$re(/^@plugin?\\s+/);\n\n                if (dir) {\n                    args = this.pluginArgs();\n\n                    if (args) {\n                        options = {\n                            pluginArgs: args,\n                            isPlugin: true\n                        };\n                    }\n                    else {\n                        options = { isPlugin: true };\n                    }\n\n                    if ((path = this.entities.quoted() || this.entities.url())) {\n\n                        if (!parserInput.$char(';')) {\n                            parserInput.i = index;\n                            error('missing semi-colon on @plugin');\n                        }\n                        return new(tree.Import)(path, null, options, index, fileInfo);\n                    }\n                    else {\n                        parserInput.i = index;\n                        error('malformed @plugin statement');\n                    }\n                }\n            },\n\n            pluginArgs: function() {\n                // list of options, surrounded by parens\n                parserInput.save();\n                if (!parserInput.$char('(')) {\n                    parserInput.restore();\n                    return null;\n                }\n                const args = parserInput.$re(/^\\s*([^\\);]+)\\)\\s*/);\n                if (args[1]) {\n                    parserInput.forget();\n                    return args[1].trim();\n                }\n                else { \n                    parserInput.restore();\n                    return null;\n                }\n            },\n\n            //\n            // A CSS AtRule\n            //\n            //     @charset \"utf-8\";\n            //\n            atrule: function () {\n                const index = parserInput.i;\n                let name;\n                let value;\n                let rules;\n                let nonVendorSpecificName;\n                let hasIdentifier;\n                let hasExpression;\n                let hasUnknown;\n                let hasBlock = true;\n                let isRooted = true;\n\n                if (parserInput.currentChar() !== '@') { return; }\n\n                value = this['import']() || this.plugin() || this.media();\n                if (value) {\n                    return value;\n                }\n\n                parserInput.save();\n\n                name = parserInput.$re(/^@[a-z-]+/);\n\n                if (!name) { return; }\n\n                nonVendorSpecificName = name;\n                if (name.charAt(1) == '-' && name.indexOf('-', 2) > 0) {\n                    nonVendorSpecificName = `@${name.slice(name.indexOf('-', 2) + 1)}`;\n                }\n\n                switch (nonVendorSpecificName) {\n                    case '@charset':\n                        hasIdentifier = true;\n                        hasBlock = false;\n                        break;\n                    case '@namespace':\n                        hasExpression = true;\n                        hasBlock = false;\n                        break;\n                    case '@keyframes':\n                    case '@counter-style':\n                        hasIdentifier = true;\n                        break;\n                    case '@document':\n                    case '@supports':\n                        hasUnknown = true;\n                        isRooted = false;\n                        break;\n                    default:\n                        hasUnknown = true;\n                        break;\n                }\n\n                parserInput.commentStore.length = 0;\n\n                if (hasIdentifier) {\n                    value = this.entity();\n                    if (!value) {\n                        error(`expected ${name} identifier`);\n                    }\n                } else if (hasExpression) {\n                    value = this.expression();\n                    if (!value) {\n                        error(`expected ${name} expression`);\n                    }\n                } else if (hasUnknown) {\n                    value = this.permissiveValue(/^[{;]/);\n                    hasBlock = (parserInput.currentChar() === '{');\n                    if (!value) {\n                        if (!hasBlock && parserInput.currentChar() !== ';') {\n                            error(`${name} rule is missing block or ending semi-colon`);\n                        }\n                    }\n                    else if (!value.value) {\n                        value = null;\n                    }\n                }\n\n                if (hasBlock) {\n                    rules = this.blockRuleset();\n                }\n\n                if (rules || (!hasBlock && value && parserInput.$char(';'))) {\n                    parserInput.forget();\n                    return new(tree.AtRule)(name, value, rules, index, fileInfo,\n                        context.dumpLineNumbers ? getDebugInfo(index) : null,\n                        isRooted\n                    );\n                }\n\n                parserInput.restore('at-rule options not recognised');\n            },\n\n            //\n            // A Value is a comma-delimited list of Expressions\n            //\n            //     font-family: Baskerville, Georgia, serif;\n            //\n            // In a Rule, a Value represents everything after the `:`,\n            // and before the `;`.\n            //\n            value: function () {\n                let e;\n                const expressions = [];\n                const index = parserInput.i;\n\n                do {\n                    e = this.expression();\n                    if (e) {\n                        expressions.push(e);\n                        if (!parserInput.$char(',')) { break; }\n                    }\n                } while (e);\n\n                if (expressions.length > 0) {\n                    return new(tree.Value)(expressions, index);\n                }\n            },\n            important: function () {\n                if (parserInput.currentChar() === '!') {\n                    return parserInput.$re(/^! *important/);\n                }\n            },\n            sub: function () {\n                let a;\n                let e;\n\n                parserInput.save();\n                if (parserInput.$char('(')) {\n                    a = this.addition();\n                    if (a && parserInput.$char(')')) {\n                        parserInput.forget();\n                        e = new(tree.Expression)([a]);\n                        e.parens = true;\n                        return e;\n                    }\n                    parserInput.restore('Expected \\')\\'');\n                    return;\n                }\n                parserInput.restore();\n            },\n            multiplication: function () {\n                let m;\n                let a;\n                let op;\n                let operation;\n                let isSpaced;\n                m = this.operand();\n                if (m) {\n                    isSpaced = parserInput.isWhitespace(-1);\n                    while (true) {\n                        if (parserInput.peek(/^\\/[*\\/]/)) {\n                            break;\n                        }\n\n                        parserInput.save();\n\n                        op = parserInput.$char('/') || parserInput.$char('*') || parserInput.$str('./');\n\n                        if (!op) { parserInput.forget(); break; }\n\n                        a = this.operand();\n\n                        if (!a) { parserInput.restore(); break; }\n                        parserInput.forget();\n\n                        m.parensInOp = true;\n                        a.parensInOp = true;\n                        operation = new(tree.Operation)(op, [operation || m, a], isSpaced);\n                        isSpaced = parserInput.isWhitespace(-1);\n                    }\n                    return operation || m;\n                }\n            },\n            addition: function () {\n                let m;\n                let a;\n                let op;\n                let operation;\n                let isSpaced;\n                m = this.multiplication();\n                if (m) {\n                    isSpaced = parserInput.isWhitespace(-1);\n                    while (true) {\n                        op = parserInput.$re(/^[-+]\\s+/) || (!isSpaced && (parserInput.$char('+') || parserInput.$char('-')));\n                        if (!op) {\n                            break;\n                        }\n                        a = this.multiplication();\n                        if (!a) {\n                            break;\n                        }\n\n                        m.parensInOp = true;\n                        a.parensInOp = true;\n                        operation = new(tree.Operation)(op, [operation || m, a], isSpaced);\n                        isSpaced = parserInput.isWhitespace(-1);\n                    }\n                    return operation || m;\n                }\n            },\n            conditions: function () {\n                let a;\n                let b;\n                const index = parserInput.i;\n                let condition;\n\n                a = this.condition(true);\n                if (a) {\n                    while (true) {\n                        if (!parserInput.peek(/^,\\s*(not\\s*)?\\(/) || !parserInput.$char(',')) {\n                            break;\n                        }\n                        b = this.condition(true);\n                        if (!b) {\n                            break;\n                        }\n                        condition = new(tree.Condition)('or', condition || a, b, index);\n                    }\n                    return condition || a;\n                }\n            },\n            condition: function (needsParens) {\n                let result;\n                let logical;\n                let next;\n                function or() {\n                    return parserInput.$str('or');\n                }\n\n                result = this.conditionAnd(needsParens);\n                if (!result) {\n                    return ;\n                }\n                logical = or();\n                if (logical) {\n                    next = this.condition(needsParens);\n                    if (next) {\n                        result = new(tree.Condition)(logical, result, next);\n                    } else {\n                        return ;\n                    }\n                }\n                return result;\n            },\n            conditionAnd: function (needsParens) {\n                let result;\n                let logical;\n                let next;\n                const self = this;\n                function insideCondition() {\n                    const cond = self.negatedCondition(needsParens) || self.parenthesisCondition(needsParens);\n                    if (!cond && !needsParens) {\n                        return self.atomicCondition(needsParens);\n                    }\n                    return cond;\n                }\n                function and() {\n                    return parserInput.$str('and');\n                }\n\n                result = insideCondition();\n                if (!result) {\n                    return ;\n                }\n                logical = and();\n                if (logical) {\n                    next = this.conditionAnd(needsParens);\n                    if (next) {\n                        result = new(tree.Condition)(logical, result, next);\n                    } else {\n                        return ;\n                    }\n                }\n                return result;\n            },\n            negatedCondition: function (needsParens) {\n                if (parserInput.$str('not')) {\n                    const result = this.parenthesisCondition(needsParens);\n                    if (result) {\n                        result.negate = !result.negate;\n                    }\n                    return result;\n                }\n            },\n            parenthesisCondition: function (needsParens) {\n                function tryConditionFollowedByParenthesis(me) {\n                    let body;\n                    parserInput.save();\n                    body = me.condition(needsParens);\n                    if (!body) {\n                        parserInput.restore();\n                        return ;\n                    }\n                    if (!parserInput.$char(')')) {\n                        parserInput.restore();\n                        return ;\n                    }\n                    parserInput.forget();\n                    return body;\n                }\n\n                let body;\n                parserInput.save();\n                if (!parserInput.$str('(')) {\n                    parserInput.restore();\n                    return ;\n                }\n                body = tryConditionFollowedByParenthesis(this);\n                if (body) {\n                    parserInput.forget();\n                    return body;\n                }\n\n                body = this.atomicCondition(needsParens);\n                if (!body) {\n                    parserInput.restore();\n                    return ;\n                }\n                if (!parserInput.$char(')')) {\n                    parserInput.restore(`expected ')' got '${parserInput.currentChar()}'`);\n                    return ;\n                }\n                parserInput.forget();\n                return body;\n            },\n            atomicCondition: function (needsParens) {\n                const entities = this.entities;\n                const index = parserInput.i;\n                let a;\n                let b;\n                let c;\n                let op;\n\n                function cond() {\n                    return this.addition() || entities.keyword() || entities.quoted() || entities.mixinLookup();\n                }\n                cond = cond.bind(this);\n\n                a = cond();\n                if (a) {\n                    if (parserInput.$char('>')) {\n                        if (parserInput.$char('=')) {\n                            op = '>=';\n                        } else {\n                            op = '>';\n                        }\n                    } else\n                    if (parserInput.$char('<')) {\n                        if (parserInput.$char('=')) {\n                            op = '<=';\n                        } else {\n                            op = '<';\n                        }\n                    } else\n                    if (parserInput.$char('=')) {\n                        if (parserInput.$char('>')) {\n                            op = '=>';\n                        } else if (parserInput.$char('<')) {\n                            op = '=<';\n                        } else {\n                            op = '=';\n                        }\n                    }\n                    if (op) {\n                        b = cond();\n                        if (b) {\n                            c = new(tree.Condition)(op, a, b, index, false);\n                        } else {\n                            error('expected expression');\n                        }\n                    } else {\n                        c = new(tree.Condition)('=', a, new(tree.Keyword)('true'), index, false);\n                    }\n                    return c;\n                }\n            },\n\n            //\n            // An operand is anything that can be part of an operation,\n            // such as a Color, or a Variable\n            //\n            operand: function () {\n                const entities = this.entities;\n                let negate;\n\n                if (parserInput.peek(/^-[@\\$\\(]/)) {\n                    negate = parserInput.$char('-');\n                }\n\n                let o = this.sub() || entities.dimension() ||\n                        entities.color() || entities.variable() ||\n                        entities.property() || entities.call() ||\n                        entities.quoted(true) || entities.colorKeyword() ||\n                        entities.mixinLookup();\n\n                if (negate) {\n                    o.parensInOp = true;\n                    o = new(tree.Negative)(o);\n                }\n\n                return o;\n            },\n\n            //\n            // Expressions either represent mathematical operations,\n            // or white-space delimited Entities.\n            //\n            //     1px solid black\n            //     @var * 2\n            //\n            expression: function () {\n                const entities = [];\n                let e;\n                let delim;\n                const index = parserInput.i;\n\n                do {\n                    e = this.comment();\n                    if (e) {\n                        entities.push(e);\n                        continue;\n                    }\n                    e = this.addition() || this.entity();\n                    if (e) {\n                        entities.push(e);\n                        // operations do not allow keyword \"/\" dimension (e.g. small/20px) so we support that here\n                        if (!parserInput.peek(/^\\/[\\/*]/)) {\n                            delim = parserInput.$char('/');\n                            if (delim) {\n                                entities.push(new(tree.Anonymous)(delim, index));\n                            }\n                        }\n                    }\n                } while (e);\n                if (entities.length > 0) {\n                    return new(tree.Expression)(entities);\n                }\n            },\n            property: function () {\n                const name = parserInput.$re(/^(\\*?-?[_a-zA-Z0-9-]+)\\s*:/);\n                if (name) {\n                    return name[1];\n                }\n            },\n            ruleProperty: function () {\n                let name = [];\n                const index = [];\n                let s;\n                let k;\n\n                parserInput.save();\n\n                const simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\\s*:/);\n                if (simpleProperty) {\n                    name = [new(tree.Keyword)(simpleProperty[1])];\n                    parserInput.forget();\n                    return name;\n                }\n\n                function match(re) {\n                    const i = parserInput.i;\n                    const chunk = parserInput.$re(re);\n                    if (chunk) {\n                        index.push(i);\n                        return name.push(chunk[1]);\n                    }\n                }\n\n                match(/^(\\*?)/);\n                while (true) {\n                    if (!match(/^((?:[\\w-]+)|(?:[@\\$]\\{[\\w-]+\\}))/)) {\n                        break;\n                    }\n                }\n\n                if ((name.length > 1) && match(/^((?:\\+_|\\+)?)\\s*:/)) {\n                    parserInput.forget();\n\n                    // at last, we have the complete match now. move forward,\n                    // convert name particles to tree objects and return:\n                    if (name[0] === '') {\n                        name.shift();\n                        index.shift();\n                    }\n                    for (k = 0; k < name.length; k++) {\n                        s = name[k];\n                        name[k] = (s.charAt(0) !== '@' && s.charAt(0) !== '$') ?\n                            new(tree.Keyword)(s) :\n                            (s.charAt(0) === '@' ?\n                                new(tree.Variable)(`@${s.slice(2, -1)}`, index[k], fileInfo) :\n                                new(tree.Property)(`$${s.slice(2, -1)}`, index[k], fileInfo));\n                    }\n                    return name;\n                }\n                parserInput.restore();\n            }\n        }\n    };\n};\nParser.serializeVars = vars => {\n    let s = '';\n\n    for (const name in vars) {\n        if (Object.hasOwnProperty.call(vars, name)) {\n            const value = vars[name];\n            s += `${((name[0] === '@') ? '' : '@') + name}: ${value}${(String(value).slice(-1) === ';') ? '' : ';'}`;\n        }\n    }\n\n    return s;\n};\n\nexport default Parser;\n","import Dimension from '../tree/dimension';\nimport Color from '../tree/color';\nimport Quoted from '../tree/quoted';\nimport Anonymous from '../tree/anonymous';\nlet colorFunctions;\n\nfunction clamp(val) {\n    return Math.min(1, Math.max(0, val));\n}\nfunction hsla(origColor, hsl) {\n    const color = colorFunctions.hsla(hsl.h, hsl.s, hsl.l, hsl.a);\n    if (color) {\n        if (origColor.value && \n            /^(rgb|hsl)/.test(origColor.value)) {\n            color.value = origColor.value;\n        } else {\n            color.value = 'rgb';\n        }\n        return color;\n    }\n}\nfunction toHSL(color) {\n    if (color.toHSL) {\n        return color.toHSL();\n    } else {\n        throw new Error('Argument cannot be evaluated to a color');\n    }\n}\n\nfunction toHSV(color) {\n    if (color.toHSV) {\n        return color.toHSV();\n    } else {\n        throw new Error('Argument cannot be evaluated to a color');\n    }\n}\n\nfunction number(n) {\n    if (n instanceof Dimension) {\n        return parseFloat(n.unit.is('%') ? n.value / 100 : n.value);\n    } else if (typeof n === 'number') {\n        return n;\n    } else {\n        throw {\n            type: 'Argument',\n            message: 'color functions take numbers as parameters'\n        };\n    }\n}\nfunction scaled(n, size) {\n    if (n instanceof Dimension && n.unit.is('%')) {\n        return parseFloat(n.value * size / 100);\n    } else {\n        return number(n);\n    }\n}\ncolorFunctions = {\n    rgb: function (r, g, b) {\n        const color = colorFunctions.rgba(r, g, b, 1.0);\n        if (color) {\n            color.value = 'rgb';\n            return color;\n        }\n    },\n    rgba: function (r, g, b, a) {\n        try {\n            if (r instanceof Color) {\n                if (g) {\n                    a = number(g);\n                } else {\n                    a = r.alpha;\n                }\n                return new Color(r.rgb, a, 'rgba');\n            }\n            const rgb = [r, g, b].map(c => scaled(c, 255));\n            a = number(a);\n            return new Color(rgb, a, 'rgba');\n        }\n        catch (e) {}\n    },\n    hsl: function (h, s, l) {\n        const color = colorFunctions.hsla(h, s, l, 1.0);\n        if (color) {\n            color.value = 'hsl';\n            return color;\n        }\n    },\n    hsla: function (h, s, l, a) {\n        try {\n            if (h instanceof Color) {\n                if (s) {\n                    a = number(s);\n                } else {\n                    a = h.alpha;\n                }\n                return new Color(h.rgb, a, 'hsla');\n            }\n\n            let m1;\n            let m2;\n\n            function hue(h) {\n                h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);\n                if (h * 6 < 1) {\n                    return m1 + (m2 - m1) * h * 6;\n                }\n                else if (h * 2 < 1) {\n                    return m2;\n                }\n                else if (h * 3 < 2) {\n                    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n                }\n                else {\n                    return m1;\n                }\n            }\n\n            h = (number(h) % 360) / 360;\n            s = clamp(number(s));l = clamp(number(l));a = clamp(number(a));\n\n            m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n            m1 = l * 2 - m2;\n\n            const rgb = [\n                hue(h + 1 / 3) * 255,\n                hue(h)       * 255,\n                hue(h - 1 / 3) * 255\n            ];\n            a = number(a);\n            return new Color(rgb, a, 'hsla');\n        }\n        catch (e) {}\n    },\n\n    hsv: function(h, s, v) {\n        return colorFunctions.hsva(h, s, v, 1.0);\n    },\n\n    hsva: function(h, s, v, a) {\n        h = ((number(h) % 360) / 360) * 360;\n        s = number(s);v = number(v);a = number(a);\n\n        let i;\n        let f;\n        i = Math.floor((h / 60) % 6);\n        f = (h / 60) - i;\n\n        const vs = [v,\n            v * (1 - s),\n            v * (1 - f * s),\n            v * (1 - (1 - f) * s)];\n        const perm = [[0, 3, 1],\n            [2, 0, 1],\n            [1, 0, 3],\n            [1, 2, 0],\n            [3, 1, 0],\n            [0, 1, 2]];\n\n        return colorFunctions.rgba(vs[perm[i][0]] * 255,\n            vs[perm[i][1]] * 255,\n            vs[perm[i][2]] * 255,\n            a);\n    },\n\n    hue: function (color) {\n        return new Dimension(toHSL(color).h);\n    },\n    saturation: function (color) {\n        return new Dimension(toHSL(color).s * 100, '%');\n    },\n    lightness: function (color) {\n        return new Dimension(toHSL(color).l * 100, '%');\n    },\n    hsvhue: function(color) {\n        return new Dimension(toHSV(color).h);\n    },\n    hsvsaturation: function (color) {\n        return new Dimension(toHSV(color).s * 100, '%');\n    },\n    hsvvalue: function (color) {\n        return new Dimension(toHSV(color).v * 100, '%');\n    },\n    red: function (color) {\n        return new Dimension(color.rgb[0]);\n    },\n    green: function (color) {\n        return new Dimension(color.rgb[1]);\n    },\n    blue: function (color) {\n        return new Dimension(color.rgb[2]);\n    },\n    alpha: function (color) {\n        return new Dimension(toHSL(color).a);\n    },\n    luma: function (color) {\n        return new Dimension(color.luma() * color.alpha * 100, '%');\n    },\n    luminance: function (color) {\n        const luminance =\n            (0.2126 * color.rgb[0] / 255) +\n                (0.7152 * color.rgb[1] / 255) +\n                (0.0722 * color.rgb[2] / 255);\n\n        return new Dimension(luminance * color.alpha * 100, '%');\n    },\n    saturate: function (color, amount, method) {\n        // filter: saturate(3.2);\n        // should be kept as is, so check for color\n        if (!color.rgb) {\n            return null;\n        }\n        const hsl = toHSL(color);\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.s +=  hsl.s * amount.value / 100;\n        }\n        else {\n            hsl.s += amount.value / 100;\n        }\n        hsl.s = clamp(hsl.s);\n        return hsla(color, hsl);\n    },\n    desaturate: function (color, amount, method) {\n        const hsl = toHSL(color);\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.s -=  hsl.s * amount.value / 100;\n        }\n        else {\n            hsl.s -= amount.value / 100;\n        }\n        hsl.s = clamp(hsl.s);\n        return hsla(color, hsl);\n    },\n    lighten: function (color, amount, method) {\n        const hsl = toHSL(color);\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.l +=  hsl.l * amount.value / 100;\n        }\n        else {\n            hsl.l += amount.value / 100;\n        }\n        hsl.l = clamp(hsl.l);\n        return hsla(color, hsl);\n    },\n    darken: function (color, amount, method) {\n        const hsl = toHSL(color);\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.l -=  hsl.l * amount.value / 100;\n        }\n        else {\n            hsl.l -= amount.value / 100;\n        }\n        hsl.l = clamp(hsl.l);\n        return hsla(color, hsl);\n    },\n    fadein: function (color, amount, method) {\n        const hsl = toHSL(color);\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.a +=  hsl.a * amount.value / 100;\n        }\n        else {\n            hsl.a += amount.value / 100;\n        }\n        hsl.a = clamp(hsl.a);\n        return hsla(color, hsl);\n    },\n    fadeout: function (color, amount, method) {\n        const hsl = toHSL(color);\n\n        if (typeof method !== 'undefined' && method.value === 'relative') {\n            hsl.a -=  hsl.a * amount.value / 100;\n        }\n        else {\n            hsl.a -= amount.value / 100;\n        }\n        hsl.a = clamp(hsl.a);\n        return hsla(color, hsl);\n    },\n    fade: function (color, amount) {\n        const hsl = toHSL(color);\n\n        hsl.a = amount.value / 100;\n        hsl.a = clamp(hsl.a);\n        return hsla(color, hsl);\n    },\n    spin: function (color, amount) {\n        const hsl = toHSL(color);\n        const hue = (hsl.h + amount.value) % 360;\n\n        hsl.h = hue < 0 ? 360 + hue : hue;\n\n        return hsla(color, hsl);\n    },\n    //\n    // Copyright (c) 2006-2009 Hampton Catlin, Natalie Weizenbaum, and Chris Eppstein\n    // http://sass-lang.com\n    //\n    mix: function (color1, color2, weight) {\n        if (!weight) {\n            weight = new Dimension(50);\n        }\n        const p = weight.value / 100.0;\n        const w = p * 2 - 1;\n        const a = toHSL(color1).a - toHSL(color2).a;\n\n        const w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n        const w2 = 1 - w1;\n\n        const rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,\n            color1.rgb[1] * w1 + color2.rgb[1] * w2,\n            color1.rgb[2] * w1 + color2.rgb[2] * w2];\n\n        const alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n        return new Color(rgb, alpha);\n    },\n    greyscale: function (color) {\n        return colorFunctions.desaturate(color, new Dimension(100));\n    },\n    contrast: function (color, dark, light, threshold) {\n        // filter: contrast(3.2);\n        // should be kept as is, so check for color\n        if (!color.rgb) {\n            return null;\n        }\n        if (typeof light === 'undefined') {\n            light = colorFunctions.rgba(255, 255, 255, 1.0);\n        }\n        if (typeof dark === 'undefined') {\n            dark = colorFunctions.rgba(0, 0, 0, 1.0);\n        }\n        // Figure out which is actually light and dark:\n        if (dark.luma() > light.luma()) {\n            const t = light;\n            light = dark;\n            dark = t;\n        }\n        if (typeof threshold === 'undefined') {\n            threshold = 0.43;\n        } else {\n            threshold = number(threshold);\n        }\n        if (color.luma() < threshold) {\n            return light;\n        } else {\n            return dark;\n        }\n    },\n    // Changes made in 2.7.0 - Reverted in 3.0.0\n    // contrast: function (color, color1, color2, threshold) {\n    //     // Return which of `color1` and `color2` has the greatest contrast with `color`\n    //     // according to the standard WCAG contrast ratio calculation.\n    //     // http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n    //     // The threshold param is no longer used, in line with SASS.\n    //     // filter: contrast(3.2);\n    //     // should be kept as is, so check for color\n    //     if (!color.rgb) {\n    //         return null;\n    //     }\n    //     if (typeof color1 === 'undefined') {\n    //         color1 = colorFunctions.rgba(0, 0, 0, 1.0);\n    //     }\n    //     if (typeof color2 === 'undefined') {\n    //         color2 = colorFunctions.rgba(255, 255, 255, 1.0);\n    //     }\n    //     var contrast1, contrast2;\n    //     var luma = color.luma();\n    //     var luma1 = color1.luma();\n    //     var luma2 = color2.luma();\n    //     // Calculate contrast ratios for each color\n    //     if (luma > luma1) {\n    //         contrast1 = (luma + 0.05) / (luma1 + 0.05);\n    //     } else {\n    //         contrast1 = (luma1 + 0.05) / (luma + 0.05);\n    //     }\n    //     if (luma > luma2) {\n    //         contrast2 = (luma + 0.05) / (luma2 + 0.05);\n    //     } else {\n    //         contrast2 = (luma2 + 0.05) / (luma + 0.05);\n    //     }\n    //     if (contrast1 > contrast2) {\n    //         return color1;\n    //     } else {\n    //         return color2;\n    //     }\n    // },\n    argb: function (color) {\n        return new Anonymous(color.toARGB());\n    },\n    color: function(c) {\n        if ((c instanceof Quoted) &&\n            (/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})$/i.test(c.value))) {\n            const val = c.value.slice(1);\n            return new Color(val, undefined, `#${val}`);\n        }\n        if ((c instanceof Color) || (c = Color.fromKeyword(c.value))) {\n            c.value = undefined;\n            return c;\n        }\n        throw {\n            type:    'Argument',\n            message: 'argument must be a color keyword or 3|4|6|8 digit hex e.g. #FFF'\n        };\n    },\n    tint: function(color, amount) {\n        return colorFunctions.mix(colorFunctions.rgb(255, 255, 255), color, amount);\n    },\n    shade: function(color, amount) {\n        return colorFunctions.mix(colorFunctions.rgb(0, 0, 0), color, amount);\n    }\n};\n\nexport default colorFunctions;\n","import Anonymous from '../tree/anonymous';\nimport Keyword from '../tree/keyword';\n\nfunction boolean(condition) {\n    return condition ? Keyword.True : Keyword.False;\n}\n\nfunction If(condition, trueValue, falseValue) {\n    return condition ? trueValue\n        : (falseValue || new Anonymous);\n}\n\nexport default { boolean, 'if': If };\n","import Color from '../tree/color';\n\n// Color Blending\n// ref: http://www.w3.org/TR/compositing-1\n\nfunction colorBlend(mode, color1, color2) {\n    const ab = color1.alpha;        // result\n\n    let // backdrop\n        cb;\n\n    const as = color2.alpha;\n\n    let // source\n        cs;\n\n    let ar;\n    let cr;\n    const r = [];\n\n    ar = as + ab * (1 - as);\n    for (let i = 0; i < 3; i++) {\n        cb = color1.rgb[i] / 255;\n        cs = color2.rgb[i] / 255;\n        cr = mode(cb, cs);\n        if (ar) {\n            cr = (as * cs + ab * (cb -\n                  as * (cb + cs - cr))) / ar;\n        }\n        r[i] = cr * 255;\n    }\n\n    return new Color(r, ar);\n}\n\nconst colorBlendModeFunctions = {\n    multiply: function(cb, cs) {\n        return cb * cs;\n    },\n    screen: function(cb, cs) {\n        return cb + cs - cb * cs;\n    },\n    overlay: function(cb, cs) {\n        cb *= 2;\n        return (cb <= 1) ?\n            colorBlendModeFunctions.multiply(cb, cs) :\n            colorBlendModeFunctions.screen(cb - 1, cs);\n    },\n    softlight: function(cb, cs) {\n        let d = 1;\n        let e = cb;\n        if (cs > 0.5) {\n            e = 1;\n            d = (cb > 0.25) ? Math.sqrt(cb)\n                : ((16 * cb - 12) * cb + 4) * cb;\n        }\n        return cb - (1 - 2 * cs) * e * (d - cb);\n    },\n    hardlight: function(cb, cs) {\n        return colorBlendModeFunctions.overlay(cs, cb);\n    },\n    difference: function(cb, cs) {\n        return Math.abs(cb - cs);\n    },\n    exclusion: function(cb, cs) {\n        return cb + cs - 2 * cb * cs;\n    },\n\n    // non-w3c functions:\n    average: function(cb, cs) {\n        return (cb + cs) / 2;\n    },\n    negation: function(cb, cs) {\n        return 1 - Math.abs(cb + cs - 1);\n    }\n};\n\nfor (const f in colorBlendModeFunctions) {\n    if (colorBlendModeFunctions.hasOwnProperty(f)) {\n        colorBlend[f] = colorBlend.bind(null, colorBlendModeFunctions[f]);\n    }\n}\n\nexport default colorBlend;\n","import Comment from '../tree/comment';\nimport Dimension from '../tree/dimension';\nimport Declaration from '../tree/declaration';\nimport Expression from '../tree/expression';\nimport Ruleset from '../tree/ruleset';\nimport Selector from '../tree/selector';\nimport Element from '../tree/element';\nimport Quote from '../tree/quoted';\n\nconst getItemsFromNode = node => {\n    // handle non-array values as an array of length 1\n    // return 'undefined' if index is invalid\n    const items = Array.isArray(node.value) ?\n        node.value : Array(node);\n\n    return items;\n};\n\nexport default {\n    _SELF: function(n) {\n        return n;\n    },\n    extract: function(values, index) {\n        index = index.value - 1; // (1-based index)\n\n        return getItemsFromNode(values)[index];\n    },\n    length: function(values) {\n        return new Dimension(getItemsFromNode(values).length);\n    },\n    /**\n     * Creates a Less list of incremental values.\n     * Modeled after Lodash's range function, also exists natively in PHP\n     * \n     * @param {Dimension} [start=1]\n     * @param {Dimension} end  - e.g. 10 or 10px - unit is added to output\n     * @param {Dimension} [step=1] \n     */\n    range: function(start, end, step) {\n        let from;\n        let to;\n        let stepValue = 1;\n        const list = [];\n        if (end) {\n            to = end;\n            from = start.value;\n            if (step) {\n                stepValue = step.value;\n            }\n        }\n        else {\n            from = 1;\n            to = start;\n        }\n\n        for (let i = from; i <= to.value; i += stepValue) {\n            list.push(new Dimension(i, to.unit));\n        }\n\n        return new Expression(list);\n    },\n    each: function(list, rs) {\n        const rules = [];\n        let newRules;\n        let iterator;\n\n        if (list.value && !(list instanceof Quote)) {\n            if (Array.isArray(list.value)) {\n                iterator = list.value;\n            } else {\n                iterator = [list.value];\n            }\n        } else if (list.ruleset) {\n            iterator = list.ruleset.rules;\n        } else if (list.rules) {\n            iterator = list.rules;\n        } else if (Array.isArray(list)) {\n            iterator = list;\n        } else {\n            iterator = [list];\n        }\n\n        let valueName = '@value';\n        let keyName = '@key';\n        let indexName = '@index';\n\n        if (rs.params) {\n            valueName = rs.params[0] && rs.params[0].name;\n            keyName = rs.params[1] && rs.params[1].name;\n            indexName = rs.params[2] && rs.params[2].name;\n            rs = rs.rules;\n        } else {\n            rs = rs.ruleset;\n        }\n\n        for (let i = 0; i < iterator.length; i++) {\n            let key;\n            let value;\n            const item = iterator[i];\n            if (item instanceof Declaration) {\n                key = typeof item.name === 'string' ? item.name : item.name[0].value;\n                value = item.value;\n            } else {\n                key = new Dimension(i + 1);\n                value = item;\n            }\n\n            if (item instanceof Comment) {\n                continue;\n            }\n\n            newRules = rs.rules.slice(0);\n            if (valueName) {\n                newRules.push(new Declaration(valueName,\n                    value,\n                    false, false, this.index, this.currentFileInfo));\n            }\n            if (indexName) {\n                newRules.push(new Declaration(indexName,\n                    new Dimension(i + 1),\n                    false, false, this.index, this.currentFileInfo));\n            }\n            if (keyName) {\n                newRules.push(new Declaration(keyName,\n                    key,\n                    false, false, this.index, this.currentFileInfo));\n            }\n\n            rules.push(new Ruleset([ new(Selector)([ new Element(\"\", '&') ]) ],\n                newRules,\n                rs.strictImports,\n                rs.visibilityInfo()\n            ));\n        }\n\n        return new Ruleset([ new(Selector)([ new Element(\"\", '&') ]) ],\n            rules,\n            rs.strictImports,\n            rs.visibilityInfo()\n        ).eval(this.context);\n    }\n};\n","import Dimension from '../tree/dimension';\n\nconst MathHelper = (fn, unit, n) => {\n    if (!(n instanceof Dimension)) {\n        throw { type: 'Argument', message: 'argument must be a number' };\n    }\n    if (unit == null) {\n        unit = n.unit;\n    } else {\n        n = n.unify();\n    }\n    return new Dimension(fn(parseFloat(n.value)), unit);\n};\n\nexport default MathHelper;","import mathHelper from './math-helper.js';\n\nconst mathFunctions = {\n    // name,  unit\n    ceil:  null,\n    floor: null,\n    sqrt:  null,\n    abs:   null,\n    tan:   '',\n    sin:   '',\n    cos:   '',\n    atan:  'rad',\n    asin:  'rad',\n    acos:  'rad'\n};\n\nfor (const f in mathFunctions) {\n    if (mathFunctions.hasOwnProperty(f)) {\n        mathFunctions[f] = mathHelper.bind(null, Math[f], mathFunctions[f]);\n    }\n}\n\nmathFunctions.round = (n, f) => {\n    const fraction = typeof f === 'undefined' ? 0 : f.value;\n    return mathHelper(num => num.toFixed(fraction), null, n);\n};\n\nexport default mathFunctions;\n","import Dimension from '../tree/dimension';\nimport Anonymous from '../tree/anonymous';\nimport mathHelper from './math-helper.js';\n\nconst minMax = function (isMin, args) {\n    args = Array.prototype.slice.call(args);\n    switch (args.length) {\n        case 0: throw { type: 'Argument', message: 'one or more arguments required' };\n    }\n    let i; // key is the unit.toString() for unified Dimension values,\n    let j;\n    let current;\n    let currentUnified;\n    let referenceUnified;\n    let unit;\n    let unitStatic;\n    let unitClone;\n\n    const // elems only contains original argument values.\n        order  = [];\n\n    const values = {};\n    // value is the index into the order array.\n    for (i = 0; i < args.length; i++) {\n        current = args[i];\n        if (!(current instanceof Dimension)) {\n            if (Array.isArray(args[i].value)) {\n                Array.prototype.push.apply(args, Array.prototype.slice.call(args[i].value));\n            }\n            continue;\n        }\n        currentUnified = current.unit.toString() === '' && unitClone !== undefined ? new Dimension(current.value, unitClone).unify() : current.unify();\n        unit = currentUnified.unit.toString() === '' && unitStatic !== undefined ? unitStatic : currentUnified.unit.toString();\n        unitStatic = unit !== '' && unitStatic === undefined || unit !== '' && order[0].unify().unit.toString() === '' ? unit : unitStatic;\n        unitClone = unit !== '' && unitClone === undefined ? current.unit.toString() : unitClone;\n        j = values[''] !== undefined && unit !== '' && unit === unitStatic ? values[''] : values[unit];\n        if (j === undefined) {\n            if (unitStatic !== undefined && unit !== unitStatic) {\n                throw { type: 'Argument', message: 'incompatible types' };\n            }\n            values[unit] = order.length;\n            order.push(current);\n            continue;\n        }\n        referenceUnified = order[j].unit.toString() === '' && unitClone !== undefined ? new Dimension(order[j].value, unitClone).unify() : order[j].unify();\n        if ( isMin && currentUnified.value < referenceUnified.value ||\n            !isMin && currentUnified.value > referenceUnified.value) {\n            order[j] = current;\n        }\n    }\n    if (order.length == 1) {\n        return order[0];\n    }\n    args = order.map(function (a) { return a.toCSS(this.context); }).join(this.context.compress ? ',' : ', ');\n    return new Anonymous(`${isMin ? 'min' : 'max'}(${args})`);\n};\n\nexport default {\n    min: function(...args) {\n        return minMax(true, args);\n    },\n    max: function(...args) {\n        return minMax(false, args);\n    },\n    convert: function (val, unit) {\n        return val.convertTo(unit.value);\n    },\n    pi: function () {\n        return new Dimension(Math.PI);\n    },\n    mod: function(a, b) {\n        return new Dimension(a.value % b.value, a.unit);\n    },\n    pow: function(x, y) {\n        if (typeof x === 'number' && typeof y === 'number') {\n            x = new Dimension(x);\n            y = new Dimension(y);\n        } else if (!(x instanceof Dimension) || !(y instanceof Dimension)) {\n            throw { type: 'Argument', message: 'arguments must be numbers' };\n        }\n\n        return new Dimension(Math.pow(x.value, y.value), x.unit);\n    },\n    percentage: function (n) {\n        const result = mathHelper(num => num * 100, '%', n);\n\n        return result;\n    }\n};\n","/**\n * Plugin Manager\n */\nclass PluginManager {\n    constructor(less) {\n        this.less = less;\n        this.visitors = [];\n        this.preProcessors = [];\n        this.postProcessors = [];\n        this.installedPlugins = [];\n        this.fileManagers = [];\n        this.iterator = -1;\n        this.pluginCache = {};\n        this.Loader = new less.PluginLoader(less);\n    }\n\n    /**\n     * Adds all the plugins in the array\n     * @param {Array} plugins\n     */\n    addPlugins(plugins) {\n        if (plugins) {\n            for (let i = 0; i < plugins.length; i++) {\n                this.addPlugin(plugins[i]);\n            }\n        }\n    }\n\n    /**\n     *\n     * @param plugin\n     * @param {String} filename\n     */\n    addPlugin(plugin, filename, functionRegistry) {\n        this.installedPlugins.push(plugin);\n        if (filename) {\n            this.pluginCache[filename] = plugin;\n        }\n        if (plugin.install) {\n            plugin.install(this.less, this, functionRegistry || this.less.functions.functionRegistry);\n        }\n    }\n\n    /**\n     *\n     * @param filename\n     */\n    get(filename) {\n        return this.pluginCache[filename];\n    }\n\n    /**\n     * Adds a visitor. The visitor object has options on itself to determine\n     * when it should run.\n     * @param visitor\n     */\n    addVisitor(visitor) {\n        this.visitors.push(visitor);\n    }\n\n    /**\n     * Adds a pre processor object\n     * @param {object} preProcessor\n     * @param {number} priority - guidelines 1 = before import, 1000 = import, 2000 = after import\n     */\n    addPreProcessor(preProcessor, priority) {\n        let indexToInsertAt;\n        for (indexToInsertAt = 0; indexToInsertAt < this.preProcessors.length; indexToInsertAt++) {\n            if (this.preProcessors[indexToInsertAt].priority >= priority) {\n                break;\n            }\n        }\n        this.preProcessors.splice(indexToInsertAt, 0, {preProcessor, priority});\n    }\n\n    /**\n     * Adds a post processor object\n     * @param {object} postProcessor\n     * @param {number} priority - guidelines 1 = before compression, 1000 = compression, 2000 = after compression\n     */\n    addPostProcessor(postProcessor, priority) {\n        let indexToInsertAt;\n        for (indexToInsertAt = 0; indexToInsertAt < this.postProcessors.length; indexToInsertAt++) {\n            if (this.postProcessors[indexToInsertAt].priority >= priority) {\n                break;\n            }\n        }\n        this.postProcessors.splice(indexToInsertAt, 0, {postProcessor, priority});\n    }\n\n    /**\n     *\n     * @param manager\n     */\n    addFileManager(manager) {\n        this.fileManagers.push(manager);\n    }\n\n    /**\n     *\n     * @returns {Array}\n     * @private\n     */\n    getPreProcessors() {\n        const preProcessors = [];\n        for (let i = 0; i < this.preProcessors.length; i++) {\n            preProcessors.push(this.preProcessors[i].preProcessor);\n        }\n        return preProcessors;\n    }\n\n    /**\n     *\n     * @returns {Array}\n     * @private\n     */\n    getPostProcessors() {\n        const postProcessors = [];\n        for (let i = 0; i < this.postProcessors.length; i++) {\n            postProcessors.push(this.postProcessors[i].postProcessor);\n        }\n        return postProcessors;\n    }\n\n    /**\n     *\n     * @returns {Array}\n     * @private\n     */\n    getVisitors() {\n        return this.visitors;\n    }\n\n    visitor() {\n        const self = this;\n        return {\n            first: function() {\n                self.iterator = -1;\n                return self.visitors[self.iterator];\n            },\n            get: function() {\n                self.iterator += 1;\n                return self.visitors[self.iterator];\n            }\n        };\n    }\n\n    /**\n     *\n     * @returns {Array}\n     * @private\n     */\n    getFileManagers() {\n        return this.fileManagers;\n    }\n}\n\nlet pm;\n\nfunction PluginManagerFactory(less, newFactory) {\n    if (newFactory || !pm) {\n        pm = new PluginManager(less);\n    }\n    return pm;\n};\n\n//\nexport default PluginManagerFactory;\n","import Quoted from '../tree/quoted';\nimport Anonymous from '../tree/anonymous';\nimport Quote from '../tree/quoted';\nimport JavaScript from '../tree/javascript';\n\nexport default {\n    e: function (str) {\n        return new Quote('\"', str instanceof JavaScript ? str.evaluated : str.value, true);\n    },\n    escape: function (str) {\n        return new Anonymous(\n            encodeURI(str.value).replace(/=/g, '%3D').replace(/:/g, '%3A').replace(/#/g, '%23').replace(/;/g, '%3B')\n                .replace(/\\(/g, '%28').replace(/\\)/g, '%29'));\n    },\n    replace: function (string, pattern, replacement, flags) {\n        let result = string.value;\n        replacement = (replacement.type === 'Quoted') ?\n            replacement.value : replacement.toCSS();\n        result = result.replace(new RegExp(pattern.value, flags ? flags.value : ''), replacement);\n        return new Quoted(string.quote || '', result, string.escaped);\n    },\n    '%': function (string /* arg, arg, ... */) {\n        const args = Array.prototype.slice.call(arguments, 1);\n        let result = string.value;\n\n        for (let i = 0; i < args.length; i++) {\n            /* jshint loopfunc:true */\n            result = result.replace(/%[sda]/i, token => {\n                const value = ((args[i].type === 'Quoted') &&\n                    token.match(/s/i)) ? args[i].value : args[i].toCSS();\n                return token.match(/[A-Z]$/) ? encodeURIComponent(value) : value;\n            });\n        }\n        result = result.replace(/%%/g, '%');\n        return new Quoted(string.quote || '', result, string.escaped);\n    }\n};\n","import Keyword from '../tree/keyword';\nimport DetachedRuleset from '../tree/detached-ruleset';\nimport Dimension from '../tree/dimension';\nimport Color from '../tree/color';\nimport Quoted from '../tree/quoted';\nimport Anonymous from '../tree/anonymous';\nimport URL from '../tree/url';\nimport Operation from '../tree/operation';\n\nconst isa = (n, Type) => (n instanceof Type) ? Keyword.True : Keyword.False;\nconst isunit = (n, unit) => {\n    if (unit === undefined) {\n        throw { type: 'Argument', message: 'missing the required second argument to isunit.' };\n    }\n    unit = typeof unit.value === 'string' ? unit.value : unit;\n    if (typeof unit !== 'string') {\n        throw { type: 'Argument', message: 'Second argument to isunit should be a unit or a string.' };\n    }\n    return (n instanceof Dimension) && n.unit.is(unit) ? Keyword.True : Keyword.False;\n};\n\nexport default {\n    isruleset: function (n) {\n        return isa(n, DetachedRuleset);\n    },\n    iscolor: function (n) {\n        return isa(n, Color);\n    },\n    isnumber: function (n) {\n        return isa(n, Dimension);\n    },\n    isstring: function (n) {\n        return isa(n, Quoted);\n    },\n    iskeyword: function (n) {\n        return isa(n, Keyword);\n    },\n    isurl: function (n) {\n        return isa(n, URL);\n    },\n    ispixel: function (n) {\n        return isunit(n, 'px');\n    },\n    ispercentage: function (n) {\n        return isunit(n, '%');\n    },\n    isem: function (n) {\n        return isunit(n, 'em');\n    },\n    isunit,\n    unit: function (val, unit) {\n        if (!(val instanceof Dimension)) {\n            throw { type: 'Argument',\n                message: `the first argument to unit must be a number${val instanceof Operation ? '. Have you forgotten parenthesis?' : ''}` };\n        }\n        if (unit) {\n            if (unit instanceof Keyword) {\n                unit = unit.value;\n            } else {\n                unit = unit.toCSS();\n            }\n        } else {\n            unit = '';\n        }\n        return new Dimension(val.value, unit);\n    },\n    'get-unit': function (n) {\n        return new Anonymous(n.unit);\n    }\n};\n","import functionRegistry from './function-registry';\nimport functionCaller from './function-caller';\n\nimport boolean from './boolean';\nimport defaultFunc from './default';\nimport color from './color';\nimport colorBlending from './color-blending';\nimport dataUri from './data-uri';\nimport list from './list';\nimport math from './math';\nimport number from './number';\nimport string from './string';\nimport svg from './svg';\nimport types from './types';\n\nexport default environment => {\n    const functions = { functionRegistry, functionCaller };\n\n    // register functions\n    functionRegistry.addMultiple(boolean);\n    functionRegistry.add('default', defaultFunc.eval.bind(defaultFunc));\n    functionRegistry.addMultiple(color);\n    functionRegistry.addMultiple(colorBlending);\n    functionRegistry.addMultiple(dataUri(environment));\n    functionRegistry.addMultiple(list);\n    functionRegistry.addMultiple(math);\n    functionRegistry.addMultiple(number);\n    functionRegistry.addMultiple(string);\n    functionRegistry.addMultiple(svg(environment));\n    functionRegistry.addMultiple(types);\n\n    return functions;\n};\n","import Quoted from '../tree/quoted';\nimport URL from '../tree/url';\nimport * as utils from '../utils';\nimport logger from '../logger';\n\nexport default environment => {\n    \n    const fallback = (functionThis, node) => new URL(node, functionThis.index, functionThis.currentFileInfo).eval(functionThis.context);    \n\n    return { 'data-uri': function(mimetypeNode, filePathNode) {\n\n        if (!filePathNode) {\n            filePathNode = mimetypeNode;\n            mimetypeNode = null;\n        }\n\n        let mimetype = mimetypeNode && mimetypeNode.value;\n        let filePath = filePathNode.value;\n        const currentFileInfo = this.currentFileInfo;\n        const currentDirectory = currentFileInfo.rewriteUrls ?\n            currentFileInfo.currentDirectory : currentFileInfo.entryPath;\n\n        const fragmentStart = filePath.indexOf('#');\n        let fragment = '';\n        if (fragmentStart !== -1) {\n            fragment = filePath.slice(fragmentStart);\n            filePath = filePath.slice(0, fragmentStart);\n        }\n        const context = utils.clone(this.context);\n        context.rawBuffer = true;\n\n        const fileManager = environment.getFileManager(filePath, currentDirectory, context, environment, true);\n\n        if (!fileManager) {\n            return fallback(this, filePathNode);\n        }\n\n        let useBase64 = false;\n\n        // detect the mimetype if not given\n        if (!mimetypeNode) {\n\n            mimetype = environment.mimeLookup(filePath);\n\n            if (mimetype === 'image/svg+xml') {\n                useBase64 = false;\n            } else {\n                // use base 64 unless it's an ASCII or UTF-8 format\n                const charset = environment.charsetLookup(mimetype);\n                useBase64 = ['US-ASCII', 'UTF-8'].indexOf(charset) < 0;\n            }\n            if (useBase64) { mimetype += ';base64'; }\n        }\n        else {\n            useBase64 = /;base64$/.test(mimetype);\n        }\n\n        const fileSync = fileManager.loadFileSync(filePath, currentDirectory, context, environment);\n        if (!fileSync.contents) {\n            logger.warn(`Skipped data-uri embedding of ${filePath} because file not found`);\n            return fallback(this, filePathNode || mimetypeNode);\n        }\n        let buf = fileSync.contents;\n        if (useBase64 && !environment.encodeBase64) {\n            return fallback(this, filePathNode);\n        }\n\n        buf = useBase64 ? environment.encodeBase64(buf) : encodeURIComponent(buf);\n\n        const uri = `data:${mimetype},${buf}${fragment}`;\n\n        return new URL(new Quoted(`\"${uri}\"`, uri, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);\n    }};\n};\n","import Dimension from '../tree/dimension';\nimport Color from '../tree/color';\nimport Expression from '../tree/expression';\nimport Quoted from '../tree/quoted';\nimport URL from '../tree/url';\n\nexport default environment => {\n    return { 'svg-gradient': function(direction) {\n        let stops;\n        let gradientDirectionSvg;\n        let gradientType = 'linear';\n        let rectangleDimension = 'x=\"0\" y=\"0\" width=\"1\" height=\"1\"';\n        const renderEnv = {compress: false};\n        let returner;\n        const directionValue = direction.toCSS(renderEnv);\n        let i;\n        let color;\n        let position;\n        let positionValue;\n        let alpha;\n\n        function throwArgumentDescriptor() {\n            throw { type: 'Argument',\n                message: 'svg-gradient expects direction, start_color [start_position], [color position,]...,' +\n                            ' end_color [end_position] or direction, color list' };\n        }\n\n        if (arguments.length == 2) {\n            if (arguments[1].value.length < 2) {\n                throwArgumentDescriptor();\n            }\n            stops = arguments[1].value;\n        } else if (arguments.length < 3) {\n            throwArgumentDescriptor();\n        } else {\n            stops = Array.prototype.slice.call(arguments, 1);\n        }\n\n        switch (directionValue) {\n            case 'to bottom':\n                gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\"';\n                break;\n            case 'to right':\n                gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\"';\n                break;\n            case 'to bottom right':\n                gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"100%\"';\n                break;\n            case 'to top right':\n                gradientDirectionSvg = 'x1=\"0%\" y1=\"100%\" x2=\"100%\" y2=\"0%\"';\n                break;\n            case 'ellipse':\n            case 'ellipse at center':\n                gradientType = 'radial';\n                gradientDirectionSvg = 'cx=\"50%\" cy=\"50%\" r=\"75%\"';\n                rectangleDimension = 'x=\"-50\" y=\"-50\" width=\"101\" height=\"101\"';\n                break;\n            default:\n                throw { type: 'Argument', message: 'svg-gradient direction must be \\'to bottom\\', \\'to right\\',' +\n                    ' \\'to bottom right\\', \\'to top right\\' or \\'ellipse at center\\'' };\n        }\n        returner = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1 1\"><${gradientType}Gradient id=\"g\" ${gradientDirectionSvg}>`;\n\n        for (i = 0; i < stops.length; i += 1) {\n            if (stops[i] instanceof Expression) {\n                color = stops[i].value[0];\n                position = stops[i].value[1];\n            } else {\n                color = stops[i];\n                position = undefined;\n            }\n\n            if (!(color instanceof Color) || (!((i === 0 || i + 1 === stops.length) && position === undefined) && !(position instanceof Dimension))) {\n                throwArgumentDescriptor();\n            }\n            positionValue = position ? position.toCSS(renderEnv) : i === 0 ? '0%' : '100%';\n            alpha = color.alpha;\n            returner += `<stop offset=\"${positionValue}\" stop-color=\"${color.toRGB()}\"${alpha < 1 ? ` stop-opacity=\"${alpha}\"` : ''}/>`;\n        }\n        returner += `</${gradientType}Gradient><rect ${rectangleDimension} fill=\"url(#g)\" /></svg>`;\n\n        returner = encodeURIComponent(returner);\n\n        returner = `data:image/svg+xml,${returner}`;\n        return new URL(new Quoted(`'${returner}'`, returner, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);\n    }};\n};\n","import contexts from './contexts';\nimport visitor from './visitors';\nimport tree from './tree';\n\nexport default (root, options = {}) => {\n    let evaldRoot;\n    let variables = options.variables;\n    const evalEnv = new contexts.Eval(options);\n\n    //\n    // Allows setting variables with a hash, so:\n    //\n    //   `{ color: new tree.Color('#f01') }` will become:\n    //\n    //   new tree.Declaration('@color',\n    //     new tree.Value([\n    //       new tree.Expression([\n    //         new tree.Color('#f01')\n    //       ])\n    //     ])\n    //   )\n    //\n    if (typeof variables === 'object' && !Array.isArray(variables)) {\n        variables = Object.keys(variables).map(k => {\n            let value = variables[k];\n\n            if (!(value instanceof tree.Value)) {\n                if (!(value instanceof tree.Expression)) {\n                    value = new tree.Expression([value]);\n                }\n                value = new tree.Value([value]);\n            }\n            return new tree.Declaration(`@${k}`, value, false, null, 0);\n        });\n        evalEnv.frames = [new tree.Ruleset(null, variables)];\n    }\n\n    const visitors = [\n        new visitor.JoinSelectorVisitor(),\n        new visitor.MarkVisibleSelectorsVisitor(true),\n        new visitor.ExtendVisitor(),\n        new visitor.ToCSSVisitor({compress: Boolean(options.compress)})\n    ];\n\n    const preEvalVisitors = [];\n    let v;\n    let visitorIterator;\n\n    /**\n     * first() / get() allows visitors to be added while visiting\n     * \n     * @todo Add scoping for visitors just like functions for @plugin; right now they're global\n     */\n    if (options.pluginManager) {\n        visitorIterator = options.pluginManager.visitor();\n        for (var i = 0; i < 2; i++) {\n            visitorIterator.first();\n            while ((v = visitorIterator.get())) {\n                if (v.isPreEvalVisitor) {\n                    if (i === 0 || preEvalVisitors.indexOf(v) === -1) {\n                        preEvalVisitors.push(v);\n                        v.run(root);\n                    }\n                }\n                else {\n                    if (i === 0 || visitors.indexOf(v) === -1) {\n                        if (v.isPreVisitor) {\n                            visitors.unshift(v);\n                        }\n                        else {\n                            visitors.push(v);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    evaldRoot = root.eval(evalEnv);\n\n    for (var i = 0; i < visitors.length; i++) {\n        visitors[i].run(evaldRoot);\n    }\n\n    // Run any remaining visitors added after eval pass\n    if (options.pluginManager) {\n        visitorIterator.first();\n        while ((v = visitorIterator.get())) {\n            if (visitors.indexOf(v) === -1 && preEvalVisitors.indexOf(v) === -1) {\n                v.run(evaldRoot);\n            }\n        }\n    }\n\n    return evaldRoot;\n};\n","/* global window, XMLHttpRequest */\n\nimport AbstractFileManager from '../less/environment/abstract-file-manager.js';\n\nlet options;\nlet logger;\nlet fileCache = {};\n\n// TODOS - move log somewhere. pathDiff and doing something similar in node. use pathDiff in the other browser file for the initial load\nclass FileManager extends AbstractFileManager {\n    alwaysMakePathsAbsolute() {\n        return true;\n    }\n\n    join(basePath, laterPath) {\n        if (!basePath) {\n            return laterPath;\n        }\n        return this.extractUrlParts(laterPath, basePath).path;\n    }\n\n    doXHR(url, type, callback, errback) {\n        const xhr = new XMLHttpRequest();\n        const async = options.isFileProtocol ? options.fileAsync : true;\n\n        if (typeof xhr.overrideMimeType === 'function') {\n            xhr.overrideMimeType('text/css');\n        }\n        logger.debug(`XHR: Getting '${url}'`);\n        xhr.open('GET', url, async);\n        xhr.setRequestHeader('Accept', type || 'text/x-less, text/css; q=0.9, */*; q=0.5');\n        xhr.send(null);\n\n        function handleResponse(xhr, callback, errback) {\n            if (xhr.status >= 200 && xhr.status < 300) {\n                callback(xhr.responseText,\n                    xhr.getResponseHeader('Last-Modified'));\n            } else if (typeof errback === 'function') {\n                errback(xhr.status, url);\n            }\n        }\n\n        if (options.isFileProtocol && !options.fileAsync) {\n            if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)) {\n                callback(xhr.responseText);\n            } else {\n                errback(xhr.status, url);\n            }\n        } else if (async) {\n            xhr.onreadystatechange = () => {\n                if (xhr.readyState == 4) {\n                    handleResponse(xhr, callback, errback);\n                }\n            };\n        } else {\n            handleResponse(xhr, callback, errback);\n        }\n    }\n\n    supports() {\n        return true;\n    }\n\n    clearFileCache() {\n        fileCache = {};\n    }\n\n    loadFile(filename, currentDirectory, options, environment) {\n        // TODO: Add prefix support like less-node?\n        // What about multiple paths?\n\n        if (currentDirectory && !this.isPathAbsolute(filename)) {\n            filename = currentDirectory + filename;\n        }\n\n        filename = options.ext ? this.tryAppendExtension(filename, options.ext) : filename;\n\n        options = options || {};\n\n        // sheet may be set to the stylesheet for the initial load or a collection of properties including\n        // some context variables for imports\n        const hrefParts = this.extractUrlParts(filename, window.location.href);\n        const href      = hrefParts.url;\n        const self      = this;\n        \n        return new Promise((resolve, reject) => {\n            if (options.useFileCache && fileCache[href]) {\n                try {\n                    const lessText = fileCache[href];\n                    return resolve({ contents: lessText, filename: href, webInfo: { lastModified: new Date() }});\n                } catch (e) {\n                    return reject({ filename: href, message: `Error loading file ${href} error was ${e.message}` });\n                }\n            }\n\n            self.doXHR(href, options.mime, function doXHRCallback(data, lastModified) {\n                // per file cache\n                fileCache[href] = data;\n\n                // Use remote copy (re-parse)\n                resolve({ contents: data, filename: href, webInfo: { lastModified }});\n            }, function doXHRError(status, url) {\n                reject({ type: 'File', message: `'${url}' wasn't found (${status})`, href });\n            });\n        });\n    }\n}\n\nexport default (opts, log) => {\n    options = opts;\n    logger = log;\n    return FileManager;\n}\n","import data from './data';\nimport tree from './tree';\nimport Environment from './environment/environment';\nimport AbstractFileManager from './environment/abstract-file-manager';\nimport AbstractPluginLoader from './environment/abstract-plugin-loader';\nimport visitors from './visitors';\nimport Parser from './parser/parser';\nimport Functions from './functions';\nimport contexts from './contexts';\nimport sourceMapOutput from './source-map-output';\nimport sourceMapBuilder from './source-map-builder';\nimport parseTree from './parse-tree';\nimport importManager from './import-manager';\nimport Render from './render';\nimport Parse from './parse';\nimport LessError from './less-error';\nimport transformTree from './transform-tree';\nimport * as utils from './utils';\nimport PluginManager from './plugin-manager';\nimport logger from './logger';\n\nexport default (environment, fileManagers) => {\n    /**\n     * @todo\n     * This original code could be improved quite a bit.\n     * Many classes / modules currently add side-effects / mutations to passed in objects,\n     * which makes it hard to refactor and reason about. \n     */\n    environment = new Environment(environment, fileManagers);\n\n    const SourceMapOutput = sourceMapOutput(environment);\n    const SourceMapBuilder = sourceMapBuilder(SourceMapOutput, environment);\n    const ParseTree = parseTree(SourceMapBuilder);\n    const ImportManager = importManager(environment);\n    const render = Render(environment, ParseTree, ImportManager);\n    const parse = Parse(environment, ParseTree, ImportManager);\n    const functions = Functions(environment);\n\n    /**\n     * @todo\n     * This root properties / methods need to be organized.\n     * It's not clear what should / must be public and why.\n     */\n    const initial = {\n        version: [3, 10, 0],\n        data,\n        tree,\n        Environment,\n        AbstractFileManager,\n        AbstractPluginLoader,\n        environment,\n        visitors,\n        Parser,\n        functions,\n        contexts,\n        SourceMapOutput,\n        SourceMapBuilder,\n        ParseTree,\n        ImportManager,\n        render,\n        parse,\n        LessError,\n        transformTree,\n        utils,\n        PluginManager,\n        logger\n    };\n\n    // Create a public API\n    const ctor = t => function (...args) {\n        return new t(...args);\n    };\n\n    let t;\n    const api = Object.create(initial);\n    for (const n in initial.tree) {\n        /* eslint guard-for-in: 0 */\n        t = initial.tree[n];\n        if (typeof t === 'function') {\n            api[n.toLowerCase()] = ctor(t);\n        }\n        else {\n            api[n] = Object.create(null);\n            for (const o in t) {\n                /* eslint guard-for-in: 0 */\n                api[n][o.toLowerCase()] = ctor(t[o]);\n            }\n        }\n    }\n\n    return api;\n};\n","export default environment => {\n    class SourceMapOutput {\n        constructor(options) {\n            this._css = [];\n            this._rootNode = options.rootNode;\n            this._contentsMap = options.contentsMap;\n            this._contentsIgnoredCharsMap = options.contentsIgnoredCharsMap;\n            if (options.sourceMapFilename) {\n                this._sourceMapFilename = options.sourceMapFilename.replace(/\\\\/g, '/');\n            }\n            this._outputFilename = options.outputFilename;\n            this.sourceMapURL = options.sourceMapURL;\n            if (options.sourceMapBasepath) {\n                this._sourceMapBasepath = options.sourceMapBasepath.replace(/\\\\/g, '/');\n            }\n            if (options.sourceMapRootpath) {\n                this._sourceMapRootpath = options.sourceMapRootpath.replace(/\\\\/g, '/');\n                if (this._sourceMapRootpath.charAt(this._sourceMapRootpath.length - 1) !== '/') {\n                    this._sourceMapRootpath += '/';\n                }\n            } else {\n                this._sourceMapRootpath = '';\n            }\n            this._outputSourceFiles = options.outputSourceFiles;\n            this._sourceMapGeneratorConstructor = environment.getSourceMapGenerator();\n\n            this._lineNumber = 0;\n            this._column = 0;\n        }\n\n        removeBasepath(path) {\n            if (this._sourceMapBasepath && path.indexOf(this._sourceMapBasepath) === 0) {\n                path = path.substring(this._sourceMapBasepath.length);\n                if (path.charAt(0) === '\\\\' || path.charAt(0) === '/') {\n                    path = path.substring(1);\n                }\n            }\n\n            return path;\n        }\n\n        normalizeFilename(filename) {\n            filename = filename.replace(/\\\\/g, '/');\n            filename = this.removeBasepath(filename);\n            return (this._sourceMapRootpath || '') + filename;\n        }\n\n        add(chunk, fileInfo, index, mapLines) {\n            // ignore adding empty strings\n            if (!chunk) {\n                return;\n            }\n\n            let lines;\n            let sourceLines;\n            let columns;\n            let sourceColumns;\n            let i;\n\n            if (fileInfo && fileInfo.filename) {\n                let inputSource = this._contentsMap[fileInfo.filename];\n\n                // remove vars/banner added to the top of the file\n                if (this._contentsIgnoredCharsMap[fileInfo.filename]) {\n                    // adjust the index\n                    index -= this._contentsIgnoredCharsMap[fileInfo.filename];\n                    if (index < 0) { index = 0; }\n                    // adjust the source\n                    inputSource = inputSource.slice(this._contentsIgnoredCharsMap[fileInfo.filename]);\n                }\n\n                // ignore empty content\n                if (inputSource === undefined) {\n                    return;\n                }\n\n                inputSource = inputSource.substring(0, index);\n                sourceLines = inputSource.split('\\n');\n                sourceColumns = sourceLines[sourceLines.length - 1];\n            }\n\n            lines = chunk.split('\\n');\n            columns = lines[lines.length - 1];\n\n            if (fileInfo && fileInfo.filename) {\n                if (!mapLines) {\n                    this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + 1, column: this._column},\n                        original: { line: sourceLines.length, column: sourceColumns.length},\n                        source: this.normalizeFilename(fileInfo.filename)});\n                } else {\n                    for (i = 0; i < lines.length; i++) {\n                        this._sourceMapGenerator.addMapping({ generated: { line: this._lineNumber + i + 1, column: i === 0 ? this._column : 0},\n                            original: { line: sourceLines.length + i, column: i === 0 ? sourceColumns.length : 0},\n                            source: this.normalizeFilename(fileInfo.filename)});\n                    }\n                }\n            }\n\n            if (lines.length === 1) {\n                this._column += columns.length;\n            } else {\n                this._lineNumber += lines.length - 1;\n                this._column = columns.length;\n            }\n\n            this._css.push(chunk);\n        }\n\n        isEmpty() {\n            return this._css.length === 0;\n        }\n\n        toCSS(context) {\n            this._sourceMapGenerator = new this._sourceMapGeneratorConstructor({ file: this._outputFilename, sourceRoot: null });\n\n            if (this._outputSourceFiles) {\n                for (const filename in this._contentsMap) {\n                    if (this._contentsMap.hasOwnProperty(filename)) {\n                        let source = this._contentsMap[filename];\n                        if (this._contentsIgnoredCharsMap[filename]) {\n                            source = source.slice(this._contentsIgnoredCharsMap[filename]);\n                        }\n                        this._sourceMapGenerator.setSourceContent(this.normalizeFilename(filename), source);\n                    }\n                }\n            }\n\n            this._rootNode.genCSS(context, this);\n\n            if (this._css.length > 0) {\n                let sourceMapURL;\n                const sourceMapContent = JSON.stringify(this._sourceMapGenerator.toJSON());\n\n                if (this.sourceMapURL) {\n                    sourceMapURL = this.sourceMapURL;\n                } else if (this._sourceMapFilename) {\n                    sourceMapURL = this._sourceMapFilename;\n                }\n                this.sourceMapURL = sourceMapURL;\n\n                this.sourceMap = sourceMapContent;\n            }\n\n            return this._css.join('');\n        }\n    }\n\n    return SourceMapOutput;\n};\n","export default (SourceMapOutput, environment) => {\n    class SourceMapBuilder {\n        constructor(options) {\n            this.options = options;\n        }\n\n        toCSS(rootNode, options, imports) {\n            const sourceMapOutput = new SourceMapOutput(\n                {\n                    contentsIgnoredCharsMap: imports.contentsIgnoredChars,\n                    rootNode,\n                    contentsMap: imports.contents,\n                    sourceMapFilename: this.options.sourceMapFilename,\n                    sourceMapURL: this.options.sourceMapURL,\n                    outputFilename: this.options.sourceMapOutputFilename,\n                    sourceMapBasepath: this.options.sourceMapBasepath,\n                    sourceMapRootpath: this.options.sourceMapRootpath,\n                    outputSourceFiles: this.options.outputSourceFiles,\n                    sourceMapGenerator: this.options.sourceMapGenerator,\n                    sourceMapFileInline: this.options.sourceMapFileInline\n                });\n\n            const css = sourceMapOutput.toCSS(options);\n            this.sourceMap = sourceMapOutput.sourceMap;\n            this.sourceMapURL = sourceMapOutput.sourceMapURL;\n            if (this.options.sourceMapInputFilename) {\n                this.sourceMapInputFilename = sourceMapOutput.normalizeFilename(this.options.sourceMapInputFilename);\n            }\n            if (this.options.sourceMapBasepath !== undefined && this.sourceMapURL !== undefined) {\n                this.sourceMapURL = sourceMapOutput.removeBasepath(this.sourceMapURL);\n            }\n            return css + this.getCSSAppendage();\n        }\n\n        getCSSAppendage() {\n\n            let sourceMapURL = this.sourceMapURL;\n            if (this.options.sourceMapFileInline) {\n                if (this.sourceMap === undefined) {\n                    return '';\n                }\n                sourceMapURL = `data:application/json;base64,${environment.encodeBase64(this.sourceMap)}`;\n            }\n\n            if (sourceMapURL) {\n                return `/*# sourceMappingURL=${sourceMapURL} */`;\n            }\n            return '';\n        }\n\n        getExternalSourceMap() {\n            return this.sourceMap;\n        }\n\n        setExternalSourceMap(sourceMap) {\n            this.sourceMap = sourceMap;\n        }\n\n        isInline() {\n            return this.options.sourceMapFileInline;\n        }\n\n        getSourceMapURL() {\n            return this.sourceMapURL;\n        }\n\n        getOutputFilename() {\n            return this.options.sourceMapOutputFilename;\n        }\n\n        getInputFilename() {\n            return this.sourceMapInputFilename;\n        }\n    }\n\n    return SourceMapBuilder;\n};\n","import LessError from './less-error';\nimport transformTree from './transform-tree';\nimport logger from './logger';\n\nexport default SourceMapBuilder => {\n    class ParseTree {\n        constructor(root, imports) {\n            this.root = root;\n            this.imports = imports;\n        }\n\n        toCSS(options) {\n            let evaldRoot;\n            const result = {};\n            let sourceMapBuilder;\n            try {\n                evaldRoot = transformTree(this.root, options);\n            } catch (e) {\n                throw new LessError(e, this.imports);\n            }\n\n            try {\n                const compress = Boolean(options.compress);\n                if (compress) {\n                    logger.warn('The compress option has been deprecated. ' + \n                        'We recommend you use a dedicated css minifier, for instance see less-plugin-clean-css.');\n                }\n\n                const toCSSOptions = {\n                    compress,\n                    dumpLineNumbers: options.dumpLineNumbers,\n                    strictUnits: Boolean(options.strictUnits),\n                    numPrecision: 8};\n\n                if (options.sourceMap) {\n                    sourceMapBuilder = new SourceMapBuilder(options.sourceMap);\n                    result.css = sourceMapBuilder.toCSS(evaldRoot, toCSSOptions, this.imports);\n                } else {\n                    result.css = evaldRoot.toCSS(toCSSOptions);\n                }\n            } catch (e) {\n                throw new LessError(e, this.imports);\n            }\n\n            if (options.pluginManager) {\n                const postProcessors = options.pluginManager.getPostProcessors();\n                for (let i = 0; i < postProcessors.length; i++) {\n                    result.css = postProcessors[i].process(result.css, { sourceMap: sourceMapBuilder, options, imports: this.imports });\n                }\n            }\n            if (options.sourceMap) {\n                result.map = sourceMapBuilder.getExternalSourceMap();\n            }\n\n            result.imports = [];\n            for (const file in this.imports.files) {\n                if (this.imports.files.hasOwnProperty(file) && file !== this.imports.rootFilename) {\n                    result.imports.push(file);\n                }\n            }\n            return result;\n        }\n    }\n\n    return ParseTree;\n};\n","import contexts from './contexts';\nimport Parser from './parser/parser';\nimport LessError from './less-error';\nimport * as utils from './utils';\nimport logger from './logger';\n\nexport default environment => {\n    // FileInfo = {\n    //  'rewriteUrls' - option - whether to adjust URL's to be relative\n    //  'filename' - full resolved filename of current file\n    //  'rootpath' - path to append to normal URLs for this node\n    //  'currentDirectory' - path to the current file, absolute\n    //  'rootFilename' - filename of the base file\n    //  'entryPath' - absolute path to the entry file\n    //  'reference' - whether the file should not be output and only output parts that are referenced\n\n    class ImportManager {\n        constructor(less, context, rootFileInfo) {\n            this.less = less;\n            this.rootFilename = rootFileInfo.filename;\n            this.paths = context.paths || [];  // Search paths, when importing\n            this.contents = {};             // map - filename to contents of all the files\n            this.contentsIgnoredChars = {}; // map - filename to lines at the beginning of each file to ignore\n            this.mime = context.mime;\n            this.error = null;\n            this.context = context;\n            // Deprecated? Unused outside of here, could be useful.\n            this.queue = [];        // Files which haven't been imported yet\n            this.files = {};        // Holds the imported parse trees.\n        }\n\n        /**\n         * Add an import to be imported\n         * @param path - the raw path\n         * @param tryAppendExtension - whether to try appending a file extension (.less or .js if the path has no extension)\n         * @param currentFileInfo - the current file info (used for instance to work out relative paths)\n         * @param importOptions - import options\n         * @param callback - callback for when it is imported\n         */\n        push(path, tryAppendExtension, currentFileInfo, importOptions, callback) {\n            const importManager = this;\n            const pluginLoader = this.context.pluginManager.Loader;\n\n            this.queue.push(path);\n\n            const fileParsedFunc = (e, root, fullPath) => {\n                importManager.queue.splice(importManager.queue.indexOf(path), 1); // Remove the path from the queue\n\n                const importedEqualsRoot = fullPath === importManager.rootFilename;\n                if (importOptions.optional && e) {\n                    callback(null, {rules:[]}, false, null);\n                    logger.info(`The file ${fullPath} was skipped because it was not found and the import was marked optional.`);\n                }\n                else {\n                    // Inline imports aren't cached here.\n                    // If we start to cache them, please make sure they won't conflict with non-inline imports of the\n                    // same name as they used to do before this comment and the condition below have been added.\n                    if (!importManager.files[fullPath] && !importOptions.inline) {\n                        importManager.files[fullPath] = { root, options: importOptions };\n                    }\n                    if (e && !importManager.error) { importManager.error = e; }\n                    callback(e, root, importedEqualsRoot, fullPath);\n                }\n            };\n\n            const newFileInfo = {\n                rewriteUrls: this.context.rewriteUrls,\n                entryPath: currentFileInfo.entryPath,\n                rootpath: currentFileInfo.rootpath,\n                rootFilename: currentFileInfo.rootFilename\n            };\n\n            const fileManager = environment.getFileManager(path, currentFileInfo.currentDirectory, this.context, environment);\n\n            if (!fileManager) {\n                fileParsedFunc({ message: `Could not find a file-manager for ${path}` });\n                return;\n            }\n\n            const loadFileCallback = loadedFile => {\n                let plugin;\n                const resolvedFilename = loadedFile.filename;\n                const contents = loadedFile.contents.replace(/^\\uFEFF/, '');\n\n                // Pass on an updated rootpath if path of imported file is relative and file\n                // is in a (sub|sup) directory\n                //\n                // Examples:\n                // - If path of imported file is 'module/nav/nav.less' and rootpath is 'less/',\n                //   then rootpath should become 'less/module/nav/'\n                // - If path of imported file is '../mixins.less' and rootpath is 'less/',\n                //   then rootpath should become 'less/../'\n                newFileInfo.currentDirectory = fileManager.getPath(resolvedFilename);\n                if (newFileInfo.rewriteUrls) {\n                    newFileInfo.rootpath = fileManager.join(\n                        (importManager.context.rootpath || ''),\n                        fileManager.pathDiff(newFileInfo.currentDirectory, newFileInfo.entryPath));\n\n                    if (!fileManager.isPathAbsolute(newFileInfo.rootpath) && fileManager.alwaysMakePathsAbsolute()) {\n                        newFileInfo.rootpath = fileManager.join(newFileInfo.entryPath, newFileInfo.rootpath);\n                    }\n                }\n                newFileInfo.filename = resolvedFilename;\n\n                const newEnv = new contexts.Parse(importManager.context);\n\n                newEnv.processImports = false;\n                importManager.contents[resolvedFilename] = contents;\n\n                if (currentFileInfo.reference || importOptions.reference) {\n                    newFileInfo.reference = true;\n                }\n\n                if (importOptions.isPlugin) {\n                    plugin = pluginLoader.evalPlugin(contents, newEnv, importManager, importOptions.pluginArgs, newFileInfo);\n                    if (plugin instanceof LessError) {\n                        fileParsedFunc(plugin, null, resolvedFilename);\n                    }\n                    else {\n                        fileParsedFunc(null, plugin, resolvedFilename);\n                    }\n                } else if (importOptions.inline) {\n                    fileParsedFunc(null, contents, resolvedFilename);\n                } else {\n\n                    // import (multiple) parse trees apparently get altered and can't be cached.\n                    // TODO: investigate why this is\n                    if (importManager.files[resolvedFilename]\n                        && !importManager.files[resolvedFilename].options.multiple\n                        && !importOptions.multiple) {\n\n                        fileParsedFunc(null, importManager.files[resolvedFilename].root, resolvedFilename);\n                    }\n                    else {\n                        new Parser(newEnv, importManager, newFileInfo).parse(contents, (e, root) => {\n                            fileParsedFunc(e, root, resolvedFilename);\n                        });\n                    }\n                }\n            };\n            let promise;\n            const context = utils.clone(this.context);\n\n            if (tryAppendExtension) {\n                context.ext = importOptions.isPlugin ? '.js' : '.less';\n            }\n\n            if (importOptions.isPlugin) {\n                context.mime = 'application/javascript';\n                promise = pluginLoader.loadPlugin(path, currentFileInfo.currentDirectory, context, environment, fileManager);\n            }\n            else {\n                promise = fileManager.loadFile(path, currentFileInfo.currentDirectory, context, environment,\n                    (err, loadedFile) => {\n                        if (err) {\n                            fileParsedFunc(err);\n                        } else {\n                            loadFileCallback(loadedFile);\n                        }\n                    });\n            }\n            if (promise) {\n                promise.then(loadFileCallback, fileParsedFunc);\n            }\n        }\n    }\n\n    return ImportManager;\n};\n","let PromiseConstructor;\nimport * as utils from './utils';\n\nexport default (environment, ParseTree, ImportManager) => {\n    const render = function (input, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = utils.copyOptions(this.options, {});\n        }\n        else {\n            options = utils.copyOptions(this.options, options || {});\n        }\n\n        if (!callback) {\n            const self = this;\n            return new Promise((resolve, reject) => {\n                render.call(self, input, options, (err, output) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(output);\n                    }\n                });\n            });\n        } else {\n            this.parse(input, options, (err, root, imports, options) => {\n                if (err) { return callback(err); }\n\n                let result;\n                try {\n                    const parseTree = new ParseTree(root, imports);\n                    result = parseTree.toCSS(options);\n                }\n                catch (err) { return callback(err); }\n\n                callback(null, result);\n            });\n        }\n    };\n\n    return render;\n};\n","let PromiseConstructor;\nimport contexts from './contexts';\nimport Parser from './parser/parser';\nimport PluginManager from './plugin-manager';\nimport LessError from './less-error';\nimport * as utils from './utils';\n\nexport default (environment, ParseTree, ImportManager) => {\n    const parse = function (input, options, callback) {\n\n        if (typeof options === 'function') {\n            callback = options;\n            options = utils.copyOptions(this.options, {});\n        }\n        else {\n            options = utils.copyOptions(this.options, options || {});\n        }\n\n        if (!callback) {\n            const self = this;\n            return new Promise((resolve, reject) => {\n                parse.call(self, input, options, (err, output) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(output);\n                    }\n                });\n            });\n        } else {\n            let context;\n            let rootFileInfo;\n            const pluginManager = new PluginManager(this, !options.reUsePluginManager);\n\n            options.pluginManager = pluginManager;\n\n            context = new contexts.Parse(options);\n\n            if (options.rootFileInfo) {\n                rootFileInfo = options.rootFileInfo;\n            } else {\n                const filename = options.filename || 'input';\n                const entryPath = filename.replace(/[^\\/\\\\]*$/, '');\n                rootFileInfo = {\n                    filename,\n                    rewriteUrls: context.rewriteUrls,\n                    rootpath: context.rootpath || '',\n                    currentDirectory: entryPath,\n                    entryPath,\n                    rootFilename: filename\n                };\n                // add in a missing trailing slash\n                if (rootFileInfo.rootpath && rootFileInfo.rootpath.slice(-1) !== '/') {\n                    rootFileInfo.rootpath += '/';\n                }\n            }\n\n            const imports = new ImportManager(this, context, rootFileInfo);\n            this.importManager = imports;\n\n            // TODO: allow the plugins to be just a list of paths or names\n            // Do an async plugin queue like lessc\n\n            if (options.plugins) {\n                options.plugins.forEach(plugin => {\n                    let evalResult;\n                    let contents;\n                    if (plugin.fileContent) {\n                        contents = plugin.fileContent.replace(/^\\uFEFF/, '');\n                        evalResult = pluginManager.Loader.evalPlugin(contents, context, imports, plugin.options, plugin.filename);\n                        if (evalResult instanceof LessError) {\n                            return callback(evalResult);\n                        }\n                    }\n                    else {\n                        pluginManager.addPlugin(plugin);\n                    }\n                });\n            }\n\n            new Parser(context, imports, rootFileInfo)\n                .parse(input, (e, root) => {\n                    if (e) { return callback(e); }\n                    callback(null, root, imports, options);\n                }, options);\n        }\n    };\n    return parse;\n};\n","// TODO: Add tests for browser @plugin\n/* global window */\n\nimport AbstractPluginLoader from '../less/environment/abstract-plugin-loader.js';\n\n/**\n * Browser Plugin Loader\n */\nclass PluginLoader extends AbstractPluginLoader {\n    constructor(less) {\n        super();\n\n        this.less = less;\n        // Should we shim this.require for browser? Probably not?\n    }\n\n    loadPlugin(filename, basePath, context, environment, fileManager) {\n        return new Promise((fulfill, reject) => {\n            fileManager.loadFile(filename, basePath, context, environment)\n                .then(fulfill).catch(reject);\n        });\n    }\n}\n\nexport default PluginLoader;\n\n","import * as utils from './utils';\nimport browser from './browser';\n\nexport default (window, less, options) => {\n\n    function errorHTML(e, rootHref) {\n        const id = `less-error-message:${utils.extractId(rootHref || '')}`;\n        const template = '<li><label>{line}</label><pre class=\"{class}\">{content}</pre></li>';\n        const elem = window.document.createElement('div');\n        let timer;\n        let content;\n        const errors = [];\n        const filename = e.filename || rootHref;\n        const filenameNoPath = filename.match(/([^\\/]+(\\?.*)?)$/)[1];\n\n        elem.id        = id;\n        elem.className = 'less-error-message';\n\n        content = `<h3>${e.type || 'Syntax'}Error: ${e.message || 'There is an error in your .less file'}` + \n            `</h3><p>in <a href=\"${filename}\">${filenameNoPath}</a> `;\n\n        const errorline = (e, i, classname) => {\n            if (e.extract[i] !== undefined) {\n                errors.push(template.replace(/\\{line\\}/, (parseInt(e.line, 10) || 0) + (i - 1))\n                    .replace(/\\{class\\}/, classname)\n                    .replace(/\\{content\\}/, e.extract[i]));\n            }\n        };\n\n        if (e.line) {\n            errorline(e, 0, '');\n            errorline(e, 1, 'line');\n            errorline(e, 2, '');\n            content += `on line ${e.line}, column ${e.column + 1}:</p><ul>${errors.join('')}</ul>`;\n        }\n        if (e.stack && (e.extract || options.logLevel >= 4)) {\n            content += `<br/>Stack Trace</br />${e.stack.split('\\n').slice(1).join('<br/>')}`;\n        }\n        elem.innerHTML = content;\n\n        // CSS for error messages\n        browser.createCSS(window.document, [\n            '.less-error-message ul, .less-error-message li {',\n            'list-style-type: none;',\n            'margin-right: 15px;',\n            'padding: 4px 0;',\n            'margin: 0;',\n            '}',\n            '.less-error-message label {',\n            'font-size: 12px;',\n            'margin-right: 15px;',\n            'padding: 4px 0;',\n            'color: #cc7777;',\n            '}',\n            '.less-error-message pre {',\n            'color: #dd6666;',\n            'padding: 4px 0;',\n            'margin: 0;',\n            'display: inline-block;',\n            '}',\n            '.less-error-message pre.line {',\n            'color: #ff0000;',\n            '}',\n            '.less-error-message h3 {',\n            'font-size: 20px;',\n            'font-weight: bold;',\n            'padding: 15px 0 5px 0;',\n            'margin: 0;',\n            '}',\n            '.less-error-message a {',\n            'color: #10a',\n            '}',\n            '.less-error-message .error {',\n            'color: red;',\n            'font-weight: bold;',\n            'padding-bottom: 2px;',\n            'border-bottom: 1px dashed red;',\n            '}'\n        ].join('\\n'), { title: 'error-message' });\n\n        elem.style.cssText = [\n            'font-family: Arial, sans-serif',\n            'border: 1px solid #e00',\n            'background-color: #eee',\n            'border-radius: 5px',\n            '-webkit-border-radius: 5px',\n            '-moz-border-radius: 5px',\n            'color: #e00',\n            'padding: 15px',\n            'margin-bottom: 15px'\n        ].join(';');\n\n        if (options.env === 'development') {\n            timer = setInterval(() => {\n                const document = window.document;\n                const body = document.body;\n                if (body) {\n                    if (document.getElementById(id)) {\n                        body.replaceChild(elem, document.getElementById(id));\n                    } else {\n                        body.insertBefore(elem, body.firstChild);\n                    }\n                    clearInterval(timer);\n                }\n            }, 10);\n        }\n    }\n\n    function removeErrorHTML(path) {\n        const node = window.document.getElementById(`less-error-message:${utils.extractId(path)}`);\n        if (node) {\n            node.parentNode.removeChild(node);\n        }\n    }\n\n    function removeErrorConsole(path) {\n        // no action\n    }\n\n    function removeError(path) {\n        if (!options.errorReporting || options.errorReporting === 'html') {\n            removeErrorHTML(path);\n        } else if (options.errorReporting === 'console') {\n            removeErrorConsole(path);\n        } else if (typeof options.errorReporting === 'function') {\n            options.errorReporting('remove', path);\n        }\n    }\n\n    function errorConsole(e, rootHref) {\n        const template = '{line} {content}';\n        const filename = e.filename || rootHref;\n        const errors = [];\n        let content = `${e.type || 'Syntax'}Error: ${e.message || 'There is an error in your .less file'} in ${filename}`;\n\n        const errorline = (e, i, classname) => {\n            if (e.extract[i] !== undefined) {\n                errors.push(template.replace(/\\{line\\}/, (parseInt(e.line, 10) || 0) + (i - 1))\n                    .replace(/\\{class\\}/, classname)\n                    .replace(/\\{content\\}/, e.extract[i]));\n            }\n        };\n\n        if (e.line) {\n            errorline(e, 0, '');\n            errorline(e, 1, 'line');\n            errorline(e, 2, '');\n            content += ` on line ${e.line}, column ${e.column + 1}:\\n${errors.join('\\n')}`;\n        }\n        if (e.stack && (e.extract || options.logLevel >= 4)) {\n            content += `\\nStack Trace\\n${e.stack}`;\n        }\n        less.logger.error(content);\n    }\n\n    function error(e, rootHref) {\n        if (!options.errorReporting || options.errorReporting === 'html') {\n            errorHTML(e, rootHref);\n        } else if (options.errorReporting === 'console') {\n            errorConsole(e, rootHref);\n        } else if (typeof options.errorReporting === 'function') {\n            options.errorReporting('add', e, rootHref);\n        }\n    }\n\n    return {\n        add: error,\n        remove: removeError\n    };\n};\n","/**\n * Kicks off less and compiles any stylesheets\n * used in the browser distributed version of less\n * to kick-start less using the browser api\n */\n/* global window, document */\n\nimport defaultOptions from '../less/default-options';\nimport addDefaultOptions from './add-default-options';\nimport root from './index';\n\nconst options = defaultOptions();\n\nif (window.less) {\n    for (const key in window.less) {\n        if (window.less.hasOwnProperty(key)) {\n            options[key] = window.less[key];\n        }\n    }\n}\naddDefaultOptions(window, options);\n\noptions.plugins = options.plugins || [];\n\nif (window.LESS_PLUGINS) {\n    options.plugins = options.plugins.concat(window.LESS_PLUGINS);\n}\n\nconst less = root(window, options);\nexport default less;\n\nwindow.less = less;\n\nlet css;\nlet head;\nlet style;\n\n// Always restore page visibility\nfunction resolveOrReject(data) {\n    if (data.filename) {\n        console.warn(data);\n    }\n    if (!options.async) {\n        head.removeChild(style);\n    }\n}\n\nif (options.onReady) {\n    if (/!watch/.test(window.location.hash)) {\n        less.watch();\n    }\n    // Simulate synchronous stylesheet loading by hiding page rendering\n    if (!options.async) {\n        css = 'body { display: none !important }';\n        head = document.head || document.getElementsByTagName('head')[0];\n        style = document.createElement('style');\n\n        style.type = 'text/css';\n        if (style.styleSheet) {\n            style.styleSheet.cssText = css;\n        } else {\n            style.appendChild(document.createTextNode(css));\n        }\n\n        head.appendChild(style);\n    }\n    less.registerStylesheetsImmediately();\n    less.pageLoadFinished = less.refresh(less.env === 'development').then(resolveOrReject, resolveOrReject);\n}\n","// Export a new default each time\nexport default () => ({\n    /* Inline Javascript - @plugin still allowed */\n    javascriptEnabled: false,\n\n    /* Outputs a makefile import dependency list to stdout. */\n    depends: false,\n\n    /* (DEPRECATED) Compress using less built-in compression. \n  * This does an okay job but does not utilise all the tricks of \n  * dedicated css compression. */\n    compress: false,\n\n    /* Runs the less parser and just reports errors without any output. */\n    lint: false,\n\n    /* Sets available include paths.\n  * If the file in an @import rule does not exist at that exact location, \n  * less will look for it at the location(s) passed to this option. \n  * You might use this for instance to specify a path to a library which \n  * you want to be referenced simply and relatively in the less files. */\n    paths: [],\n\n    /* color output in the terminal */\n    color: true,\n\n    /* The strictImports controls whether the compiler will allow an @import inside of either \n  * @media blocks or (a later addition) other selector blocks.\n  * See: https://github.com/less/less.js/issues/656 */\n    strictImports: false,\n\n    /* Allow Imports from Insecure HTTPS Hosts */\n    insecure: false,\n\n    /* Allows you to add a path to every generated import and url in your css. \n  * This does not affect less import statements that are processed, just ones \n  * that are left in the output css. */\n    rootpath: '',\n\n    /* By default URLs are kept as-is, so if you import a file in a sub-directory \n  * that references an image, exactly the same URL will be output in the css. \n  * This option allows you to re-write URL's in imported files so that the \n  * URL is always relative to the base imported file */\n    rewriteUrls: false,\n\n    /* How to process math \n  *   0 always           - eagerly try to solve all operations\n  *   1 parens-division  - require parens for division \"/\"\n  *   2 parens | strict  - require parens for all operations\n  *   3 strict-legacy    - legacy strict behavior (super-strict)\n  */\n    math: 0,\n\n    /* Without this option, less attempts to guess at the output unit when it does maths. */\n    strictUnits: false,\n\n    /* Effectively the declaration is put at the top of your base Less file, \n  * meaning it can be used but it also can be overridden if this variable \n  * is defined in the file. */\n    globalVars: null,\n\n    /* As opposed to the global variable option, this puts the declaration at the\n  * end of your base file, meaning it will override anything defined in your Less file. */\n    modifyVars: null,\n\n    /* This option allows you to specify a argument to go on to every URL.  */\n    urlArgs: ''\n});","import {addDataAttr} from './utils';\nimport browser from './browser';\n\nexport default (window, options) => {\n\n    // use options from the current script tag data attribues\n    addDataAttr(options, browser.currentScript(window));\n\n    if (options.isFileProtocol === undefined) {\n        options.isFileProtocol = /^(file|(chrome|safari)(-extension)?|resource|qrc|app):/.test(window.location.protocol);\n    }\n\n    // Load styles asynchronously (default: false)\n    //\n    // This is set to `false` by default, so that the body\n    // doesn't start loading before the stylesheets are parsed.\n    // Setting this to `true` can result in flickering.\n    //\n    options.async = options.async || false;\n    options.fileAsync = options.fileAsync || false;\n\n    // Interval between watch polls\n    options.poll = options.poll || (options.isFileProtocol ? 1000 : 1500);\n\n    options.env = options.env || (window.location.hostname == '127.0.0.1' ||\n        window.location.hostname == '0.0.0.0'   ||\n        window.location.hostname == 'localhost' ||\n        (window.location.port &&\n            window.location.port.length > 0)      ||\n        options.isFileProtocol                   ? 'development'\n        : 'production');\n\n    const dumpLineNumbers = /!dumpLineNumbers:(comments|mediaquery|all)/.exec(window.location.hash);\n    if (dumpLineNumbers) {\n        options.dumpLineNumbers = dumpLineNumbers[1];\n    }\n\n    if (options.useFileCache === undefined) {\n        options.useFileCache = true;\n    }\n\n    if (options.onReady === undefined) {\n        options.onReady = true;\n    }\n\n    if (options.relativeUrls) {\n        options.rewriteUrls = 'all';\n    }\n};\n","//\n// index.js\n// Should expose the additional browser functions on to the less object\n//\nimport {addDataAttr} from './utils';\nimport lessRoot from '../less';\nimport browser from './browser';\nimport FM from './file-manager';\nimport PluginLoader from './plugin-loader';\nimport LogListener from './log-listener';\nimport ErrorReporting from './error-reporting';\nimport Cache from './cache';\nimport ImageSize from './image-size';\n\nexport default (window, options) => {\n    const document = window.document;\n    const less = lessRoot();\n\n    less.options = options;\n    const environment = less.environment;\n    const FileManager = FM(options, less.logger);\n    const fileManager = new FileManager();\n    environment.addFileManager(fileManager);\n    less.FileManager = FileManager;\n    less.PluginLoader = PluginLoader;\n\n    LogListener(less, options);\n    const errors = ErrorReporting(window, less, options);\n    const cache = less.cache = options.cache || Cache(window, options, less.logger);\n    ImageSize(less.environment);\n\n    // Setup user functions - Deprecate?\n    if (options.functions) {\n        less.functions.functionRegistry.addMultiple(options.functions);\n    }\n\n    const typePattern = /^text\\/(x-)?less$/;\n\n    function clone(obj) {\n        const cloned = {};\n        for (const prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                cloned[prop] = obj[prop];\n            }\n        }\n        return cloned;\n    }\n\n    // only really needed for phantom\n    function bind(func, thisArg) {\n        const curryArgs = Array.prototype.slice.call(arguments, 2);\n        return function() {\n            const args = curryArgs.concat(Array.prototype.slice.call(arguments, 0));\n            return func.apply(thisArg, args);\n        };\n    }\n\n    function loadStyles(modifyVars) {\n        const styles = document.getElementsByTagName('style');\n        let style;\n\n        for (let i = 0; i < styles.length; i++) {\n            style = styles[i];\n            if (style.type.match(typePattern)) {\n                const instanceOptions = clone(options);\n                instanceOptions.modifyVars = modifyVars;\n                const lessText = style.innerHTML || '';\n                instanceOptions.filename = document.location.href.replace(/#.*$/, '');\n\n                /* jshint loopfunc:true */\n                // use closure to store current style\n                less.render(lessText, instanceOptions,\n                    bind((style, e, result) => {\n                        if (e) {\n                            errors.add(e, 'inline');\n                        } else {\n                            style.type = 'text/css';\n                            if (style.styleSheet) {\n                                style.styleSheet.cssText = result.css;\n                            } else {\n                                style.innerHTML = result.css;\n                            }\n                        }\n                    }, null, style));\n            }\n        }\n    }\n\n    function loadStyleSheet(sheet, callback, reload, remaining, modifyVars) {\n\n        const instanceOptions = clone(options);\n        addDataAttr(instanceOptions, sheet);\n        instanceOptions.mime = sheet.type;\n\n        if (modifyVars) {\n            instanceOptions.modifyVars = modifyVars;\n        }\n\n        function loadInitialFileCallback(loadedFile) {\n            const data = loadedFile.contents;\n            const path = loadedFile.filename;\n            const webInfo = loadedFile.webInfo;\n\n            const newFileInfo = {\n                currentDirectory: fileManager.getPath(path),\n                filename: path,\n                rootFilename: path,\n                rewriteUrls: instanceOptions.rewriteUrls\n            };\n\n            newFileInfo.entryPath = newFileInfo.currentDirectory;\n            newFileInfo.rootpath = instanceOptions.rootpath || newFileInfo.currentDirectory;\n\n            if (webInfo) {\n                webInfo.remaining = remaining;\n\n                const css = cache.getCSS(path, webInfo, instanceOptions.modifyVars);\n                if (!reload && css) {\n                    webInfo.local = true;\n                    callback(null, css, data, sheet, webInfo, path);\n                    return;\n                }\n\n            }\n\n            // TODO add tests around how this behaves when reloading\n            errors.remove(path);\n\n            instanceOptions.rootFileInfo = newFileInfo;\n            less.render(data, instanceOptions, (e, result) => {\n                if (e) {\n                    e.href = path;\n                    callback(e);\n                } else {\n                    cache.setCSS(sheet.href, webInfo.lastModified, instanceOptions.modifyVars, result.css);\n                    callback(null, result.css, data, sheet, webInfo, path);\n                }\n            });\n        }\n\n        fileManager.loadFile(sheet.href, null, instanceOptions, environment)\n            .then(loadedFile => {\n                loadInitialFileCallback(loadedFile);\n            }).catch(err => {\n                console.log(err);\n                callback(err);\n            });\n\n    }\n\n    function loadStyleSheets(callback, reload, modifyVars) {\n        for (let i = 0; i < less.sheets.length; i++) {\n            loadStyleSheet(less.sheets[i], callback, reload, less.sheets.length - (i + 1), modifyVars);\n        }\n    }\n\n    function initRunningMode() {\n        if (less.env === 'development') {\n            less.watchTimer = setInterval(() => {\n                if (less.watchMode) {\n                    fileManager.clearFileCache();\n                    loadStyleSheets((e, css, _, sheet, webInfo) => {\n                        if (e) {\n                            errors.add(e, e.href || sheet.href);\n                        } else if (css) {\n                            browser.createCSS(window.document, css, sheet);\n                        }\n                    });\n                }\n            }, options.poll);\n        }\n    }\n\n    //\n    // Watch mode\n    //\n    less.watch   = function () {\n        if (!less.watchMode ) {\n            less.env = 'development';\n            initRunningMode();\n        }\n        this.watchMode = true;\n        return true;\n    };\n\n    less.unwatch = function () {clearInterval(less.watchTimer); this.watchMode = false; return false; };\n\n    //\n    // Synchronously get all <link> tags with the 'rel' attribute set to\n    // \"stylesheet/less\".\n    //\n    less.registerStylesheetsImmediately = () => {\n        const links = document.getElementsByTagName('link');\n        less.sheets = [];\n\n        for (let i = 0; i < links.length; i++) {\n            if (links[i].rel === 'stylesheet/less' || (links[i].rel.match(/stylesheet/) &&\n                (links[i].type.match(typePattern)))) {\n                less.sheets.push(links[i]);\n            }\n        }\n    };\n\n    //\n    // Asynchronously get all <link> tags with the 'rel' attribute set to\n    // \"stylesheet/less\", returning a Promise.\n    //\n    less.registerStylesheets = () => new Promise((resolve, reject) => {\n        less.registerStylesheetsImmediately();\n        resolve();\n    });\n\n    //\n    // With this function, it's possible to alter variables and re-render\n    // CSS without reloading less-files\n    //\n    less.modifyVars = record => less.refresh(true, record, false);\n\n    less.refresh = (reload, modifyVars, clearFileCache) => {\n        if ((reload || clearFileCache) && clearFileCache !== false) {\n            fileManager.clearFileCache();\n        }\n        return new Promise((resolve, reject) => {\n            let startTime;\n            let endTime;\n            let totalMilliseconds;\n            let remainingSheets;\n            startTime = endTime = new Date();\n\n            // Set counter for remaining unprocessed sheets\n            remainingSheets = less.sheets.length;\n\n            if (remainingSheets === 0) {\n\n                endTime = new Date();\n                totalMilliseconds = endTime - startTime;\n                less.logger.info('Less has finished and no sheets were loaded.');\n                resolve({\n                    startTime,\n                    endTime,\n                    totalMilliseconds,\n                    sheets: less.sheets.length\n                });\n\n            } else {\n                // Relies on less.sheets array, callback seems to be guaranteed to be called for every element of the array\n                loadStyleSheets((e, css, _, sheet, webInfo) => {\n                    if (e) {\n                        errors.add(e, e.href || sheet.href);\n                        reject(e);\n                        return;\n                    }\n                    if (webInfo.local) {\n                        less.logger.info(`Loading ${sheet.href} from cache.`);\n                    } else {\n                        less.logger.info(`Rendered ${sheet.href} successfully.`);\n                    }\n                    browser.createCSS(window.document, css, sheet);\n                    less.logger.info(`CSS for ${sheet.href} generated in ${new Date() - endTime}ms`);\n\n                    // Count completed sheet\n                    remainingSheets--;\n\n                    // Check if the last remaining sheet was processed and then call the promise\n                    if (remainingSheets === 0) {\n                        totalMilliseconds = new Date() - startTime;\n                        less.logger.info(`Less has finished. CSS generated in ${totalMilliseconds}ms`);\n                        resolve({\n                            startTime,\n                            endTime,\n                            totalMilliseconds,\n                            sheets: less.sheets.length\n                        });\n                    }\n                    endTime = new Date();\n                }, reload, modifyVars);\n            }\n\n            loadStyles(modifyVars);\n        });\n    };\n\n    less.refreshStyles = loadStyles;\n    return less;\n};\n","export default (less, options) => {\n    const logLevel_debug = 4;\n    const logLevel_info = 3;\n    const logLevel_warn = 2;\n    const logLevel_error = 1;\n\n    // The amount of logging in the javascript console.\n    // 3 - Debug, information and errors\n    // 2 - Information and errors\n    // 1 - Errors\n    // 0 - None\n    // Defaults to 2\n    options.logLevel = typeof options.logLevel !== 'undefined' ? options.logLevel : (options.env === 'development' ?  logLevel_info : logLevel_error);\n\n    if (!options.loggers) {\n        options.loggers = [{\n            debug: function(msg) {\n                if (options.logLevel >= logLevel_debug) {\n                    console.log(msg);\n                }\n            },\n            info: function(msg) {\n                if (options.logLevel >= logLevel_info) {\n                    console.log(msg);\n                }\n            },\n            warn: function(msg) {\n                if (options.logLevel >= logLevel_warn) {\n                    console.warn(msg);\n                }\n            },\n            error: function(msg) {\n                if (options.logLevel >= logLevel_error) {\n                    console.error(msg);\n                }\n            }\n        }];\n    }\n    for (let i = 0; i < options.loggers.length; i++) {\n        less.logger.addListener(options.loggers[i]);\n    }\n};\n","// Cache system is a bit outdated and could do with work\n\nexport default (window, options, logger) => {\n    let cache = null;\n    if (options.env !== 'development') {\n        try {\n            cache = (typeof window.localStorage === 'undefined') ? null : window.localStorage;\n        } catch (_) {}\n    }\n    return {\n        setCSS: function(path, lastModified, modifyVars, styles) {\n            if (cache) {\n                logger.info(`saving ${path} to cache.`);\n                try {\n                    cache.setItem(path, styles);\n                    cache.setItem(`${path}:timestamp`, lastModified);\n                    if (modifyVars) {\n                        cache.setItem(`${path}:vars`, JSON.stringify(modifyVars));\n                    }\n                } catch (e) {\n                    // TODO - could do with adding more robust error handling\n                    logger.error(`failed to save \"${path}\" to local storage for caching.`);\n                }\n            }\n        },\n        getCSS: function(path, webInfo, modifyVars) {\n            const css       = cache && cache.getItem(path);\n            const timestamp = cache && cache.getItem(`${path}:timestamp`);\n            let vars      = cache && cache.getItem(`${path}:vars`);\n\n            modifyVars = modifyVars || {};\n            vars = vars || \"{}\"; // if not set, treat as the JSON representation of an empty object\n\n            if (timestamp && webInfo.lastModified &&\n                (new Date(webInfo.lastModified).valueOf() ===\n                    new Date(timestamp).valueOf()) &&\n                JSON.stringify(modifyVars) === vars) {\n                // Use local copy\n                return css;\n            }\n        }\n    };\n};\n","\nimport functionRegistry from './../less/functions/function-registry';\n\nexport default () => {\n    function imageSize() {\n        throw {\n            type: 'Runtime',\n            message: 'Image size functions are not supported in browser version of less'\n        };\n    }\n\n    const imageFunctions = {\n        'image-size': function(filePathNode) {\n            imageSize(this, filePathNode);\n            return -1;\n        },\n        'image-width': function(filePathNode) {\n            imageSize(this, filePathNode);\n            return -1;\n        },\n        'image-height': function(filePathNode) {\n            imageSize(this, filePathNode);\n            return -1;\n        }\n    };\n\n    functionRegistry.addMultiple(imageFunctions);\n};\n"],"names":["extractId","href","replace","addDataAttr","options","tag","opt","dataset","hasOwnProperty","JSON","parse","_","createCSS","document","styles","sheet","id","title","utils","oldStyleNode","getElementById","keepOldStyleNode","styleNode","createElement","setAttribute","media","styleSheet","appendChild","createTextNode","childNodes","length","firstChild","nodeValue","head","getElementsByTagName","nextEl","nextSibling","parentNode","insertBefore","removeChild","cssText","e","Error","currentScript","window","scripts","duration","angle","Math","PI","colors","unitConversions","Node","parent","visibilityBlocks","undefined","nodeVisible","rootNode","parsed","self","this","Object","defineProperty","get","fileInfo","getIndex","nodes","set","node","Array","isArray","forEach","_index","_fileInfo","context","strs","genCSS","add","chunk","index","push","isEmpty","join","output","value","visitor","visit","op","a","b","precision","numPrecision","Number","toFixed","info","compare","type","i","numericCompare","Color","rgb","originalForm","match","map","c","parseInt","alpha","split","_this","r","g","pow","toCSS","doNotCompress","color","colorFunction","compress","args","fround","indexOf","clamp","round","concat","toHSL","h","s","l","toRGB","splitcolor","other","_operate","toHex","max","min","d","v","x","toString","prototype","fromKeyword","keyword","key","toLowerCase","slice","Paren","eval","_noSpaceCombinators","Combinator","emptyOrWhitespace","trim","spaceOrEmpty","Element","combinator","isVariable","currentFileInfo","visibilityInfo","copyVisibilityInfo","setParent","_typeof","firstSelector","charAt","ALWAYS","PARENS_DIVISION","PARENS","STRICT_LEGACY","RewriteUrls","OFF","LOCAL","ALL","clone","_instanceof","obj","nativeMap","nativeSet","nativePromise","Map","Set","Promise","circular","depth","includeNonEnumerable","allParents","allChildren","useBuffer","Buffer","Infinity","_clone","child","proto","resolve","reject","then","err","__isArray","__isRegExp","RegExp","source","__getRegExpFlags","lastIndex","__isDate","Date","getTime","isBuffer","allocUnsafe","copy","create","getPrototypeOf","keyChild","valueChild","entryChild","attrs","getOwnPropertyDescriptor","getOwnPropertySymbols","symbols","symbol","descriptor","enumerable","allPropertyNames","getOwnPropertyNames","propertyName","__objToStr","o","call","re","flags","global","ignoreCase","multiline","clonePrototype","module","exports","getLocation","inputStream","n","line","column","copyArray","arr","cloned","prop","defaults","obj1","obj2","newObj","_defaults","CloneHelper","assign","copyOptions","opts","strictMath","math","Constants","relativeUrls","rewriteUrls","flattenArray","result","LessError","fileContentMap","currentFilename","filename","message","stack","input","contents","loc","col","callLine","lines","found","callExtract","extract","F","constructor","error","stylize","str","errorTxt","substr","Selector","elements","extendList","condition","evaldCondition","getElements","mixinElements_","visitArray","newSelector","mediaEmpty","els","parseNode","imports","sels","olen","len","mixinElements","shift","extend","createDerived","Value","Keyword","True","False","Anonymous","mapLines","rulesetLike","allowRoot","Boolean","MATH","Declaration","name","important","merge","inline","variable","lastRule","prevMath","evaldValue","mathBypass","evalName","importantScope","importantResult","pop","debugInfo","ctx","lineSeparator","dumpLineNumbers","asComment","asMediaQuery","lineNumber","fileName","filenameWithProtocol","test","Comment","isLineComment","getDebugInfo","isCompressed","contexts","copyFromOriginal","original","destination","propertiesToCopy","parseCopyProperties","Parse","paths","evalCopyProperties","isPathRelative","path","isPathLocalRelative","Eval","frames","inCalc","mathOn","calcStack","parensStack","rootpath","newPath","normalizePath","segment","segments","reverse","makeRegistry","base","_data","func","addMultiple","functions","keys","getLocalFunctions","inherit","defaultFunc","value_","error_","reset","Ruleset","selectors","rules","strictImports","_lookups","_variables","_properties","selCnt","selector","hasVariable","hasOnePassingSelector","j","toParseSelectors","rule","subRule","ruleset","originalRuleset","root","firstRoot","allowImports","functionRegistry","globalFunctionRegistry","ctxFrames","unshift","ctxSelectors","evalImports","rsRules","evalFirst","mediaBlockCount","mediaBlocks","filter","splice","resetCache","isJustParentSelector","bubbleSelectors","importRules","makeImportant","lastSelector","_rulesets","reduce","hash","variables","vars","decl","parseValue","properties","toParse","transformDeclaration","filtRules","isRuleset","foundMixins","rulesets","find","apply","ruleNodes","tabLevel","sep","tabRuleStr","tabSetStr","charsetNodeIndex","importNodeIndex","isCharset","pathSubCnt","pathCnt","currentLastRule","isRulesetLike","isVisible","joinSelector","createParenthesis","elementsToPak","originalElement","replacementParen","insideParent","createSelector","containedElement","element","addReplacementIntoPath","beginningPath","addPath","replacedElement","originalSelector","newSelectorPath","newJoinedSelector","parentEl","restOfPath","addAllReplacementsIntoPath","addPaths","mergeElementsOnToSelectors","sel","deriveSelector","deriveFrom","newPaths","replaceParentSelector","inSelector","k","currentElements","newSelectors","selectorsMultiplied","el","maybeSelector","hadParentSelector","nestedSelector","replaced","nestedPaths","replacedNewSelectors","concatenated","bind","AtRule","isRooted","createEmptySelectors","outputRuleset","mediaPathBackup","mediaBlocksBackup","mediaPath","ruleCnt","DetachedRuleset","Unit","numerator","denominator","backupUnit","sort","strictUnits","returnStr","is","unitString","toUpperCase","callback","group","mapUnit","groupName","atomicUnit","counter","count","Dimension","unit","parseFloat","isNaN","isSingular","strValue","String","isLength","convertTo","usedUnits","cancel","unify","conversions","targetUnit","applyUnit","derivedConversions","Operation","operands","isSpaced","isMathOn","toColor","operate","Expression","noSpacing","returnValue","inParenthesis","parens","parensInOp","doubleParen","outOfParenthesis","functionCaller","item","subNodes","Call","calc","currentMathContext","enterCalc","exitCalc","funcCaller","FunctionCaller","isValid","columnNumber","Variable","evaluating","frame","fun","Property","property","mergeRules","pluginManager","less","visitors","ToCSSVisitor","_mergeRules","vArr","Attribute","Quoted","content","escaped","quote","variableRegex","propRegex","that","iterativeReplace","regexp","replacementFnc","evaluatedValue","URL","val","isEvald","pathRequiresRewrite","rewritePath","urlArgs","Media","features","evalTop","evalNested","multiMedia","permute","fragment","rest","Import","css","pathValue","getPath","isPlugin","reference","containsVariables","doEval","blocksVisibility","addVisibilityBlock","registry","skip","importedFilename","newImport","evalPath","JsEvalNode","expression","evalContext","javascriptEnabled","jsify","Function","toJS","JavaScript","string","evaluateJavaScript","Assignment","Condition","negate","lvalue","rvalue","UnicodeDescriptor","Negative","Extend","option","object_id","next_id","parent_ids","allowBefore","allowAfter","selectorElements","selfElements","selfSelectors","VariableCall","detachedRuleset","callEval","NamespaceValue","ruleCall","lookups","lastDeclaration","substring","Definition","params","variadic","arity","optionalParameters","required","p","mixinEnv","evaldArguments","varargs","arg","isNamedFound","argIndex","argsLength","prependRule","_arguments","mixinFrames","evalParams","allArgsCnt","requiredArgsCnt","MixinCall","arguments","mixins","mixin","mixinPath","argValue","m","f","isRecursive","isOneFound","candidate","defaultResult","noArgumentsFilter","candidates","conditionResult","defFalseEitherCase","defNone","defTrue","defFalse","calcDefGroup","namespace","matchCondition","expand","matchArgs","MixinDefinition","format","newRules","evalCall","_setVisibilityToReplacement","replacement","msg","_fireEvent","warn","debug","addListener","listener","_listeners","removeListener","logFunction","environment","externalEnvironment","fileManagers","requiredFunctions","propName","environmentFunc","currentDirectory","isSync","logger","getFileManagers","fileManager","AbstractFileManager","lastIndexOf","ext","tryAppendExtension","basePath","laterPath","url","baseUrl","urlDirectories","baseUrlDirectories","urlParts","extractUrlParts","baseUrlParts","diff","hostPart","directories","urlPartsRegex","returner","rawDirectories","rawPath","fileUrl","AbstractPluginLoader","require","pluginOptions","pluginObj","localModule","shortname","FileManager","trySetOptions","use","loader","tree","validatePlugin","minVersion","compareVersion","addPlugin","plugin","setOptions","version","versionToString","aVersion","bVersion","versionString","plugins","printUsage","_visitArgs","visitDeeper","_hasIndexed","_noop","Visitor","impl","_impl","_visitInCache","_visitOutCache","indexNodeTypes","ticker","typeIndex","nodeTypeIndex","fnName","funcOut","visitArgs","newNode","isReplacing","accept","nonReplacing","cnt","out","evald","flatten","nestedCnt","nestedItem","ImportSequencer","onSequencerEmpty","variableImports","_onSequencerEmpty","_currentDepth","importSequencer","importItem","isReady","tryRun","variableImport","ImportVisitor","importer","finish","_importer","_finish","importCount","onceFileDetectionMap","recursionDetector","_sequencer","isFinished","importNode","inlineCSS","importParent","isVariableImport","addVariableImport","processImportNode","evaldImportNode","evalForImport","multiple","importMultiple","tryAppendLessExtension","onImported","sequencedOnImported","addImport","importedAtRoot","fullPath","importVisitor","isOptional","optional","duplicateImport","oldContext","declNode","atRuleNode","mixinDefinitionNode","rulesetNode","mediaNode","SetTreeVisibilityVisitor","visible","ensureVisibility","ensureInvisibility","ExtendFinderVisitor","extendMap","hasExtend","elValue","selArray","_this2","_elementValue","_visitAtRule","_visitAtRuleOut","targets","selectorTargets","pushExtend","_this3","target","_joinPath","coll","pathExtend","ProcessExtendsVisitor","finder","ruleMap","run","targetPath","findElements","extendVisible","valueMap","extendElements","nextMatch","findLength","matches","allMatches","setIndex","num","getValue","lookup","_this5","currentEl","nextValue","currentValue","extendEl","matchExtendValue","matchExtendCombinator","prev","matchArr","mapCollection","outputPaths","listLength","range","accumulator","startingElement","selectorModified","newEl","start","createPaths","visitedKeys","insertions","_this6","addInsertion","selString","mapIndex","vKeys","exactMatch","mapKey","mapKeyLength","newFind","insertion","_createDerived","JoinSelectorVisitor","getIsOutput","joinSelectors","CSSVisitorUtils","_context","bodyRules","isSilent","owner","thing","originalRules","containsSilentNonBlockedChild","compiledRulesBody","keepOnlyVisibleChilds","removeVisibilityBlock","hasVisibleSelector","MarkVisibleSelectorsVisitor","ExtendVisitor","mixinNode","extendNode","commentNode","resolveVisibility","visitAtRuleWithBody","visitAtRuleWithoutBody","anonymousNode","nodeRules","hasFakeRuleset","getBodyRules","charset","comment","isRoot","ruleNode","checkValidNodes","_compileRulesetPaths","nodeRuleCnt","_removeDuplicateRules","isVisibleRuleset","ruleList","ruleCache","ruleCSS","groups","groupsArr","space","comma","furthest","furthestPossibleErrorMessage","chunks","current","currentPos","saveStack","parserInput","CHARCODE_SPACE","CHARCODE_TAB","CHARCODE_LF","CHARCODE_CR","CHARCODE_FORWARD_SLASH","skipWhitespace","nextChar","oldi","oldj","curr","endIndex","mem","inp","charCodeAt","autoCommentAbsorb","nextNewLine","text","commentStore","nextStarSlash","finished","save","restore","possibleErrorMessage","state","forget","isWhitespace","offset","pos","code","$re","tok","exec","$char","$str","tokLength","$quoted","startChar","currentPosition","$parseUntil","testChar","returnVal","inComment","blockDepth","blockStack","parseGroups","startPos","lastPos","loop","char","expected","peek","peekChar","currentChar","prevChar","getInput","peekNotNumeric","chunkInput","failFunction","fail","lastOpening","lastOpeningParen","lastMultiComment","lastMultiCommentEndBrace","chunkerCurrentIndex","currentChunkStartIndex","cc","cc2","matched","level","parenLevel","emitFrom","emitChunk","force","fromCharCode","chunker","end","furthestReachedEnd","furthestChar","Parser","parsers","getParserInput","expect","expectChar","parseList","currentIndex","returnNodes","parser","additionalData","globalVars","modifyVars","ignored","preText","serializeVars","preProcessors","getPreProcessors","process","banner","contentsIgnoredChars","primary","endInfo","processImports","extendRule","definition","declaration","variableCall","entities","atrule","foundSemiColon","mixinLookup","quoted","forceEscaped","isEscaped","customFuncCall","stop","ieAlpha","boolean","prevArgs","isSemiColonSeparated","argsComma","argsSemiColon","assignment","literal","dimension","unicodeDescriptor","entity","ch","variableCurly","curly","propertyCurly","colorKeyword","ud","javascript","js","escape","parsedName","inValue","ruleLookups","isRule","getLookup","hasParens","elem","elemIndex","isCall","expressionContainsNamed","nameLoop","expressions","hasSep","throwAwayComments","cond","argInfo","conditions","block","lookupValue","attribute","slashedCombinator","isLess","allExtends","when","blockRuleset","hasDR","ruleProperty","permissiveValue","anonymousValue","untilTokens","done","testCurrentChar","dir","importOptions","mediaFeatures","optionName","importOption","mediaFeature","pluginArgs","nonVendorSpecificName","hasIdentifier","hasExpression","hasUnknown","hasBlock","sub","addition","multiplication","operation","operand","needsParens","logical","next","conditionAnd","negatedCondition","parenthesisCondition","atomicCondition","body","me","tryConditionFollowedByParenthesis","delim","simpleProperty","colorFunctions","trueValue","falseValue","hsla","origColor","hsl","toHSV","number","rgba","size","m1","m2","hue","hsv","hsva","vs","floor","perm","saturation","lightness","hsvhue","hsvsaturation","hsvvalue","red","green","blue","luma","luminance","saturate","amount","method","desaturate","lighten","darken","fadein","fadeout","fade","spin","mix","color1","color2","weight","w","w1","w2","greyscale","contrast","dark","light","threshold","t","argb","toARGB","tint","shade","colorBlend","mode","cb","cs","ar","cr","ab","as","colorBlendModeFunctions","multiply","screen","overlay","softlight","sqrt","hardlight","difference","abs","exclusion","average","negation","getItemsFromNode","_SELF","values","step","from","to","stepValue","list","each","rs","iterator","Quote","valueName","keyName","indexName","MathHelper","fn","mathFunctions","ceil","tan","sin","cos","atan","asin","acos","mathHelper","fraction","pm","minMax","isMin","currentUnified","referenceUnified","unitStatic","unitClone","order","convert","pi","mod","y","percentage","evaluated","encodeURI","pattern","token","encodeURIComponent","isa","Type","isunit","isruleset","iscolor","isnumber","isstring","iskeyword","isurl","ispixel","ispercentage","isem","colorBlending","fallback","functionThis","mimetypeNode","filePathNode","mimetype","filePath","entryPath","fragmentStart","rawBuffer","getFileManager","useBase64","mimeLookup","charsetLookup","fileSync","loadFileSync","buf","encodeBase64","uri","dataUri","direction","stops","gradientDirectionSvg","position","positionValue","gradientType","rectangleDimension","renderEnv","directionValue","throwArgumentDescriptor","types","evaldRoot","evalEnv","visitorIterator","preEvalVisitors","first","isPreEvalVisitor","isPreVisitor","PluginManager","postProcessors","installedPlugins","pluginCache","Loader","PluginLoader","install","preProcessor","priority","indexToInsertAt","postProcessor","manager","PluginManagerFactory","newFactory","SourceMapOutput","_css","_rootNode","_contentsMap","contentsMap","_contentsIgnoredCharsMap","contentsIgnoredCharsMap","sourceMapFilename","_sourceMapFilename","_outputFilename","outputFilename","sourceMapURL","sourceMapBasepath","_sourceMapBasepath","sourceMapRootpath","_sourceMapRootpath","_outputSourceFiles","outputSourceFiles","_sourceMapGeneratorConstructor","getSourceMapGenerator","_lineNumber","_column","removeBasepath","sourceLines","columns","sourceColumns","inputSource","_sourceMapGenerator","addMapping","generated","normalizeFilename","file","sourceRoot","setSourceContent","sourceMapContent","stringify","toJSON","sourceMap","sourceMapOutput","Environment","SourceMapBuilder","sourceMapOutputFilename","sourceMapGenerator","sourceMapFileInline","sourceMapInputFilename","getCSSAppendage","sourceMapBuilder","ParseTree","transformTree","toCSSOptions","getPostProcessors","getExternalSourceMap","files","rootFilename","parseTree","ImportManager","rootFileInfo","mime","queue","importManager","pluginLoader","fileParsedFunc","importedEqualsRoot","newFileInfo","promise","loadFileCallback","loadedFile","resolvedFilename","pathDiff","isPathAbsolute","alwaysMakePathsAbsolute","newEnv","evalPlugin","loadPlugin","loadFile","render","Render","reUsePluginManager","evalResult","fileContent","Functions","initial","data","ctor","api","fileCache","errback","xhr","XMLHttpRequest","async","isFileProtocol","fileAsync","handleResponse","status","responseText","getResponseHeader","overrideMimeType","open","setRequestHeader","send","onreadystatechange","readyState","location","useFileCache","lessText","webInfo","lastModified","doXHR","log","fulfill","catch","rootHref","errorReporting","errors","errorline","classname","logLevel","errorConsole","timer","filenameNoPath","className","innerHTML","browser","style","env","setInterval","replaceChild","clearInterval","errorHTML","remove","removeErrorHTML","depends","lint","insecure","protocol","poll","hostname","port","onReady","addDefaultOptions","LESS_PLUGINS","lessRoot","FM","addFileManager","loggers","console","LogListener","ErrorReporting","cache","localStorage","setCSS","setItem","getCSS","getItem","timestamp","valueOf","Cache","imageSize","imageFunctions","ImageSize","typePattern","thisArg","curryArgs","loadStyles","instanceOptions","loadStyleSheet","reload","remaining","local","loadInitialFileCallback","loadStyleSheets","sheets","watch","watchMode","watchTimer","clearFileCache","unwatch","registerStylesheetsImmediately","links","rel","registerStylesheets","record","refresh","startTime","endTime","totalMilliseconds","remainingSheets","refreshStyles","resolveOrReject","pageLoadFinished"],"mappings":";;;;;;;;;0LACO,SAASA,EAAUC,UACfA,EAAKC,QAAQ,sBAAuB,IACtCA,QAAQ,uBAAwB,IAChCA,QAAQ,MAAO,IACfA,QAAQ,eAAgB,IACxBA,QAAQ,aAAc,KACtBA,QAAQ,MAAO,KAGjB,SAASC,EAAYC,EAASC,OAC5B,IAAMC,KAAOD,EAAIE,WACdF,EAAIE,QAAQC,eAAeF,MACf,QAARA,GAAyB,oBAARA,GAAqC,aAARA,GAA8B,mBAARA,EACpEF,EAAQE,GAAOD,EAAIE,QAAQD,YAGvBF,EAAQE,GAAOG,KAAKC,MAAML,EAAIE,QAAQD,IAE1C,MAAOK,WCjBR,CACXC,UAAW,SAAUC,EAAUC,EAAQC,OAE7Bd,EAAOc,EAAMd,MAAQ,GAGrBe,iBAAaD,EAAME,OAASC,EAAgBjB,IAG5CkB,EAAeN,EAASO,eAAeJ,GACzCK,GAAmB,EAGjBC,EAAYT,EAASU,cAAc,SACzCD,EAAUE,aAAa,OAAQ,YAC3BT,EAAMU,OACNH,EAAUE,aAAa,QAAST,EAAMU,OAE1CH,EAAUN,GAAKA,EAEVM,EAAUI,aACXJ,EAAUK,YAAYd,EAASe,eAAed,IAG9CO,EAAqC,OAAjBF,GAAyBA,EAAaU,WAAWC,OAAS,GAAKR,EAAUO,WAAWC,OAAS,GAC7GX,EAAaY,WAAWC,YAAcV,EAAUS,WAAWC,eAG7DC,EAAOpB,EAASqB,qBAAqB,QAAQ,MAI9B,OAAjBf,IAA8C,IAArBE,EAA4B,KAC/Cc,EAASpB,GAASA,EAAMqB,aAAe,KACzCD,EACAA,EAAOE,WAAWC,aAAahB,EAAWa,GAE1CF,EAAKN,YAAYL,MAGrBH,IAAqC,IAArBE,GAChBF,EAAakB,WAAWE,YAAYpB,GAMpCG,EAAUI,eAENJ,EAAUI,WAAWc,QAAU1B,EACjC,MAAO2B,SACC,IAAIC,MAAM,2CAI5BC,cAAe,SAASC,OAGVC,EAFJhC,EAAW+B,EAAO/B,gBACjBA,EAAS8B,gBACNE,EAAUhC,EAASqB,qBAAqB,WAC/BW,EAAQf,OAAS,s7DC7D7B,WACC,uBACG,eACR,qBACM,gBACL,gBACA,iBACC,gBACD,yBACS,eACV,qBACM,gBACL,oBACI,oBACA,qBACC,oBACD,gBACJ,yBACS,mBACN,kBACD,eACH,mBACI,mBACA,wBACK,mBACL,mBACA,oBACC,oBACA,sBACE,yBACG,qBACJ,qBACA,kBACH,qBACG,uBACE,wBACC,wBACA,wBACA,wBACA,qBACH,mBACF,sBACG,kBACJ,kBACA,qBACG,oBACD,sBACE,sBACA,kBACJ,oBACE,qBACC,eACN,oBACK,eACL,eACA,gBACC,sBACM,mBACH,kBACD,oBACE,iBACH,gBACD,gBACA,mBACG,wBACK,oBACJ,uBACG,oBACH,qBACC,oBACD,+BACW,oBACX,oBACA,qBACC,oBACD,sBACE,wBACE,uBACD,yBACE,yBACA,yBACA,sBACH,eACP,oBACK,gBACJ,kBACE,iBACD,2BACU,qBACN,uBACE,uBACA,yBACE,0BACC,4BACE,0BACF,0BACA,uBACH,oBACH,oBACA,mBACD,sBACG,eACP,kBACG,gBACF,oBACI,iBACH,oBACG,iBACH,wBACO,oBACJ,wBACI,wBACA,qBACH,oBACD,eACL,eACA,eACA,qBACM,iBACJ,wBACO,cACV,oBACM,oBACA,sBACE,iBACL,qBACI,mBACF,mBACA,iBACF,iBACA,kBACC,oBACE,oBACA,oBACA,eACL,sBACO,oBACF,cACN,eACC,kBACG,iBACD,oBACG,iBACH,gBACD,gBACA,qBACK,iBACJ,sBACK,aCpJH,CACXA,OAAQ,GACC,KACC,OACA,QACA,SACA,MAAS,MACT,MAAS,MACT,MAAS,GAAK,IAExBgB,SAAU,GACD,KACC,MAEVC,MAAO,KACI,GAAK,EAAIC,KAAKC,QACd,EAAI,SACH,WACA,MCfD,CAAEC,OAAAA,EAAQC,gBAAAA,GCHnBC,yCAEOC,OAAS,UACTC,sBAAmBC,OACnBC,iBAAcD,OACdE,SAAW,UACXC,OAAS,SAERC,EAAOC,KACbC,OAAOC,eAAeF,KAAM,kBAAmB,CAC3CG,IAAK,kBAAoBJ,EAAKK,cAElCH,OAAOC,eAAeF,KAAM,QAAS,CACjCG,IAAK,kBAAoBJ,EAAKM,0DAK5BC,EAAOb,YACJc,EAAIC,GACLA,GAAQA,aAAgB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"}